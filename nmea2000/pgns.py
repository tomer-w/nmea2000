from .utils import *
from .message import NMEA2000Message, NMEA2000Field, LookupFieldTypeEnumeration, int_to_bytes
from .consts import PhysicalQuantities, FieldTypes

master_dict = {

    'LIGHTING_COMMAND': {
        0: "Idle",
        1: "Detect Devices",
        2: "Reboot",
        3: "Factory Reset",
        4: "Powering Up",
    },
    'INDUSTRY_CODE': {
        0: "Global",
        1: "Highway",
        2: "Agriculture",
        3: "Construction",
        4: "Marine",
        5: "Industrial",
    },
    'MANUFACTURER_CODE': {
        69: "ARKS Enterprises, Inc.",
        78: "FW Murphy/Enovation Controls",
        80: "Twin Disc",
        85: "Kohler Power Systems",
        88: "Hemisphere GPS Inc",
        116: "BEP Marine",
        135: "Airmar",
        137: "Maretron",
        140: "Lowrance",
        144: "Mercury Marine",
        147: "Nautibus Electronic GmbH",
        148: "Blue Water Data",
        154: "Westerbeke",
        161: "Offshore Systems (UK) Ltd.",
        163: "Evinrude/BRP",
        165: "CPAC Systems AB",
        168: "Xantrex Technology Inc.",
        172: "Yanmar Marine",
        174: "Volvo Penta",
        175: "Honda Marine",
        176: "Carling Technologies Inc. (Moritz Aerospace)",
        185: "Beede Instruments",
        192: "Floscan Instrument Co. Inc.",
        193: "Nobletec",
        198: "Mystic Valley Communications",
        199: "Actia",
        200: "Honda Marine",
        201: "Disenos Y Technologia",
        211: "Digital Switching Systems",
        215: "Xintex/Atena",
        224: "EMMI NETWORK S.L.",
        225: "Honda Marine",
        228: "ZF",
        229: "Garmin",
        233: "Yacht Monitoring Solutions",
        235: "Sailormade Marine Telemetry/Tetra Technology LTD",
        243: "Eride",
        250: "Honda Marine",
        257: "Honda Motor Company LTD",
        272: "Groco",
        273: "Actisense",
        274: "Amphenol LTW Technology",
        275: "Navico",
        283: "Hamilton Jet",
        285: "Sea Recovery",
        286: "Coelmo SRL Italy",
        295: "BEP Marine",
        304: "Empir Bus",
        305: "NovAtel",
        306: "Sleipner Motor AS",
        307: "MBW Technologies",
        311: "Fischer Panda",
        315: "ICOM",
        328: "Qwerty",
        329: "Dief",
        341: "Boening Automationstechnologie GmbH & Co. KG",
        345: "Korean Maritime University",
        351: "Thrane and Thrane",
        355: "Mastervolt",
        356: "Fischer Panda Generators",
        358: "Victron Energy",
        370: "Rolls Royce Marine",
        373: "Electronic Design",
        374: "Northern Lights",
        378: "Glendinning",
        381: "B & G",
        384: "Rose Point Navigation Systems",
        385: "Johnson Outdoors Marine Electronics Inc Geonav",
        394: "Capi 2",
        396: "Beyond Measure",
        400: "Livorsi Marine",
        404: "ComNav",
        409: "Chetco",
        419: "Fusion Electronics",
        421: "Standard Horizon",
        422: "True Heading AB",
        426: "Egersund Marine Electronics AS",
        427: "em-trak Marine Electronics",
        431: "Tohatsu Co, JP",
        437: "Digital Yacht",
        438: "Comar Systems Limited",
        440: "Cummins",
        443: "VDO (aka Continental-Corporation)",
        451: "Parker Hannifin aka Village Marine Tech",
        459: "Alltek Marine Electronics Corp",
        460: "SAN GIORGIO S.E.I.N",
        466: "Veethree Electronics & Marine",
        467: "Humminbird Marine Electronics",
        470: "SI-TEX Marine Electronics",
        471: "Sea Cross Marine AB",
        475: "GME aka Standard Communications Pty LTD",
        476: "Humminbird Marine Electronics",
        478: "Ocean Sat BV",
        481: "Chetco Digitial Instruments",
        493: "Watcheye",
        499: "Lcj Capteurs",
        502: "Attwood Marine",
        503: "Naviop S.R.L.",
        504: "Vesper Marine Ltd",
        510: "Marinesoft Co. LTD",
        517: "NoLand Engineering",
        518: "Transas USA",
        529: "National Instruments Korea",
        532: "Onwa Marine",
        571: "Marinecraft (South Korea)",
        573: "McMurdo Group aka Orolia LTD",
        578: "Advansea",
        579: "KVH",
        580: "San Jose Technology",
        583: "Yacht Control",
        586: "Suzuki Motor Corporation",
        591: "US Coast Guard",
        595: "Ship Module aka Customware",
        600: "Aquatic AV",
        605: "Aventics GmbH",
        606: "Intellian",
        612: "SamwonIT",
        614: "Arlt Tecnologies",
        637: "Bavaria Yacts",
        641: "Diverse Yacht Services",
        644: "Wema U.S.A dba KUS",
        645: "Garmin",
        658: "Shenzhen Jiuzhou Himunication",
        688: "Rockford Corp",
        704: "JL Audio",
        715: "Autonnic",
        717: "Yacht Devices",
        734: "REAP Systems",
        735: "Au Electronics Group",
        739: "LxNav",
        743: "DaeMyung",
        744: "Woosung",
        773: "Clarion US",
        776: "HMI Systems",
        777: "Ocean Signal",
        778: "Seekeeper",
        781: "Poly Planar",
        785: "Fischer Panda DE",
        795: "Broyda Industries",
        796: "Canadian Automotive",
        797: "Tides Marine",
        798: "Lumishore",
        799: "Still Water Designs and Audio",
        802: "BJ Technologies (Beneteau)",
        803: "Gill Sensors",
        811: "Blue Water Desalination",
        815: "FLIR",
        824: "Undheim Systems",
        838: "TeamSurv",
        844: "Fell Marine",
        847: "Oceanvolt",
        862: "Prospec",
        868: "Data Panel Corp",
        890: "L3 Technologies",
        894: "Rhodan Marine Systems",
        896: "Nexfour Solutions",
        905: "ASA Electronics",
        909: "Marines Co (South Korea)",
        911: "Nautic-on",
        930: "Ecotronix",
        962: "Timbolier Industries",
        963: "TJC Micro",
        968: "Cox Powertrain",
        969: "Blue Seas",
        1417: "Revatek",
        1850: "Teleflex Marine (SeaStar Solutions)",
        1851: "Raymarine",
        1852: "Navionics",
        1853: "Japan Radio Co",
        1854: "Northstar Technologies",
        1855: "Furuno",
        1856: "Trimble",
        1857: "Simrad",
        1858: "Litton",
        1859: "Kvasar AB",
        1860: "MMP",
        1861: "Vector Cantech",
        1862: "Yamaha Marine",
        1863: "Faria Instruments",
    },
    'AIS_MESSAGE_ID': {
        1: "Scheduled Class A position report",
        2: "Assigned scheduled Class A position report",
        3: "Interrogated Class A position report",
        4: "Base station report",
        5: "Static and voyage related data",
        6: "Binary addressed message",
        7: "Binary acknowledgement",
        8: "Binary broadcast message",
        9: "Standard SAR aircraft position report",
        10: "UTC/date inquiry",
        11: "UTC/date response",
        12: "Safety related addressed message",
        13: "Safety related acknowledgement",
        14: "Satety related broadcast message",
        15: "Interrogation",
        16: "Assignment mode command",
        17: "DGNSS broadcast binary message",
        18: "Standard Class B position report",
        19: "Extended Class B position report",
        20: "Data link management message",
        21: "ATON report",
        22: "Channel management",
        23: "Group assignment command",
        24: "Static data report",
        25: "Single slot binary message",
        26: "Multiple slot binary message",
        27: "Position report for long range applications",
    },
    'SHIP_TYPE': {
        0: "Unavailable",
        20: "Wing In Ground",
        21: "Wing In Ground (hazard cat X)",
        22: "Wing In Ground (hazard cat Y)",
        23: "Wing In Ground (hazard cat Z)",
        24: "Wing In Ground (hazard cat OS)",
        29: "Wing In Ground (no additional information)",
        30: "Fishing",
        31: "Towing",
        32: "Towing exceeds 200m or wider than 25m",
        33: "Engaged in dredging or underwater operations",
        34: "Engaged in diving operations",
        35: "Engaged in military operations",
        36: "Sailing",
        37: "Pleasure",
        40: "High speed craft",
        41: "High speed craft (hazard cat X)",
        42: "High speed craft (hazard cat Y)",
        43: "High speed craft (hazard cat Z)",
        44: "High speed craft (hazard cat OS)",
        49: "High speed craft (no additional information)",
        50: "Pilot vessel",
        51: "SAR",
        52: "Tug",
        53: "Port tender",
        54: "Anti-pollution",
        55: "Law enforcement",
        56: "Spare",
        57: "Spare #2",
        58: "Medical",
        59: "Ships and aircraft of States not parties to an armed conflict",
        60: "Passenger ship",
        61: "Passenger ship (hazard cat X)",
        62: "Passenger ship (hazard cat Y)",
        63: "Passenger ship (hazard cat Z)",
        64: "Passenger ship (hazard cat OS)",
        69: "Passenger ship (no additional information)",
        70: "Cargo ship",
        71: "Cargo ship (hazard cat X)",
        72: "Cargo ship (hazard cat Y)",
        73: "Cargo ship (hazard cat Z)",
        74: "Cargo ship (hazard cat OS)",
        79: "Cargo ship (no additional information)",
        80: "Tanker",
        81: "Tanker (hazard cat X)",
        82: "Tanker (hazard cat Y)",
        83: "Tanker (hazard cat Z)",
        84: "Tanker (hazard cat OS)",
        89: "Tanker (no additional information)",
        90: "Other",
        91: "Other (hazard cat X)",
        92: "Other (hazard cat Y)",
        93: "Other (hazard cat Z)",
        94: "Other (hazard cat OS)",
        99: "Other (no additional information)",
    },
    'DEVICE_CLASS': {
        0: "Reserved for 2000 Use",
        10: "System tools",
        20: "Safety systems",
        25: "Internetwork device",
        30: "Electrical Distribution",
        35: "Electrical Generation",
        40: "Steering and Control surfaces",
        50: "Propulsion",
        60: "Navigation",
        70: "Communication",
        75: "Sensor Communication Interface",
        80: "Instrumentation/general systems",
        85: "External Environment",
        90: "Internal Environment",
        100: "Deck + cargo + fishing equipment systems",
        110: "Human Interface",
        120: "Display",
        125: "Entertainment",
    },
    'REPEAT_INDICATOR': {
        0: "Initial",
        1: "First retransmission",
        2: "Second retransmission",
        3: "Final retransmission",
    },
    'TX_RX_MODE': {
        0: "Tx A/Tx B, Rx A/Rx B",
        1: "Tx A, Rx A/Rx B",
        2: "Tx B, Rx A/Rx B",
    },
    'STATION_TYPE': {
        0: "All types of mobile station",
        2: "All types of Class B mobile station",
        3: "SAR airborne mobile station",
        4: "AtoN station",
        5: "Class B CS shipborne mobile station",
        6: "Inland waterways",
        7: "Regional use 7",
        8: "Regional use 8",
        9: "Regional use 9",
    },
    'REPORTING_INTERVAL': {
        0: "As given by the autonomous mode",
        1: "10 min",
        2: "6 min",
        3: "3 min",
        4: "1 min",
        5: "30 sec",
        6: "15 sec",
        7: "10 sec",
        8: "5 sec",
        9: "2 sec (not applicable to Class B CS)",
        10: "Next shorter reporting interval",
        11: "Next longer reporting interval",
    },
    'AIS_TRANSCEIVER': {
        0: "Channel A VDL reception",
        1: "Channel B VDL reception",
        2: "Channel A VDL transmission",
        3: "Channel B VDL transmission",
        4: "Own information not broadcast",
        5: "Reserved",
    },
    'AIS_ASSIGNED_MODE': {
        0: "Autonomous and continuous",
        1: "Assigned mode",
    },
    'ATON_TYPE': {
        0: "Default: Type of AtoN not specified",
        1: "Reference point",
        2: "RACON",
        3: "Fixed structure off-shore",
        4: "Reserved for future use",
        5: "Fixed light: without sectors",
        6: "Fixed light: with sectors",
        7: "Fixed leading light front",
        8: "Fixed leading light rear",
        9: "Fixed beacon: cardinal N",
        10: "Fixed beacon: cardinal E",
        11: "Fixed beacon: cardinal S",
        12: "Fixed beacon: cardinal W",
        13: "Fixed beacon: port hand",
        14: "Fixed beacon: starboard hand",
        15: "Fixed beacon: preferred channel port hand",
        16: "Fixed beacon: preferred channel starboard hand",
        17: "Fixed beacon: isolated danger",
        18: "Fixed beacon: safe water",
        19: "Fixed beacon: special mark",
        20: "Floating AtoN: cardinal N",
        21: "Floating AtoN: cardinal E",
        22: "Floating AtoN: cardinal S",
        23: "Floating AtoN: cardinal W",
        24: "Floating AtoN: port hand mark",
        25: "Floating AtoN: starboard hand mark",
        26: "Floating AtoN: preferred channel port hand",
        27: "Floating AtoN: preferred channel starboard hand",
        28: "Floating AtoN: isolated danger",
        29: "Floating AtoN: safe water",
        30: "Floating AtoN: special mark",
        31: "Floating AtoN: light vessel/LANBY/rigs",
    },
    'AIS_SPECIAL_MANEUVER': {
        0: "Not available",
        1: "Not engaged in special maneuver",
        2: "Engaged in special maneuver",
        3: "Reserved",
    },
    'POSITION_FIX_DEVICE': {
        0: "Default: undefined",
        1: "GPS",
        2: "GLONASS",
        3: "Combined GPS/GLONASS",
        4: "Loran-C",
        5: "Chayka",
        6: "Integrated navigation system",
        7: "Surveyed",
        8: "Galileo",
        15: "Internal GNSS",
    },
    'GNS': {
        0: "GPS",
        1: "GLONASS",
        2: "GPS+GLONASS",
        3: "GPS+SBAS/WAAS",
        4: "GPS+SBAS/WAAS+GLONASS",
        5: "Chayka",
        6: "integrated",
        7: "surveyed",
        8: "Galileo",
    },
    'ENGINE_INSTANCE': {
        0: "Single Engine or Dual Engine Port",
        1: "Dual Engine Starboard",
    },
    'GEAR_STATUS': {
        0: "Forward",
        1: "Neutral",
        2: "Reverse",
    },
    'DIRECTION': {
        0: "Forward",
        1: "Reverse",
    },
    'POSITION_ACCURACY': {
        0: "Low",
        1: "High",
    },
    'RAIM_FLAG': {
        0: "not in use",
        1: "in use",
    },
    'TIME_STAMP': {
        60: "Not available",
        61: "Manual input mode",
        62: "Dead reckoning mode",
        63: "Positioning system is inoperative",
    },
    'GNS_METHOD': {
        0: "no GNSS",
        1: "GNSS fix",
        2: "DGNSS fix",
        3: "Precise GNSS",
        4: "RTK Fixed Integer",
        5: "RTK float",
        6: "Estimated (DR) mode",
        7: "Manual Input",
        8: "Simulate mode",
    },
    'GNS_INTEGRITY': {
        0: "No integrity checking",
        1: "Safe",
        2: "Caution",
    },
    'SYSTEM_TIME': {
        0: "GPS",
        1: "GLONASS",
        2: "Radio Station",
        3: "Local Cesium clock",
        4: "Local Rubidium clock",
        5: "Local Crystal clock",
    },
    'MAGNETIC_VARIATION': {
        0: "Manual",
        1: "Automatic Chart",
        2: "Automatic Table",
        3: "Automatic Calculation",
        4: "WMM 2000",
        5: "WMM 2005",
        6: "WMM 2010",
        7: "WMM 2015",
        8: "WMM 2020",
    },
    'RESIDUAL_MODE': {
        0: "Autonomous",
        1: "Differential enhanced",
        2: "Estimated",
        3: "Simulator",
        4: "Manual",
    },
    'WIND_REFERENCE': {
        0: "True (ground referenced to North)",
        1: "Magnetic (ground referenced to Magnetic North)",
        2: "Apparent",
        3: "True (boat referenced)",
        4: "True (water referenced)",
    },
    'WATER_REFERENCE': {
        0: "Paddle wheel",
        1: "Pitot tube",
        2: "Doppler",
        3: "Correlation (ultra sound)",
        4: "Electro Magnetic",
    },
    'YES_NO': {
        0: "No",
        1: "Yes",
    },
    'OK_WARNING': {
        0: "OK",
        1: "Warning",
    },
    'OFF_ON': {
        0: "Off",
        1: "On",
    },
    'DIRECTION_REFERENCE': {
        0: "True",
        1: "Magnetic",
        2: "Error",
    },
    'DIRECTION_RUDDER': {
        0: "No Order",
        1: "Move to starboard",
        2: "Move to port",
    },
    'NAV_STATUS': {
        0: "Under way using engine",
        1: "At anchor",
        2: "Not under command",
        3: "Restricted maneuverability",
        4: "Constrained by her draught",
        5: "Moored",
        6: "Aground",
        7: "Engaged in Fishing",
        8: "Under way sailing",
        9: "Hazardous material - High Speed",
        10: "Hazardous material - Wing in Ground",
        11: "Power-driven vessel towing astern",
        12: "Power-driven vessel pushing ahead or towing alongside",
        14: "AIS-SART",
    },
    'POWER_FACTOR': {
        0: "Leading",
        1: "Lagging",
        2: "Error",
    },
    'TEMPERATURE_SOURCE': {
        0: "Sea Temperature",
        1: "Outside Temperature",
        2: "Inside Temperature",
        3: "Engine Room Temperature",
        4: "Main Cabin Temperature",
        5: "Live Well Temperature",
        6: "Bait Well Temperature",
        7: "Refrigeration Temperature",
        8: "Heating System Temperature",
        9: "Dew Point Temperature",
        10: "Apparent Wind Chill Temperature",
        11: "Theoretical Wind Chill Temperature",
        12: "Heat Index Temperature",
        13: "Freezer Temperature",
        14: "Exhaust Gas Temperature",
        15: "Shaft Seal Temperature",
    },
    'HUMIDITY_SOURCE': {
        0: "Inside",
        1: "Outside",
    },
    'PRESSURE_SOURCE': {
        0: "Atmospheric",
        1: "Water",
        2: "Steam",
        3: "Compressed Air",
        4: "Hydraulic",
        5: "Filter",
        6: "AltimeterSetting",
        7: "Oil",
        8: "Fuel",
    },
    'DSC_FORMAT': {
        102: "Geographical area",
        112: "Distress",
        114: "Common interest",
        116: "All ships",
        120: "Individual stations",
        121: "Non-calling purpose",
        123: "Individual station automatic",
    },
    'DSC_CATEGORY': {
        100: "Routine",
        108: "Safety",
        110: "Urgency",
        112: "Distress",
    },
    'DSC_NATURE': {
        100: "Fire",
        101: "Flooding",
        102: "Collision",
        103: "Grounding",
        104: "Listing",
        105: "Sinking",
        106: "Disabled and adrift",
        107: "Undesignated",
        108: "Abandoning ship",
        109: "Piracy",
        110: "Man overboard",
        112: "EPIRB emission",
    },
    'DSC_FIRST_TELECOMMAND': {
        100: "F3E/G3E All modes TP",
        101: "F3E/G3E duplex TP",
        103: "Polling",
        104: "Unable to comply",
        105: "End of call",
        106: "Data",
        109: "J3E TP",
        110: "Distress acknowledgement",
        112: "Distress relay",
        113: "F1B/J2B TTY-FEC",
        115: "F1B/J2B TTY-ARQ",
        118: "Test",
        121: "Ship position or location registration updating",
        126: "No information",
    },
    'DSC_SECOND_TELECOMMAND': {
        100: "No reason given",
        101: "Congestion at MSC",
        102: "Busy",
        103: "Queue indication",
        104: "Station barred",
        105: "No operator available",
        106: "Operator temporarily unavailable",
        107: "Equipment disabled",
        108: "Unable to use proposed channel",
        109: "Unable to use proposed mode",
        110: "Ships and aircraft of States not parties to an armed conflict",
        111: "Medical transports",
        112: "Pay phone/public call office",
        113: "Fax/data",
        126: "No information",
    },
    'DSC_EXPANSION_DATA': {
        100: "Enhanced position",
        101: "Source and datum of position",
        102: "SOG",
        103: "COG",
        104: "Additional station identification",
        105: "Enhanced geographic area",
        106: "Number of persons on board",
    },
    'SEATALK_ALARM_STATUS': {
        0: "Alarm condition not met",
        1: "Alarm condition met and not silenced",
        2: "Alarm condition met and silenced",
    },
    'SEATALK_ALARM_ID': {
        0: "No Alarm",
        1: "Shallow Depth",
        2: "Deep Depth",
        3: "Shallow Anchor",
        4: "Deep Anchor",
        5: "Off Course",
        6: "AWA High",
        7: "AWA Low",
        8: "AWS High",
        9: "AWS Low",
        10: "TWA High",
        11: "TWA Low",
        12: "TWS High",
        13: "TWS Low",
        14: "WP Arrival",
        15: "Boat Speed High",
        16: "Boat Speed Low",
        17: "Sea Temperature High",
        18: "Sea Temperature Low",
        19: "Pilot Watch",
        20: "Pilot Off Course",
        21: "Pilot Wind Shift",
        22: "Pilot Low Battery",
        23: "Pilot Last Minute Of Watch",
        24: "Pilot No NMEA Data",
        25: "Pilot Large XTE",
        26: "Pilot NMEA DataError",
        27: "Pilot CU Disconnected",
        28: "Pilot Auto Release",
        29: "Pilot Way Point Advance",
        30: "Pilot Drive Stopped",
        31: "Pilot Type Unspecified",
        32: "Pilot Calibration Required",
        33: "Pilot Last Heading",
        34: "Pilot No Pilot",
        35: "Pilot Route Complete",
        36: "Pilot Variable Text",
        37: "GPS Failure",
        38: "MOB",
        39: "Seatalk1 Anchor",
        40: "Pilot Swapped Motor Power",
        41: "Pilot Standby Too Fast To Fish",
        42: "Pilot No GPS Fix",
        43: "Pilot No GPS COG",
        44: "Pilot Start Up",
        45: "Pilot Too Slow",
        46: "Pilot No Compass",
        47: "Pilot Rate Gyro Fault",
        48: "Pilot Current Limit",
        49: "Pilot Way Point Advance Port",
        50: "Pilot Way Point Advance Stbd",
        51: "Pilot No Wind Data",
        52: "Pilot No Speed Data",
        53: "Pilot Seatalk Fail1",
        54: "Pilot Seatalk Fail2",
        55: "Pilot Warning Too Fast To Fish",
        56: "Pilot Auto Dockside Fail",
        57: "Pilot Turn Too Fast",
        58: "Pilot No Nav Data",
        59: "Pilot Lost Waypoint Data",
        60: "Pilot EEPROM Corrupt",
        61: "Pilot Rudder Feedback Fail",
        62: "Pilot Autolearn Fail1",
        63: "Pilot Autolearn Fail2",
        64: "Pilot Autolearn Fail3",
        65: "Pilot Autolearn Fail4",
        66: "Pilot Autolearn Fail5",
        67: "Pilot Autolearn Fail6",
        68: "Pilot Warning Cal Required",
        69: "Pilot Warning OffCourse",
        70: "Pilot Warning XTE",
        71: "Pilot Warning Wind Shift",
        72: "Pilot Warning Drive Short",
        73: "Pilot Warning Clutch Short",
        74: "Pilot Warning Solenoid Short",
        75: "Pilot Joystick Fault",
        76: "Pilot No Joystick Data",
        80: "Pilot Invalid Command",
        81: "AIS TX Malfunction",
        82: "AIS Antenna VSWR fault",
        83: "AIS Rx channel 1 malfunction",
        84: "AIS Rx channel 2 malfunction",
        85: "AIS No sensor position in use",
        86: "AIS No valid SOG information",
        87: "AIS No valid COG information",
        88: "AIS 12V alarm",
        89: "AIS 6V alarm",
        90: "AIS Noise threshold exceeded channel A",
        91: "AIS Noise threshold exceeded channel B",
        92: "AIS Transmitter PA fault",
        93: "AIS 3V3 alarm",
        94: "AIS Rx channel 70 malfunction",
        95: "AIS Heading lost/invalid",
        96: "AIS internal GPS lost",
        97: "AIS No sensor position",
        98: "AIS Lock failure",
        99: "AIS Internal GGA timeout",
        100: "AIS Protocol stack restart",
        101: "Pilot No IPS communications",
        102: "Pilot Power-On or Sleep-Switch Reset While Engaged",
        103: "Pilot Unexpected Reset While Engaged",
        104: "AIS Dangerous Target",
        105: "AIS Lost Target",
        106: "AIS Safety Related Message (used to silence)",
        107: "AIS Connection Lost",
        108: "No Fix",
    },
    'SEATALK_ALARM_GROUP': {
        0: "Instrument",
        1: "Autopilot",
        2: "Radar",
        3: "Chart Plotter",
        4: "AIS",
    },
    'SEATALK_PILOT_MODE': {
        64: "Standby",
        66: "Auto",
        70: "Wind",
        74: "Track",
    },
    'ENTERTAINMENT_ZONE': {
        0: "All zones",
        1: "Zone 1",
        2: "Zone 2",
        3: "Zone 3",
        4: "Zone 4",
    },
    'ENTERTAINMENT_SOURCE': {
        0: "Vessel alarm",
        1: "AM",
        2: "FM",
        3: "Weather",
        4: "DAB",
        5: "Aux",
        6: "USB",
        7: "CD",
        8: "MP3",
        9: "Apple iOS",
        10: "Android",
        11: "Bluetooth",
        12: "Sirius XM",
        13: "Pandora",
        14: "Spotify",
        15: "Slacker",
        16: "Songza",
        17: "Apple Radio",
        18: "Last FM",
        19: "Ethernet",
        20: "Video MP4",
        21: "Video DVD",
        22: "Video BluRay",
        23: "HDMI",
        24: "Video",
    },
    'ENTERTAINMENT_PLAY_STATUS': {
        0: "Play",
        1: "Pause",
        2: "Stop",
        3: "FF 1x",
        4: "FF 2x",
        5: "FF 3x",
        6: "FF 4x",
        7: "RW 1x",
        8: "RW 2x",
        9: "RW 3x",
        10: "RW 4x",
        11: "Skip ahead",
        12: "Skip back",
        13: "Jog ahead",
        14: "Jog back",
        15: "Seek up",
        16: "Seek down",
        17: "Scan up",
        18: "Scan down",
        19: "Tune up",
        20: "Tune down",
        21: "Slow motion .75x",
        22: "Slow motion .5x",
        23: "Slow motion .25x",
        24: "Slow motion .125x",
    },
    'ENTERTAINMENT_REPEAT_STATUS': {
        0: "Off",
        1: "One",
        2: "All",
    },
    'ENTERTAINMENT_SHUFFLE_STATUS': {
        0: "Off",
        1: "Play queue",
        2: "All",
    },
    'ENTERTAINMENT_LIKE_STATUS': {
        0: "None",
        1: "Thumbs up",
        2: "Thumbs down",
    },
    'ENTERTAINMENT_TYPE': {
        0: "File",
        1: "Playlist Name",
        2: "Genre Name",
        3: "Album Name",
        4: "Artist Name",
        5: "Track Name",
        6: "Station Name",
        7: "Station Number",
        8: "Favourite Number",
        9: "Play Queue",
        10: "Content Info",
    },
    'ENTERTAINMENT_GROUP': {
        0: "File",
        1: "Playlist Name",
        2: "Genre Name",
        3: "Album Name",
        4: "Artist Name",
        5: "Track Name",
        6: "Station Name",
        7: "Station Number",
        8: "Favourite Number",
        9: "Play Queue",
        10: "Content Info",
    },
    'ENTERTAINMENT_CHANNEL': {
        0: "All channels",
        1: "Stereo full range",
        2: "Stereo front",
        3: "Stereo back",
        4: "Stereo surround",
        5: "Center",
        6: "Subwoofer",
        7: "Front left",
        8: "Front right",
        9: "Back left",
        10: "Back right",
        11: "Surround left",
        12: "Surround right",
    },
    'ENTERTAINMENT_EQ': {
        0: "Flat",
        1: "Rock",
        2: "Hall",
        3: "Jazz",
        4: "Pop",
        5: "Live",
        6: "Classic",
        7: "Vocal",
        8: "Arena",
        9: "Cinema",
        10: "Custom",
    },
    'ENTERTAINMENT_FILTER': {
        0: "Full range",
        1: "High pass",
        2: "Low pass",
        3: "Band pass",
        4: "Notch filter",
    },
    'ALERT_TYPE': {
        1: "Emergency Alarm",
        2: "Alarm",
        5: "Warning",
        8: "Caution",
    },
    'ALERT_CATEGORY': {
        0: "Navigational",
        1: "Technical",
    },
    'ALERT_TRIGGER_CONDITION': {
        0: "Manual",
        1: "Auto",
        2: "Test",
        3: "Disabled",
    },
    'ALERT_THRESHOLD_STATUS': {
        0: "Normal",
        1: "Threshold Exceeded",
        2: "Extreme Threshold Exceeded",
        3: "Low Threshold Exceeded",
        4: "Acknowledged",
        5: "Awaiting Acknowledge",
    },
    'ALERT_STATE': {
        0: "Disabled",
        1: "Normal",
        2: "Active",
        3: "Silenced",
        4: "Acknowledged",
        5: "Awaiting Acknowledge",
    },
    'ALERT_LANGUAGE_ID': {
        0: "English (US)",
        1: "English (UK)",
        2: "Arabic",
        3: "Chinese (simplified)",
        4: "Croatian",
        5: "Danish",
        6: "Dutch",
        7: "Finnish",
        8: "French",
        9: "German",
        10: "Greek",
        11: "Italian",
        12: "Japanese",
        13: "Korean",
        14: "Norwegian",
        15: "Polish",
        16: "Portuguese",
        17: "Russian",
        18: "Spanish",
        19: "Swedish",
    },
    'ALERT_RESPONSE_COMMAND': {
        0: "Acknowledge",
        1: "Temporary Silence",
        2: "Test Command off",
        3: "Test Command on",
    },
    'CONVERTER_STATE': {
        0: "Off",
        1: "Low Power Mode",
        2: "Fault",
        3: "Bulk",
        4: "Absorption",
        5: "Float",
        6: "Storage",
        7: "Equalize",
        8: "Pass thru",
        9: "Inverting",
        10: "Assisting",
    },
    'THRUSTER_DIRECTION_CONTROL': {
        0: "Off",
        1: "Ready",
        2: "To Port",
        3: "To Starboard",
    },
    'THRUSTER_RETRACT_CONTROL': {
        0: "Off",
        1: "Extend",
        2: "Retract",
    },
    'THRUSTER_MOTOR_TYPE': {
        0: "12VDC",
        1: "24VDC",
        2: "48VDC",
        3: "24VAC",
        4: "Hydraulic",
    },
    'BOOT_STATE': {
        0: "in Startup Monitor",
        1: "running Bootloader",
        2: "running Application",
    },
    'ACCESS_LEVEL': {
        0: "Locked",
        1: "unlocked level 1",
        2: "unlocked level 2",
    },
    'TRANSMISSION_INTERVAL': {
        0: "Acknowledge",
        1: "Transmit Interval/Priority not supported",
        2: "Transmit Interval too low",
        3: "Access denied",
        4: "Not supported",
    },
    'PARAMETER_FIELD': {
        0: "Acknowledge",
        1: "Invalid parameter field",
        2: "Temporary error",
        3: "Parameter out of range",
        4: "Access denied",
        5: "Not supported",
        6: "Read or Write not supported",
    },
    'PGN_LIST_FUNCTION': {
        0: "Transmit PGN list",
        1: "Receive PGN list",
    },
    'FUSION_COMMAND': {
        1: "Play",
        2: "Pause",
        4: "Next",
        6: "Prev",
    },
    'FUSION_SIRIUS_COMMAND': {
        1: "Next",
        2: "Prev",
    },
    'FUSION_MUTE_COMMAND': {
        1: "Mute On",
        2: "Mute Off",
    },
    'SEATALK_KEYSTROKE': {
        1: "Auto",
        2: "Standby",
        3: "Wind",
        5: "-1",
        6: "-10",
        7: "+1",
        8: "+10",
        33: "-1 and -10",
        34: "+1 and +10",
        35: "Track",
    },
    'SEATALK_DEVICE_ID': {
        3: "S100",
        5: "Course Computer",
    },
    'SEATALK_NETWORK_GROUP': {
        0: "None",
        1: "Helm 1",
        2: "Helm 2",
        3: "Cockpit",
        4: "Flybridge",
        5: "Mast",
        6: "Group 1",
        7: "Group 2",
        8: "Group 3",
        9: "Group 4",
        10: "Group 5",
    },
    'SEATALK_DISPLAY_COLOR': {
        0: "Day 1",
        2: "Day 2",
        3: "Red/Black",
        4: "Inverse",
    },
    'AIRMAR_CALIBRATE_FUNCTION': {
        0: "Normal/cancel calibration",
        1: "Enter calibration mode",
        2: "Reset calibration to 0",
        3: "Verify",
        4: "Reset compass to defaults",
        5: "Reset damping to defaults",
    },
    'AIRMAR_CALIBRATE_STATUS': {
        0: "Queried",
        1: "Passed",
        2: "Failed - timeout",
        3: "Failed - tilt error",
        4: "Failed - other",
        5: "In progress",
    },
    'AIRMAR_TEMPERATURE_INSTANCE': {
        0: "Device Sensor",
        1: "Onboard Water Sensor",
        2: "Optional Water Sensor",
    },
    'AIRMAR_FILTER': {
        0: "No filter",
        1: "Basic IIR filter",
    },
    'CONTROLLER_STATE': {
        0: "Error Active",
        1: "Error Passive",
        2: "Bus Off",
    },
    'EQUIPMENT_STATUS': {
        0: "Operational",
        1: "Fault",
    },
    'MOB_STATUS': {
        0: "MOB Emitter Activated",
        1: "Manual on-board MOB Button Activation",
        2: "Test mode",
    },
    'LOW_BATTERY': {
        0: "Good",
        1: "Low",
    },
    'TURN_MODE': {
        0: "Rudder limit controlled",
        1: "Turn rate controlled",
        2: "Radius controlled",
    },
    'ACCEPTABILITY': {
        0: "Bad level",
        1: "Bad frequency",
        2: "Being qualified",
        3: "Good",
    },
    'LINE': {
        0: "Line 1",
        1: "Line 2",
        2: "Line 3",
    },
    'WAVEFORM': {
        0: "Sine wave",
        1: "Modified sine wave",
    },
    'TANK_TYPE': {
        0: "Fuel",
        1: "Water",
        2: "Gray water",
        3: "Live well",
        4: "Oil",
        5: "Black water",
    },
    'DC_SOURCE': {
        0: "Battery",
        1: "Alternator",
        2: "Convertor",
        3: "Solar cell",
        4: "Wind generator",
    },
    'CHARGER_STATE': {
        0: "Not charging",
        1: "Bulk",
        2: "Absorption",
        3: "Overcharge",
        4: "Equalise",
        5: "Float",
        6: "No float",
        7: "Constant VI",
        8: "Disabled",
        9: "Fault",
    },
    'CHARGING_ALGORITHM': {
        0: "Trickle",
        1: "Constant voltage / Constant current",
        2: "2 stage (no float)",
        3: "3 stage",
    },
    'CHARGER_MODE': {
        0: "Standalone",
        1: "Primary",
        2: "Secondary",
        3: "Echo",
    },
    'INVERTER_STATE': {
        0: "Invert",
        1: "AC passthru",
        2: "Load sense",
        3: "Fault",
        4: "Disabled",
    },
    'BATTERY_TYPE': {
        0: "Flooded",
        1: "Gel",
        2: "AGM",
    },
    'BATTERY_VOLTAGE': {
        0: "6V",
        1: "12V",
        2: "24V",
        3: "32V",
        4: "36V",
        5: "42V",
        6: "48V",
    },
    'BATTERY_CHEMISTRY': {
        0: "Pb (Lead)",
        1: "Li",
        2: "NiCd",
        3: "ZnO",
        4: "NiMH",
    },
    'GOOD_WARNING_ERROR': {
        0: "Good",
        1: "Warning",
        2: "Error",
    },
    'TRACKING': {
        0: "Cancelled",
        1: "Acquiring",
        2: "Tracking",
        3: "Lost",
    },
    'TARGET_ACQUISITION': {
        0: "Manual",
        1: "Automatic",
    },
    'WINDLASS_DIRECTION': {
        0: "Off",
        1: "Down",
        2: "Up",
    },
    'SPEED_TYPE': {
        0: "Single speed",
        1: "Dual speed",
        2: "Proportional speed",
    },
    'WINDLASS_MOTION': {
        0: "Windlass stopped",
        1: "Deployment occurring",
        2: "Retrieval occurring",
    },
    'RODE_TYPE': {
        0: "Chain presently detected",
        1: "Rope presently detected",
    },
    'DOCKING_STATUS': {
        0: "Not docked",
        1: "Fully docked",
    },
    'AIS_TYPE': {
        0: "SOTDMA",
        1: "CS",
    },
    'AIS_BAND': {
        0: "Top 525 kHz of marine band",
        1: "Entire marine band",
    },
    'AIS_MODE': {
        0: "Autonomous",
        1: "Assigned",
    },
    'AIS_COMMUNICATION_STATE': {
        0: "SOTDMA",
        1: "ITDMA",
    },
    'AVAILABLE': {
        0: "Available",
        1: "Not available",
    },
    'BEARING_MODE': {
        0: "Great Circle",
        1: "Rhumbline",
    },
    'MARK_TYPE': {
        0: "Collision",
        1: "Turning point",
        2: "Reference",
        3: "Wheelover",
        4: "Waypoint",
    },
    'GNSS_MODE': {
        0: "1D",
        1: "2D",
        2: "3D",
        3: "Auto",
    },
    'RANGE_RESIDUAL_MODE': {
        0: "Range residuals were used to calculate data",
        1: "Range residuals were calculated after the position",
    },
    'DGNSS_MODE': {
        0: "None",
        1: "SBAS if available",
        3: "SBAS",
    },
    'SATELLITE_STATUS': {
        0: "Not tracked",
        1: "Tracked",
        2: "Used",
        3: "Not tracked+Diff",
        4: "Tracked+Diff",
        5: "Used+Diff",
    },
    'AIS_VERSION': {
        0: "ITU-R M.1371-1",
        1: "ITU-R M.1371-3",
        2: "ITU-R M.1371-5",
        3: "ITU-R M.1371 future edition",
    },
    'TIDE': {
        0: "Falling",
        1: "Rising",
    },
    'WATERMAKER_STATE': {
        0: "Stopped",
        1: "Starting",
        2: "Running",
        3: "Stopping",
        4: "Flushing",
        5: "Rinsing",
        6: "Initiating",
        7: "Manual",
    },
    'ENTERTAINMENT_ID_TYPE': {
        0: "Group",
        1: "File",
        2: "Encrypted group",
        3: "Encrypted file",
    },
    'ENTERTAINMENT_DEFAULT_SETTINGS': {
        0: "Save current settings as user default",
        1: "Load user default",
        2: "Load manufacturer default",
    },
    'ENTERTAINMENT_REGIONS': {
        0: "USA",
        1: "Europe",
        2: "Asia",
        3: "Middle East",
        4: "Latin America",
        5: "Australia",
        6: "Russia",
        7: "Japan",
    },
    'VIDEO_PROTOCOLS': {
        0: "PAL",
        1: "NTSC",
    },
    'ENTERTAINMENT_VOLUME_CONTROL': {
        0: "Up",
        1: "Down",
    },
    'BLUETOOTH_STATUS': {
        0: "Connected",
        1: "Not connected",
        2: "Not paired",
    },
    'BLUETOOTH_SOURCE_STATUS': {
        0: "Reserved",
        1: "Connected",
        2: "Connecting",
        3: "Not connected",
    },
    'SONICHUB_COMMAND': {
        1: "Init #2",
        4: "AM Radio",
        5: "Zone Info",
        6: "Source",
        8: "Source List",
        9: "Control",
        12: "FM Radio",
        13: "Playlist",
        14: "Track",
        15: "Artist",
        16: "Album",
        19: "Menu Item",
        20: "Zones",
        23: "Max Volume",
        24: "Volume",
        25: "Init #1",
        48: "Position",
        50: "Init #3",
    },
    'SIMNET_AP_MODE': {
        2: "Heading",
        3: "Wind",
        10: "Nav",
        11: "No Drift",
    },
    'SIMNET_DEVICE_MODEL': {
        0: "AC",
        1: "Other device",
        100: "NAC",
    },
    'SIMNET_DEVICE_REPORT': {
        2: "Status",
        3: "Send Status",
        10: "Mode",
        11: "Send Mode",
        23: "Sailing Processor Status",
    },
    'SIMNET_AP_STATUS': {
        2: "Manual",
        16: "Automatic",
    },
    'SIMNET_COMMAND': {
        50: "Text",
    },
    'SIMNET_EVENT_COMMAND': {
        1: "Alarm",
        2: "AP command",
        255: "Autopilot",
    },
    'SIMNET_NIGHT_MODE': {
        2: "Day",
        4: "Night",
    },
    'SIMNET_NIGHT_MODE_COLOR': {
        0: "Red",
        1: "Green",
        2: "Blue",
        3: "White",
    },
    'SIMNET_DISPLAY_GROUP': {
        1: "Default",
        2: "Group 1",
        3: "Group 2",
        4: "Group 3",
        5: "Group 4",
        6: "Group 5",
        7: "Group 6",
    },
    'SIMNET_HOUR_DISPLAY': {
        0: "24 hour",
        1: "12 hour",
    },
    'SIMNET_TIME_FORMAT': {
        1: "MM/dd/yyyy",
        2: "dd/MM/yyyy",
    },
    'SIMNET_BACKLIGHT_LEVEL': {
        0: "10% (Min)",
        1: "Day mode",
        4: "Night mode",
        11: "20%",
        22: "30%",
        33: "40%",
        44: "50%",
        55: "60%",
        66: "70%",
        77: "80%",
        88: "90%",
        99: "100% (Max)",
    },
    'SIMNET_AP_EVENTS': {
        6: "Standby",
        9: "Auto mode",
        10: "Nav mode",
        13: "Non Follow Up mode",
        14: "Follow Up mode",
        15: "Wind mode",
        18: "Square (Turn)",
        19: "C-Turn",
        20: "U-Turn",
        21: "Spiral (Turn)",
        22: "Zig Zag (Turn)",
        23: "Lazy-S (Turn)",
        24: "Depth (Turn)",
        26: "Change course",
        61: "Timer sync",
        112: "Ping port end",
        113: "Ping starboard end",
    },
    'SIMNET_DIRECTION': {
        2: "Port",
        3: "Starboard",
        4: "Left rudder (port)",
        5: "Right rudder (starboard)",
    },
    'SIMNET_ALARM': {
        57: "Low boat speed",
        58: "Wind data missing",
    },
    'FUSION_MESSAGE_ID': {
        1: "Request Status",
        2: "Source",
        4: "Track Info",
        5: "Track Title",
        6: "Track Artist",
        7: "Track Album",
        9: "Track Progress",
        11: "AM/FM Station",
        12: "VHF",
        13: "Squelch",
        14: "Scan",
        17: "Menu Item",
        20: "Replay",
        23: "Mute",
        24: "Set Zone Volume",
        25: "Set All Volumes",
        26: "Sub Volume",
        27: "Tone",
        29: "Volume",
        32: "Power",
        33: "Unit Name",
        36: "SiriusXM Channel",
        37: "SiriusXM Title",
        38: "SiriusXM Artist",
        40: "SiriusXM Genre",
        45: "Zone Name",
    },
    'SONICHUB_CONTROL': {
        0: "Set",
        128: "Ack",
    },
    'SONICHUB_SOURCE': {
        0: "AM",
        1: "FM",
        2: "iPod",
        3: "USB",
        4: "AUX",
        5: "AUX 2",
        6: "Mic",
    },
    'ISO_CONTROL': {
        0: "ACK",
        1: "NAK",
        2: "Access Denied",
        3: "Address Busy",
    },
    'ISO_COMMAND': {
        0: "ACK",
        16: "RTS",
        17: "CTS",
        19: "EOM",
        32: "BAM",
        255: "Abort",
    },
    'GROUP_FUNCTION': {
        0: "Request",
        1: "Command",
        2: "Acknowledge",
        3: "Read Fields",
        4: "Read Fields Reply",
        5: "Write Fields",
        6: "Write Fields Reply",
    },
    'AIRMAR_COMMAND': {
        32: "Attitude Offsets",
        33: "Calibrate Compass",
        34: "True Wind Options",
        35: "Simulate Mode",
        40: "Calibrate Depth",
        41: "Calibrate Speed",
        42: "Calibrate Temperature",
        43: "Speed Filter",
        44: "Temperature Filter",
        46: "NMEA 2000 options",
    },
    'AIRMAR_DEPTH_QUALITY_FACTOR': {
        0: "Depth unlocked",
        1: "Quality 10%",
        2: "Quality 20%",
        3: "Quality 30%",
        4: "Quality 40%",
        5: "Quality 50%",
        6: "Quality 60%",
        7: "Quality 70%",
        8: "Quality 80%",
        9: "Quality 90%",
        10: "Quality 100%",
    },
    'PGN_ERROR_CODE': {
        0: "Acknowledge",
        1: "PGN not supported",
        2: "PGN not available",
        3: "Access denied",
        4: "Not supported",
        5: "Tag not supported",
        6: "Read or Write not supported",
    },
    'AIRMAR_TRANSMISSION_INTERVAL': {
        0: "Measure interval",
        1: "Requested by user",
    },
    'MOB_POSITION_SOURCE': {
        0: "Position estimated by the vessel",
        1: "Position reported by MOB emitter",
    },
    'STEERING_MODE': {
        0: "Main Steering",
        1: "Non-Follow-Up Device",
        2: "Follow-Up Device",
        3: "Heading Control Standalone",
        4: "Heading Control",
        5: "Track Control",
    },
    'FUSION_RADIO_SOURCE': {
        0: "AM",
        1: "FM",
    },
    'FUSION_REPLAY_MODE': {
        9: "USB repeat",
        10: "USB shuffle",
        12: "iPod repeat",
        13: "iPod shuffle",
    },
    'FUSION_REPLAY_STATUS': {
        0: "Off",
        1: "One/track",
        2: "All/album",
    },
    'AIRMAR_POST_CONTROL': {
        0: "Report previous values",
        1: "Generate new values",
    },
    'AIRMAR_POST_ID': {
        1: "Format Code",
        2: "Factory EEPROM",
        3: "User EEPROM",
        4: "Water Temperature Sensor",
        5: "Sonar Transceiver",
        6: "Speed sensor",
        7: "Internal temperature sensor",
        8: "Battery voltage sensor",
    },
    'SONICHUB_TUNING': {
        1: "Seeking up",
        2: "Tuned",
        3: "Seeking down",
    },
    'SONICHUB_PLAYLIST': {
        1: "Report",
        4: "Next song",
        6: "Previous song",
    },
    'FUSION_POWER_STATE': {
        1: "On",
        2: "Off",
    },
    'PRIORITY': {
        0: "0",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "Leave unchanged",
        9: "Reset to default",
    },
    'DEVICE_TEMP_STATE': {
        0: "Cold",
        1: "Warm",
        2: "Hot",
    },
    'BANDG_DECIMALS': {
        0: "0",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        254: "Auto",
    },
    'GARMIN_COLOR_MODE': {
        0: "Day",
        1: "Night",
        13: "Color",
    },
    'GARMIN_COLOR': {
        0: "Day full color",
        1: "Day high contrast",
        2: "Night full color",
        3: "Night red/black",
        4: "Night green/black",
    },
    'GARMIN_BACKLIGHT_LEVEL': {
        0: "0%",
        1: "5%",
        2: "10%",
        3: "15%",
        4: "20%",
        5: "25%",
        6: "30%",
        7: "35%",
        8: "40%",
        9: "45%",
        10: "50%",
        11: "55%",
        12: "60%",
        13: "65%",
        14: "70%",
        15: "75%",
        16: "80%",
        17: "85%",
        18: "90%",
        19: "95%",
        20: "100%",
    },
    'SEATALK_PILOT_MODE_16': {
        0: "Standby",
        64: "Auto, compass commanded",
        256: "Vane, Wind Mode",
        384: "Track Mode",
        385: "No Drift, COG referenced (In track, course changes)",
    },
    'STATION_HEALTH': {
        0: "Not Working",
        1: "Unmonitored",
        2: "Healthy Operational",
        3: "Healthy Test Mode",
        4: "Test Mode",
    },
    'SERIAL_BIT_RATE': {
        0: "25",
        1: "50",
        2: "100",
        3: "200",
        4: "300",
        5: "600",
        6: "1200",
        7: "2400",
        8: "4800",
        9: "9600",
        10: "19200",
        11: "19200",
        12: "38400",
        13: "57600",
    },
    'SERIAL_DETECTION_MODE': {
        0: "Auto bit rate",
        1: "Manual bit rate",
    },
    'DIFFERENTIAL_SOURCE': {
        0: "Auto",
        1: "Loran",
        2: "MSK Beacon",
        3: "FM Subcarrier",
        4: "AIS",
        5: "Ground based radio",
        6: "SBAS",
        7: "Satellite",
    },
    'DIFFERENTIAL_MODE': {
        0: "Manual",
        1: "Auto Power",
        2: "Auto Range",
    },
}

master_flags_dict = {

    'STATION_STATUS': {
        0: "Station in use",
        1: "Low SNR",
        2: "Cycle Error",
        3: "Blink",
    },
    'ENGINE_STATUS_1': {
        0: "Check Engine",
        1: "Over Temperature",
        2: "Low Oil Pressure",
        3: "Low Oil Level",
        4: "Low Fuel Pressure",
        5: "Low System Voltage",
        6: "Low Coolant Level",
        7: "Water Flow",
        8: "Water In Fuel",
        9: "Charge Indicator",
        10: "Preheat Indicator",
        11: "High Boost Pressure",
        12: "Rev Limit Exceeded",
        13: "EGR System",
        14: "Throttle Position Sensor",
        15: "Emergency Stop",
    },
    'ENGINE_STATUS_2': {
        0: "Warning Level 1",
        1: "Warning Level 2",
        2: "Power Reduction",
        3: "Maintenance Needed",
        4: "Engine Comm Error",
        5: "Sub or Secondary Throttle",
        6: "Neutral Start Protect",
        7: "Engine Shutting Down",
    },
    'ENTERTAINMENT_PLAY_STATUS_BITFIELD': {
        0: "Play",
        1: "Pause",
        2: "Stop",
        3: "FF 1x",
        4: "FF 2x",
        5: "FF 3x",
        6: "FF 4x",
        7: "RW 1x",
        8: "RW 2x",
        9: "RW 3x",
        10: "RW 4x",
        11: "Skip ahead",
        12: "Skip back",
        13: "Jog ahead",
        14: "Jog back",
        15: "Seek up",
        16: "Seek down",
        17: "Scan up",
        18: "Scan down",
        19: "Tune up",
        20: "Tune down",
        21: "Slow motion .75x",
        22: "Slow motion .5x",
        23: "Slow motion .25x",
        24: "Slow motion .125x",
        25: "Source renaming",
    },
    'ENTERTAINMENT_GROUP_BITFIELD': {
        0: "File",
        1: "Playlist Name",
        2: "Genre Name",
        3: "Album Name",
        4: "Artist Name",
        5: "Track Name",
        6: "Station Name",
        7: "Station Number",
        8: "Favourite Number",
        9: "Play Queue",
        10: "Content Info",
    },
    'THRUSTER_CONTROL_EVENTS': {
        0: "Another device controlling thruster",
        1: "Boat speed too fast to safely use thruster",
    },
    'THRUSTER_MOTOR_EVENTS': {
        0: "Motor over temperature cutout",
        1: "Motor over current cutout",
        2: "Low oil level warning",
        3: "Oil over temperature warning",
        4: "Controller under voltage cutout",
        5: "Manufacturer defined",
    },
    'WINDLASS_CONTROL': {
        0: "Another device controlling windlass",
    },
    'WINDLASS_OPERATION': {
        0: "System error",
        1: "Sensor error",
        2: "No windlass motion detected",
        3: "Retrieval docking distance reached",
        4: "End of rode reached",
    },
    'WINDLASS_MONITORING': {
        0: "Controller under voltage cut-out",
        1: "Controller over current cut-out",
        2: "Controller over temperature cut-out",
        3: "Manufacturer defined",
    },
    'SIMNET_AP_MODE_BITFIELD': {
        3: "Standby",
        4: "Heading",
        6: "Nav",
        8: "No Drift",
        10: "Wind",
    },
    'SIMNET_ALERT_BITFIELD': {
        0: "No GPS fix",
        2: "No active autopilot control unit",
        4: "No autopilot computer",
        6: "AP clutch overload",
        8: "AP clutch disengaged",
        10: "Rudder controller fault",
        12: "No rudder response",
        14: "Rudder drive overload",
        16: "High drive supply",
        18: "Low drive supply",
        20: "Memory fail",
        22: "AP position data missing",
        24: "AP speed data missing",
        26: "AP depth data missing",
        28: "AP heading data missing",
        30: "AP nav data missing",
        32: "AP rudder data missing",
        34: "AP wind data missing",
        36: "AP off course",
        38: "High drive temperature",
        40: "Drive inhibit",
        42: "Rudder limit",
        44: "Drive computer missing",
        46: "Drive ready missing",
        48: "EVC com error",
        50: "EVC override",
        52: "Low CAN bus voltage",
        54: "CAN bus supply overload",
        56: "Wind sensor battery low",
    },
    'ENTERTAINMENT_REPEAT_BITFIELD': {
        0: "Song",
        1: "Play queue",
    },
    'ENTERTAINMENT_SHUFFLE_BITFIELD': {
        0: "Play queue",
        1: "All",
    },
}

master_indirect_lookup_dict = {

    'DEVICE_FUNCTION': {
        "10_130": "Diagnostic",
        "10_140": "Bus Traffic Logger",
        "20_110": "Alarm Enunciator",
        "20_130": "Emergency Position Indicating Radio Beacon (EPIRB)",
        "20_135": "Man Overboard",
        "20_140": "Voyage Data Recorder",
        "20_150": "Camera",
        "25_130": "PC Gateway",
        "25_131": "NMEA 2000 to Analog Gateway",
        "25_132": "Analog to NMEA 2000 Gateway",
        "25_133": "NMEA 2000 to Serial Gateway",
        "25_135": "NMEA 0183 Gateway",
        "25_136": "NMEA Network Gateway",
        "25_137": "NMEA 2000 Wireless Gateway",
        "25_140": "Router",
        "25_150": "Bridge",
        "25_160": "Repeater",
        "30_130": "Binary Event Monitor",
        "30_140": "Load Controller",
        "30_141": "AC/DC Input",
        "30_150": "Function Controller",
        "35_140": "Engine",
        "35_141": "DC Generator/Alternator",
        "35_142": "Solar Panel (Solar Array)",
        "35_143": "Wind Generator (DC)",
        "35_144": "Fuel Cell",
        "35_145": "Network Power Supply",
        "35_151": "AC Generator",
        "35_152": "AC Bus",
        "35_153": "AC Mains (Utility/Shore)",
        "35_154": "AC Output",
        "35_160": "Power Converter - Battery Charger",
        "35_161": "Power Converter - Battery Charger+Inverter",
        "35_162": "Power Converter - Inverter",
        "35_163": "Power Converter - DC",
        "35_170": "Battery",
        "35_180": "Engine Gateway",
        "40_130": "Follow-up Controller",
        "40_140": "Mode Controller",
        "40_150": "Autopilot",
        "40_155": "Rudder",
        "40_160": "Heading Sensors",
        "40_170": "Trim (Tabs)/Interceptors",
        "40_180": "Attitude (Pitch, Roll, Yaw) Control",
        "50_130": "Engineroom Monitoring",
        "50_140": "Engine",
        "50_141": "DC Generator/Alternator",
        "50_150": "Engine Controller",
        "50_151": "AC Generator",
        "50_155": "Motor",
        "50_160": "Engine Gateway",
        "50_165": "Transmission",
        "50_170": "Throttle/Shift Control",
        "50_180": "Actuator",
        "50_190": "Gauge Interface",
        "50_200": "Gauge Large",
        "50_210": "Gauge Small",
        "60_130": "Bottom Depth",
        "60_135": "Bottom Depth/Speed",
        "60_136": "Bottom Depth/Speed/Temperature",
        "60_140": "Ownship Attitude",
        "60_145": "Ownship Position (GNSS)",
        "60_150": "Ownship Position (Loran C)",
        "60_155": "Speed",
        "60_160": "Turn Rate Indicator",
        "60_170": "Integrated Navigation",
        "60_175": "Integrated Navigation System",
        "60_190": "Navigation Management",
        "60_195": "Automatic Identification System (AIS)",
        "60_200": "Radar",
        "60_201": "Infrared Imaging",
        "60_205": "ECDIS",
        "60_210": "ECS",
        "60_220": "Direction Finder",
        "60_230": "Voyage Status",
        "70_130": "EPIRB",
        "70_140": "AIS",
        "70_150": "DSC",
        "70_160": "Data Receiver/Transceiver",
        "70_170": "Satellite",
        "70_180": "Radio-telephone (MF/HF)",
        "70_190": "Radiotelephone",
        "75_130": "Temperature",
        "75_140": "Pressure",
        "75_150": "Fluid Level",
        "75_160": "Flow",
        "75_170": "Humidity",
        "80_130": "Time/Date Systems",
        "80_140": "VDR",
        "80_150": "Integrated Instrumentation",
        "80_160": "General Purpose Displays",
        "80_170": "General Sensor Box",
        "80_180": "Weather Instruments",
        "80_190": "Transducer/General",
        "80_200": "NMEA 0183 Converter",
        "85_130": "Atmospheric",
        "85_160": "Aquatic",
        "90_130": "HVAC",
        "100_130": "Scale (Catch)",
        "110_130": "Button Interface",
        "110_135": "Switch Interface",
        "110_140": "Analog Interface",
        "120_130": "Display",
        "120_140": "Alarm Enunciator",
        "125_130": "Multimedia Player",
        "125_140": "Multimedia Controller",
    },
}



lookup_dict_encode_LIGHTING_COMMAND = {
    "Idle" : 0,
    "Detect Devices" : 1,
    "Reboot" : 2,
    "Factory Reset" : 3,
    "Powering Up" : 4,
}
def lookup_encode_LIGHTING_COMMAND(value):
    result = lookup_dict_encode_LIGHTING_COMMAND.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from LIGHTING_COMMAND")
    return result

lookup_dict_encode_INDUSTRY_CODE = {
    "Global" : 0,
    "Highway" : 1,
    "Agriculture" : 2,
    "Construction" : 3,
    "Marine" : 4,
    "Industrial" : 5,
}
def lookup_encode_INDUSTRY_CODE(value):
    result = lookup_dict_encode_INDUSTRY_CODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from INDUSTRY_CODE")
    return result

lookup_dict_encode_MANUFACTURER_CODE = {
    "ARKS Enterprises, Inc." : 69,
    "FW Murphy/Enovation Controls" : 78,
    "Twin Disc" : 80,
    "Kohler Power Systems" : 85,
    "Hemisphere GPS Inc" : 88,
    "BEP Marine" : 116,
    "Airmar" : 135,
    "Maretron" : 137,
    "Lowrance" : 140,
    "Mercury Marine" : 144,
    "Nautibus Electronic GmbH" : 147,
    "Blue Water Data" : 148,
    "Westerbeke" : 154,
    "Offshore Systems (UK) Ltd." : 161,
    "Evinrude/BRP" : 163,
    "CPAC Systems AB" : 165,
    "Xantrex Technology Inc." : 168,
    "Yanmar Marine" : 172,
    "Volvo Penta" : 174,
    "Honda Marine" : 175,
    "Carling Technologies Inc. (Moritz Aerospace)" : 176,
    "Beede Instruments" : 185,
    "Floscan Instrument Co. Inc." : 192,
    "Nobletec" : 193,
    "Mystic Valley Communications" : 198,
    "Actia" : 199,
    "Honda Marine" : 200,
    "Disenos Y Technologia" : 201,
    "Digital Switching Systems" : 211,
    "Xintex/Atena" : 215,
    "EMMI NETWORK S.L." : 224,
    "Honda Marine" : 225,
    "ZF" : 228,
    "Garmin" : 229,
    "Yacht Monitoring Solutions" : 233,
    "Sailormade Marine Telemetry/Tetra Technology LTD" : 235,
    "Eride" : 243,
    "Honda Marine" : 250,
    "Honda Motor Company LTD" : 257,
    "Groco" : 272,
    "Actisense" : 273,
    "Amphenol LTW Technology" : 274,
    "Navico" : 275,
    "Hamilton Jet" : 283,
    "Sea Recovery" : 285,
    "Coelmo SRL Italy" : 286,
    "BEP Marine" : 295,
    "Empir Bus" : 304,
    "NovAtel" : 305,
    "Sleipner Motor AS" : 306,
    "MBW Technologies" : 307,
    "Fischer Panda" : 311,
    "ICOM" : 315,
    "Qwerty" : 328,
    "Dief" : 329,
    "Boening Automationstechnologie GmbH & Co. KG" : 341,
    "Korean Maritime University" : 345,
    "Thrane and Thrane" : 351,
    "Mastervolt" : 355,
    "Fischer Panda Generators" : 356,
    "Victron Energy" : 358,
    "Rolls Royce Marine" : 370,
    "Electronic Design" : 373,
    "Northern Lights" : 374,
    "Glendinning" : 378,
    "B & G" : 381,
    "Rose Point Navigation Systems" : 384,
    "Johnson Outdoors Marine Electronics Inc Geonav" : 385,
    "Capi 2" : 394,
    "Beyond Measure" : 396,
    "Livorsi Marine" : 400,
    "ComNav" : 404,
    "Chetco" : 409,
    "Fusion Electronics" : 419,
    "Standard Horizon" : 421,
    "True Heading AB" : 422,
    "Egersund Marine Electronics AS" : 426,
    "em-trak Marine Electronics" : 427,
    "Tohatsu Co, JP" : 431,
    "Digital Yacht" : 437,
    "Comar Systems Limited" : 438,
    "Cummins" : 440,
    "VDO (aka Continental-Corporation)" : 443,
    "Parker Hannifin aka Village Marine Tech" : 451,
    "Alltek Marine Electronics Corp" : 459,
    "SAN GIORGIO S.E.I.N" : 460,
    "Veethree Electronics & Marine" : 466,
    "Humminbird Marine Electronics" : 467,
    "SI-TEX Marine Electronics" : 470,
    "Sea Cross Marine AB" : 471,
    "GME aka Standard Communications Pty LTD" : 475,
    "Humminbird Marine Electronics" : 476,
    "Ocean Sat BV" : 478,
    "Chetco Digitial Instruments" : 481,
    "Watcheye" : 493,
    "Lcj Capteurs" : 499,
    "Attwood Marine" : 502,
    "Naviop S.R.L." : 503,
    "Vesper Marine Ltd" : 504,
    "Marinesoft Co. LTD" : 510,
    "NoLand Engineering" : 517,
    "Transas USA" : 518,
    "National Instruments Korea" : 529,
    "Onwa Marine" : 532,
    "Marinecraft (South Korea)" : 571,
    "McMurdo Group aka Orolia LTD" : 573,
    "Advansea" : 578,
    "KVH" : 579,
    "San Jose Technology" : 580,
    "Yacht Control" : 583,
    "Suzuki Motor Corporation" : 586,
    "US Coast Guard" : 591,
    "Ship Module aka Customware" : 595,
    "Aquatic AV" : 600,
    "Aventics GmbH" : 605,
    "Intellian" : 606,
    "SamwonIT" : 612,
    "Arlt Tecnologies" : 614,
    "Bavaria Yacts" : 637,
    "Diverse Yacht Services" : 641,
    "Wema U.S.A dba KUS" : 644,
    "Garmin" : 645,
    "Shenzhen Jiuzhou Himunication" : 658,
    "Rockford Corp" : 688,
    "JL Audio" : 704,
    "Autonnic" : 715,
    "Yacht Devices" : 717,
    "REAP Systems" : 734,
    "Au Electronics Group" : 735,
    "LxNav" : 739,
    "DaeMyung" : 743,
    "Woosung" : 744,
    "Clarion US" : 773,
    "HMI Systems" : 776,
    "Ocean Signal" : 777,
    "Seekeeper" : 778,
    "Poly Planar" : 781,
    "Fischer Panda DE" : 785,
    "Broyda Industries" : 795,
    "Canadian Automotive" : 796,
    "Tides Marine" : 797,
    "Lumishore" : 798,
    "Still Water Designs and Audio" : 799,
    "BJ Technologies (Beneteau)" : 802,
    "Gill Sensors" : 803,
    "Blue Water Desalination" : 811,
    "FLIR" : 815,
    "Undheim Systems" : 824,
    "TeamSurv" : 838,
    "Fell Marine" : 844,
    "Oceanvolt" : 847,
    "Prospec" : 862,
    "Data Panel Corp" : 868,
    "L3 Technologies" : 890,
    "Rhodan Marine Systems" : 894,
    "Nexfour Solutions" : 896,
    "ASA Electronics" : 905,
    "Marines Co (South Korea)" : 909,
    "Nautic-on" : 911,
    "Ecotronix" : 930,
    "Timbolier Industries" : 962,
    "TJC Micro" : 963,
    "Cox Powertrain" : 968,
    "Blue Seas" : 969,
    "Revatek" : 1417,
    "Teleflex Marine (SeaStar Solutions)" : 1850,
    "Raymarine" : 1851,
    "Navionics" : 1852,
    "Japan Radio Co" : 1853,
    "Northstar Technologies" : 1854,
    "Furuno" : 1855,
    "Trimble" : 1856,
    "Simrad" : 1857,
    "Litton" : 1858,
    "Kvasar AB" : 1859,
    "MMP" : 1860,
    "Vector Cantech" : 1861,
    "Yamaha Marine" : 1862,
    "Faria Instruments" : 1863,
}
def lookup_encode_MANUFACTURER_CODE(value):
    result = lookup_dict_encode_MANUFACTURER_CODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from MANUFACTURER_CODE")
    return result

lookup_dict_encode_AIS_MESSAGE_ID = {
    "Scheduled Class A position report" : 1,
    "Assigned scheduled Class A position report" : 2,
    "Interrogated Class A position report" : 3,
    "Base station report" : 4,
    "Static and voyage related data" : 5,
    "Binary addressed message" : 6,
    "Binary acknowledgement" : 7,
    "Binary broadcast message" : 8,
    "Standard SAR aircraft position report" : 9,
    "UTC/date inquiry" : 10,
    "UTC/date response" : 11,
    "Safety related addressed message" : 12,
    "Safety related acknowledgement" : 13,
    "Satety related broadcast message" : 14,
    "Interrogation" : 15,
    "Assignment mode command" : 16,
    "DGNSS broadcast binary message" : 17,
    "Standard Class B position report" : 18,
    "Extended Class B position report" : 19,
    "Data link management message" : 20,
    "ATON report" : 21,
    "Channel management" : 22,
    "Group assignment command" : 23,
    "Static data report" : 24,
    "Single slot binary message" : 25,
    "Multiple slot binary message" : 26,
    "Position report for long range applications" : 27,
}
def lookup_encode_AIS_MESSAGE_ID(value):
    result = lookup_dict_encode_AIS_MESSAGE_ID.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from AIS_MESSAGE_ID")
    return result

lookup_dict_encode_SHIP_TYPE = {
    "Unavailable" : 0,
    "Wing In Ground" : 20,
    "Wing In Ground (hazard cat X)" : 21,
    "Wing In Ground (hazard cat Y)" : 22,
    "Wing In Ground (hazard cat Z)" : 23,
    "Wing In Ground (hazard cat OS)" : 24,
    "Wing In Ground (no additional information)" : 29,
    "Fishing" : 30,
    "Towing" : 31,
    "Towing exceeds 200m or wider than 25m" : 32,
    "Engaged in dredging or underwater operations" : 33,
    "Engaged in diving operations" : 34,
    "Engaged in military operations" : 35,
    "Sailing" : 36,
    "Pleasure" : 37,
    "High speed craft" : 40,
    "High speed craft (hazard cat X)" : 41,
    "High speed craft (hazard cat Y)" : 42,
    "High speed craft (hazard cat Z)" : 43,
    "High speed craft (hazard cat OS)" : 44,
    "High speed craft (no additional information)" : 49,
    "Pilot vessel" : 50,
    "SAR" : 51,
    "Tug" : 52,
    "Port tender" : 53,
    "Anti-pollution" : 54,
    "Law enforcement" : 55,
    "Spare" : 56,
    "Spare #2" : 57,
    "Medical" : 58,
    "Ships and aircraft of States not parties to an armed conflict" : 59,
    "Passenger ship" : 60,
    "Passenger ship (hazard cat X)" : 61,
    "Passenger ship (hazard cat Y)" : 62,
    "Passenger ship (hazard cat Z)" : 63,
    "Passenger ship (hazard cat OS)" : 64,
    "Passenger ship (no additional information)" : 69,
    "Cargo ship" : 70,
    "Cargo ship (hazard cat X)" : 71,
    "Cargo ship (hazard cat Y)" : 72,
    "Cargo ship (hazard cat Z)" : 73,
    "Cargo ship (hazard cat OS)" : 74,
    "Cargo ship (no additional information)" : 79,
    "Tanker" : 80,
    "Tanker (hazard cat X)" : 81,
    "Tanker (hazard cat Y)" : 82,
    "Tanker (hazard cat Z)" : 83,
    "Tanker (hazard cat OS)" : 84,
    "Tanker (no additional information)" : 89,
    "Other" : 90,
    "Other (hazard cat X)" : 91,
    "Other (hazard cat Y)" : 92,
    "Other (hazard cat Z)" : 93,
    "Other (hazard cat OS)" : 94,
    "Other (no additional information)" : 99,
}
def lookup_encode_SHIP_TYPE(value):
    result = lookup_dict_encode_SHIP_TYPE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SHIP_TYPE")
    return result

lookup_dict_encode_DEVICE_CLASS = {
    "Reserved for 2000 Use" : 0,
    "System tools" : 10,
    "Safety systems" : 20,
    "Internetwork device" : 25,
    "Electrical Distribution" : 30,
    "Electrical Generation" : 35,
    "Steering and Control surfaces" : 40,
    "Propulsion" : 50,
    "Navigation" : 60,
    "Communication" : 70,
    "Sensor Communication Interface" : 75,
    "Instrumentation/general systems" : 80,
    "External Environment" : 85,
    "Internal Environment" : 90,
    "Deck + cargo + fishing equipment systems" : 100,
    "Human Interface" : 110,
    "Display" : 120,
    "Entertainment" : 125,
}
def lookup_encode_DEVICE_CLASS(value):
    result = lookup_dict_encode_DEVICE_CLASS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from DEVICE_CLASS")
    return result

lookup_dict_encode_REPEAT_INDICATOR = {
    "Initial" : 0,
    "First retransmission" : 1,
    "Second retransmission" : 2,
    "Final retransmission" : 3,
}
def lookup_encode_REPEAT_INDICATOR(value):
    result = lookup_dict_encode_REPEAT_INDICATOR.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from REPEAT_INDICATOR")
    return result

lookup_dict_encode_TX_RX_MODE = {
    "Tx A/Tx B, Rx A/Rx B" : 0,
    "Tx A, Rx A/Rx B" : 1,
    "Tx B, Rx A/Rx B" : 2,
}
def lookup_encode_TX_RX_MODE(value):
    result = lookup_dict_encode_TX_RX_MODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from TX_RX_MODE")
    return result

lookup_dict_encode_STATION_TYPE = {
    "All types of mobile station" : 0,
    "All types of Class B mobile station" : 2,
    "SAR airborne mobile station" : 3,
    "AtoN station" : 4,
    "Class B CS shipborne mobile station" : 5,
    "Inland waterways" : 6,
    "Regional use 7" : 7,
    "Regional use 8" : 8,
    "Regional use 9" : 9,
}
def lookup_encode_STATION_TYPE(value):
    result = lookup_dict_encode_STATION_TYPE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from STATION_TYPE")
    return result

lookup_dict_encode_REPORTING_INTERVAL = {
    "As given by the autonomous mode" : 0,
    "10 min" : 1,
    "6 min" : 2,
    "3 min" : 3,
    "1 min" : 4,
    "30 sec" : 5,
    "15 sec" : 6,
    "10 sec" : 7,
    "5 sec" : 8,
    "2 sec (not applicable to Class B CS)" : 9,
    "Next shorter reporting interval" : 10,
    "Next longer reporting interval" : 11,
}
def lookup_encode_REPORTING_INTERVAL(value):
    result = lookup_dict_encode_REPORTING_INTERVAL.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from REPORTING_INTERVAL")
    return result

lookup_dict_encode_AIS_TRANSCEIVER = {
    "Channel A VDL reception" : 0,
    "Channel B VDL reception" : 1,
    "Channel A VDL transmission" : 2,
    "Channel B VDL transmission" : 3,
    "Own information not broadcast" : 4,
    "Reserved" : 5,
}
def lookup_encode_AIS_TRANSCEIVER(value):
    result = lookup_dict_encode_AIS_TRANSCEIVER.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from AIS_TRANSCEIVER")
    return result

lookup_dict_encode_AIS_ASSIGNED_MODE = {
    "Autonomous and continuous" : 0,
    "Assigned mode" : 1,
}
def lookup_encode_AIS_ASSIGNED_MODE(value):
    result = lookup_dict_encode_AIS_ASSIGNED_MODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from AIS_ASSIGNED_MODE")
    return result

lookup_dict_encode_ATON_TYPE = {
    "Default: Type of AtoN not specified" : 0,
    "Reference point" : 1,
    "RACON" : 2,
    "Fixed structure off-shore" : 3,
    "Reserved for future use" : 4,
    "Fixed light: without sectors" : 5,
    "Fixed light: with sectors" : 6,
    "Fixed leading light front" : 7,
    "Fixed leading light rear" : 8,
    "Fixed beacon: cardinal N" : 9,
    "Fixed beacon: cardinal E" : 10,
    "Fixed beacon: cardinal S" : 11,
    "Fixed beacon: cardinal W" : 12,
    "Fixed beacon: port hand" : 13,
    "Fixed beacon: starboard hand" : 14,
    "Fixed beacon: preferred channel port hand" : 15,
    "Fixed beacon: preferred channel starboard hand" : 16,
    "Fixed beacon: isolated danger" : 17,
    "Fixed beacon: safe water" : 18,
    "Fixed beacon: special mark" : 19,
    "Floating AtoN: cardinal N" : 20,
    "Floating AtoN: cardinal E" : 21,
    "Floating AtoN: cardinal S" : 22,
    "Floating AtoN: cardinal W" : 23,
    "Floating AtoN: port hand mark" : 24,
    "Floating AtoN: starboard hand mark" : 25,
    "Floating AtoN: preferred channel port hand" : 26,
    "Floating AtoN: preferred channel starboard hand" : 27,
    "Floating AtoN: isolated danger" : 28,
    "Floating AtoN: safe water" : 29,
    "Floating AtoN: special mark" : 30,
    "Floating AtoN: light vessel/LANBY/rigs" : 31,
}
def lookup_encode_ATON_TYPE(value):
    result = lookup_dict_encode_ATON_TYPE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ATON_TYPE")
    return result

lookup_dict_encode_AIS_SPECIAL_MANEUVER = {
    "Not available" : 0,
    "Not engaged in special maneuver" : 1,
    "Engaged in special maneuver" : 2,
    "Reserved" : 3,
}
def lookup_encode_AIS_SPECIAL_MANEUVER(value):
    result = lookup_dict_encode_AIS_SPECIAL_MANEUVER.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from AIS_SPECIAL_MANEUVER")
    return result

lookup_dict_encode_POSITION_FIX_DEVICE = {
    "Default: undefined" : 0,
    "GPS" : 1,
    "GLONASS" : 2,
    "Combined GPS/GLONASS" : 3,
    "Loran-C" : 4,
    "Chayka" : 5,
    "Integrated navigation system" : 6,
    "Surveyed" : 7,
    "Galileo" : 8,
    "Internal GNSS" : 15,
}
def lookup_encode_POSITION_FIX_DEVICE(value):
    result = lookup_dict_encode_POSITION_FIX_DEVICE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from POSITION_FIX_DEVICE")
    return result

lookup_dict_encode_GNS = {
    "GPS" : 0,
    "GLONASS" : 1,
    "GPS+GLONASS" : 2,
    "GPS+SBAS/WAAS" : 3,
    "GPS+SBAS/WAAS+GLONASS" : 4,
    "Chayka" : 5,
    "integrated" : 6,
    "surveyed" : 7,
    "Galileo" : 8,
}
def lookup_encode_GNS(value):
    result = lookup_dict_encode_GNS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from GNS")
    return result

lookup_dict_encode_ENGINE_INSTANCE = {
    "Single Engine or Dual Engine Port" : 0,
    "Dual Engine Starboard" : 1,
}
def lookup_encode_ENGINE_INSTANCE(value):
    result = lookup_dict_encode_ENGINE_INSTANCE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ENGINE_INSTANCE")
    return result

lookup_dict_encode_GEAR_STATUS = {
    "Forward" : 0,
    "Neutral" : 1,
    "Reverse" : 2,
}
def lookup_encode_GEAR_STATUS(value):
    result = lookup_dict_encode_GEAR_STATUS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from GEAR_STATUS")
    return result

lookup_dict_encode_DIRECTION = {
    "Forward" : 0,
    "Reverse" : 1,
}
def lookup_encode_DIRECTION(value):
    result = lookup_dict_encode_DIRECTION.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from DIRECTION")
    return result

lookup_dict_encode_POSITION_ACCURACY = {
    "Low" : 0,
    "High" : 1,
}
def lookup_encode_POSITION_ACCURACY(value):
    result = lookup_dict_encode_POSITION_ACCURACY.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from POSITION_ACCURACY")
    return result

lookup_dict_encode_RAIM_FLAG = {
    "not in use" : 0,
    "in use" : 1,
}
def lookup_encode_RAIM_FLAG(value):
    result = lookup_dict_encode_RAIM_FLAG.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from RAIM_FLAG")
    return result

lookup_dict_encode_TIME_STAMP = {
    "Not available" : 60,
    "Manual input mode" : 61,
    "Dead reckoning mode" : 62,
    "Positioning system is inoperative" : 63,
}
def lookup_encode_TIME_STAMP(value):
    result = lookup_dict_encode_TIME_STAMP.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from TIME_STAMP")
    return result

lookup_dict_encode_GNS_METHOD = {
    "no GNSS" : 0,
    "GNSS fix" : 1,
    "DGNSS fix" : 2,
    "Precise GNSS" : 3,
    "RTK Fixed Integer" : 4,
    "RTK float" : 5,
    "Estimated (DR) mode" : 6,
    "Manual Input" : 7,
    "Simulate mode" : 8,
}
def lookup_encode_GNS_METHOD(value):
    result = lookup_dict_encode_GNS_METHOD.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from GNS_METHOD")
    return result

lookup_dict_encode_GNS_INTEGRITY = {
    "No integrity checking" : 0,
    "Safe" : 1,
    "Caution" : 2,
}
def lookup_encode_GNS_INTEGRITY(value):
    result = lookup_dict_encode_GNS_INTEGRITY.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from GNS_INTEGRITY")
    return result

lookup_dict_encode_SYSTEM_TIME = {
    "GPS" : 0,
    "GLONASS" : 1,
    "Radio Station" : 2,
    "Local Cesium clock" : 3,
    "Local Rubidium clock" : 4,
    "Local Crystal clock" : 5,
}
def lookup_encode_SYSTEM_TIME(value):
    result = lookup_dict_encode_SYSTEM_TIME.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SYSTEM_TIME")
    return result

lookup_dict_encode_MAGNETIC_VARIATION = {
    "Manual" : 0,
    "Automatic Chart" : 1,
    "Automatic Table" : 2,
    "Automatic Calculation" : 3,
    "WMM 2000" : 4,
    "WMM 2005" : 5,
    "WMM 2010" : 6,
    "WMM 2015" : 7,
    "WMM 2020" : 8,
}
def lookup_encode_MAGNETIC_VARIATION(value):
    result = lookup_dict_encode_MAGNETIC_VARIATION.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from MAGNETIC_VARIATION")
    return result

lookup_dict_encode_RESIDUAL_MODE = {
    "Autonomous" : 0,
    "Differential enhanced" : 1,
    "Estimated" : 2,
    "Simulator" : 3,
    "Manual" : 4,
}
def lookup_encode_RESIDUAL_MODE(value):
    result = lookup_dict_encode_RESIDUAL_MODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from RESIDUAL_MODE")
    return result

lookup_dict_encode_WIND_REFERENCE = {
    "True (ground referenced to North)" : 0,
    "Magnetic (ground referenced to Magnetic North)" : 1,
    "Apparent" : 2,
    "True (boat referenced)" : 3,
    "True (water referenced)" : 4,
}
def lookup_encode_WIND_REFERENCE(value):
    result = lookup_dict_encode_WIND_REFERENCE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from WIND_REFERENCE")
    return result

lookup_dict_encode_WATER_REFERENCE = {
    "Paddle wheel" : 0,
    "Pitot tube" : 1,
    "Doppler" : 2,
    "Correlation (ultra sound)" : 3,
    "Electro Magnetic" : 4,
}
def lookup_encode_WATER_REFERENCE(value):
    result = lookup_dict_encode_WATER_REFERENCE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from WATER_REFERENCE")
    return result

lookup_dict_encode_YES_NO = {
    "No" : 0,
    "Yes" : 1,
}
def lookup_encode_YES_NO(value):
    result = lookup_dict_encode_YES_NO.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from YES_NO")
    return result

lookup_dict_encode_OK_WARNING = {
    "OK" : 0,
    "Warning" : 1,
}
def lookup_encode_OK_WARNING(value):
    result = lookup_dict_encode_OK_WARNING.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from OK_WARNING")
    return result

lookup_dict_encode_OFF_ON = {
    "Off" : 0,
    "On" : 1,
}
def lookup_encode_OFF_ON(value):
    result = lookup_dict_encode_OFF_ON.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from OFF_ON")
    return result

lookup_dict_encode_DIRECTION_REFERENCE = {
    "True" : 0,
    "Magnetic" : 1,
    "Error" : 2,
}
def lookup_encode_DIRECTION_REFERENCE(value):
    result = lookup_dict_encode_DIRECTION_REFERENCE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from DIRECTION_REFERENCE")
    return result

lookup_dict_encode_DIRECTION_RUDDER = {
    "No Order" : 0,
    "Move to starboard" : 1,
    "Move to port" : 2,
}
def lookup_encode_DIRECTION_RUDDER(value):
    result = lookup_dict_encode_DIRECTION_RUDDER.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from DIRECTION_RUDDER")
    return result

lookup_dict_encode_NAV_STATUS = {
    "Under way using engine" : 0,
    "At anchor" : 1,
    "Not under command" : 2,
    "Restricted maneuverability" : 3,
    "Constrained by her draught" : 4,
    "Moored" : 5,
    "Aground" : 6,
    "Engaged in Fishing" : 7,
    "Under way sailing" : 8,
    "Hazardous material - High Speed" : 9,
    "Hazardous material - Wing in Ground" : 10,
    "Power-driven vessel towing astern" : 11,
    "Power-driven vessel pushing ahead or towing alongside" : 12,
    "AIS-SART" : 14,
}
def lookup_encode_NAV_STATUS(value):
    result = lookup_dict_encode_NAV_STATUS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from NAV_STATUS")
    return result

lookup_dict_encode_POWER_FACTOR = {
    "Leading" : 0,
    "Lagging" : 1,
    "Error" : 2,
}
def lookup_encode_POWER_FACTOR(value):
    result = lookup_dict_encode_POWER_FACTOR.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from POWER_FACTOR")
    return result

lookup_dict_encode_TEMPERATURE_SOURCE = {
    "Sea Temperature" : 0,
    "Outside Temperature" : 1,
    "Inside Temperature" : 2,
    "Engine Room Temperature" : 3,
    "Main Cabin Temperature" : 4,
    "Live Well Temperature" : 5,
    "Bait Well Temperature" : 6,
    "Refrigeration Temperature" : 7,
    "Heating System Temperature" : 8,
    "Dew Point Temperature" : 9,
    "Apparent Wind Chill Temperature" : 10,
    "Theoretical Wind Chill Temperature" : 11,
    "Heat Index Temperature" : 12,
    "Freezer Temperature" : 13,
    "Exhaust Gas Temperature" : 14,
    "Shaft Seal Temperature" : 15,
}
def lookup_encode_TEMPERATURE_SOURCE(value):
    result = lookup_dict_encode_TEMPERATURE_SOURCE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from TEMPERATURE_SOURCE")
    return result

lookup_dict_encode_HUMIDITY_SOURCE = {
    "Inside" : 0,
    "Outside" : 1,
}
def lookup_encode_HUMIDITY_SOURCE(value):
    result = lookup_dict_encode_HUMIDITY_SOURCE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from HUMIDITY_SOURCE")
    return result

lookup_dict_encode_PRESSURE_SOURCE = {
    "Atmospheric" : 0,
    "Water" : 1,
    "Steam" : 2,
    "Compressed Air" : 3,
    "Hydraulic" : 4,
    "Filter" : 5,
    "AltimeterSetting" : 6,
    "Oil" : 7,
    "Fuel" : 8,
}
def lookup_encode_PRESSURE_SOURCE(value):
    result = lookup_dict_encode_PRESSURE_SOURCE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from PRESSURE_SOURCE")
    return result

lookup_dict_encode_DSC_FORMAT = {
    "Geographical area" : 102,
    "Distress" : 112,
    "Common interest" : 114,
    "All ships" : 116,
    "Individual stations" : 120,
    "Non-calling purpose" : 121,
    "Individual station automatic" : 123,
}
def lookup_encode_DSC_FORMAT(value):
    result = lookup_dict_encode_DSC_FORMAT.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from DSC_FORMAT")
    return result

lookup_dict_encode_DSC_CATEGORY = {
    "Routine" : 100,
    "Safety" : 108,
    "Urgency" : 110,
    "Distress" : 112,
}
def lookup_encode_DSC_CATEGORY(value):
    result = lookup_dict_encode_DSC_CATEGORY.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from DSC_CATEGORY")
    return result

lookup_dict_encode_DSC_NATURE = {
    "Fire" : 100,
    "Flooding" : 101,
    "Collision" : 102,
    "Grounding" : 103,
    "Listing" : 104,
    "Sinking" : 105,
    "Disabled and adrift" : 106,
    "Undesignated" : 107,
    "Abandoning ship" : 108,
    "Piracy" : 109,
    "Man overboard" : 110,
    "EPIRB emission" : 112,
}
def lookup_encode_DSC_NATURE(value):
    result = lookup_dict_encode_DSC_NATURE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from DSC_NATURE")
    return result

lookup_dict_encode_DSC_FIRST_TELECOMMAND = {
    "F3E/G3E All modes TP" : 100,
    "F3E/G3E duplex TP" : 101,
    "Polling" : 103,
    "Unable to comply" : 104,
    "End of call" : 105,
    "Data" : 106,
    "J3E TP" : 109,
    "Distress acknowledgement" : 110,
    "Distress relay" : 112,
    "F1B/J2B TTY-FEC" : 113,
    "F1B/J2B TTY-ARQ" : 115,
    "Test" : 118,
    "Ship position or location registration updating" : 121,
    "No information" : 126,
}
def lookup_encode_DSC_FIRST_TELECOMMAND(value):
    result = lookup_dict_encode_DSC_FIRST_TELECOMMAND.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from DSC_FIRST_TELECOMMAND")
    return result

lookup_dict_encode_DSC_SECOND_TELECOMMAND = {
    "No reason given" : 100,
    "Congestion at MSC" : 101,
    "Busy" : 102,
    "Queue indication" : 103,
    "Station barred" : 104,
    "No operator available" : 105,
    "Operator temporarily unavailable" : 106,
    "Equipment disabled" : 107,
    "Unable to use proposed channel" : 108,
    "Unable to use proposed mode" : 109,
    "Ships and aircraft of States not parties to an armed conflict" : 110,
    "Medical transports" : 111,
    "Pay phone/public call office" : 112,
    "Fax/data" : 113,
    "No information" : 126,
}
def lookup_encode_DSC_SECOND_TELECOMMAND(value):
    result = lookup_dict_encode_DSC_SECOND_TELECOMMAND.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from DSC_SECOND_TELECOMMAND")
    return result

lookup_dict_encode_DSC_EXPANSION_DATA = {
    "Enhanced position" : 100,
    "Source and datum of position" : 101,
    "SOG" : 102,
    "COG" : 103,
    "Additional station identification" : 104,
    "Enhanced geographic area" : 105,
    "Number of persons on board" : 106,
}
def lookup_encode_DSC_EXPANSION_DATA(value):
    result = lookup_dict_encode_DSC_EXPANSION_DATA.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from DSC_EXPANSION_DATA")
    return result

lookup_dict_encode_SEATALK_ALARM_STATUS = {
    "Alarm condition not met" : 0,
    "Alarm condition met and not silenced" : 1,
    "Alarm condition met and silenced" : 2,
}
def lookup_encode_SEATALK_ALARM_STATUS(value):
    result = lookup_dict_encode_SEATALK_ALARM_STATUS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SEATALK_ALARM_STATUS")
    return result

lookup_dict_encode_SEATALK_ALARM_ID = {
    "No Alarm" : 0,
    "Shallow Depth" : 1,
    "Deep Depth" : 2,
    "Shallow Anchor" : 3,
    "Deep Anchor" : 4,
    "Off Course" : 5,
    "AWA High" : 6,
    "AWA Low" : 7,
    "AWS High" : 8,
    "AWS Low" : 9,
    "TWA High" : 10,
    "TWA Low" : 11,
    "TWS High" : 12,
    "TWS Low" : 13,
    "WP Arrival" : 14,
    "Boat Speed High" : 15,
    "Boat Speed Low" : 16,
    "Sea Temperature High" : 17,
    "Sea Temperature Low" : 18,
    "Pilot Watch" : 19,
    "Pilot Off Course" : 20,
    "Pilot Wind Shift" : 21,
    "Pilot Low Battery" : 22,
    "Pilot Last Minute Of Watch" : 23,
    "Pilot No NMEA Data" : 24,
    "Pilot Large XTE" : 25,
    "Pilot NMEA DataError" : 26,
    "Pilot CU Disconnected" : 27,
    "Pilot Auto Release" : 28,
    "Pilot Way Point Advance" : 29,
    "Pilot Drive Stopped" : 30,
    "Pilot Type Unspecified" : 31,
    "Pilot Calibration Required" : 32,
    "Pilot Last Heading" : 33,
    "Pilot No Pilot" : 34,
    "Pilot Route Complete" : 35,
    "Pilot Variable Text" : 36,
    "GPS Failure" : 37,
    "MOB" : 38,
    "Seatalk1 Anchor" : 39,
    "Pilot Swapped Motor Power" : 40,
    "Pilot Standby Too Fast To Fish" : 41,
    "Pilot No GPS Fix" : 42,
    "Pilot No GPS COG" : 43,
    "Pilot Start Up" : 44,
    "Pilot Too Slow" : 45,
    "Pilot No Compass" : 46,
    "Pilot Rate Gyro Fault" : 47,
    "Pilot Current Limit" : 48,
    "Pilot Way Point Advance Port" : 49,
    "Pilot Way Point Advance Stbd" : 50,
    "Pilot No Wind Data" : 51,
    "Pilot No Speed Data" : 52,
    "Pilot Seatalk Fail1" : 53,
    "Pilot Seatalk Fail2" : 54,
    "Pilot Warning Too Fast To Fish" : 55,
    "Pilot Auto Dockside Fail" : 56,
    "Pilot Turn Too Fast" : 57,
    "Pilot No Nav Data" : 58,
    "Pilot Lost Waypoint Data" : 59,
    "Pilot EEPROM Corrupt" : 60,
    "Pilot Rudder Feedback Fail" : 61,
    "Pilot Autolearn Fail1" : 62,
    "Pilot Autolearn Fail2" : 63,
    "Pilot Autolearn Fail3" : 64,
    "Pilot Autolearn Fail4" : 65,
    "Pilot Autolearn Fail5" : 66,
    "Pilot Autolearn Fail6" : 67,
    "Pilot Warning Cal Required" : 68,
    "Pilot Warning OffCourse" : 69,
    "Pilot Warning XTE" : 70,
    "Pilot Warning Wind Shift" : 71,
    "Pilot Warning Drive Short" : 72,
    "Pilot Warning Clutch Short" : 73,
    "Pilot Warning Solenoid Short" : 74,
    "Pilot Joystick Fault" : 75,
    "Pilot No Joystick Data" : 76,
    "Pilot Invalid Command" : 80,
    "AIS TX Malfunction" : 81,
    "AIS Antenna VSWR fault" : 82,
    "AIS Rx channel 1 malfunction" : 83,
    "AIS Rx channel 2 malfunction" : 84,
    "AIS No sensor position in use" : 85,
    "AIS No valid SOG information" : 86,
    "AIS No valid COG information" : 87,
    "AIS 12V alarm" : 88,
    "AIS 6V alarm" : 89,
    "AIS Noise threshold exceeded channel A" : 90,
    "AIS Noise threshold exceeded channel B" : 91,
    "AIS Transmitter PA fault" : 92,
    "AIS 3V3 alarm" : 93,
    "AIS Rx channel 70 malfunction" : 94,
    "AIS Heading lost/invalid" : 95,
    "AIS internal GPS lost" : 96,
    "AIS No sensor position" : 97,
    "AIS Lock failure" : 98,
    "AIS Internal GGA timeout" : 99,
    "AIS Protocol stack restart" : 100,
    "Pilot No IPS communications" : 101,
    "Pilot Power-On or Sleep-Switch Reset While Engaged" : 102,
    "Pilot Unexpected Reset While Engaged" : 103,
    "AIS Dangerous Target" : 104,
    "AIS Lost Target" : 105,
    "AIS Safety Related Message (used to silence)" : 106,
    "AIS Connection Lost" : 107,
    "No Fix" : 108,
}
def lookup_encode_SEATALK_ALARM_ID(value):
    result = lookup_dict_encode_SEATALK_ALARM_ID.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SEATALK_ALARM_ID")
    return result

lookup_dict_encode_SEATALK_ALARM_GROUP = {
    "Instrument" : 0,
    "Autopilot" : 1,
    "Radar" : 2,
    "Chart Plotter" : 3,
    "AIS" : 4,
}
def lookup_encode_SEATALK_ALARM_GROUP(value):
    result = lookup_dict_encode_SEATALK_ALARM_GROUP.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SEATALK_ALARM_GROUP")
    return result

lookup_dict_encode_SEATALK_PILOT_MODE = {
    "Standby" : 64,
    "Auto" : 66,
    "Wind" : 70,
    "Track" : 74,
}
def lookup_encode_SEATALK_PILOT_MODE(value):
    result = lookup_dict_encode_SEATALK_PILOT_MODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SEATALK_PILOT_MODE")
    return result

lookup_dict_encode_ENTERTAINMENT_ZONE = {
    "All zones" : 0,
    "Zone 1" : 1,
    "Zone 2" : 2,
    "Zone 3" : 3,
    "Zone 4" : 4,
}
def lookup_encode_ENTERTAINMENT_ZONE(value):
    result = lookup_dict_encode_ENTERTAINMENT_ZONE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ENTERTAINMENT_ZONE")
    return result

lookup_dict_encode_ENTERTAINMENT_SOURCE = {
    "Vessel alarm" : 0,
    "AM" : 1,
    "FM" : 2,
    "Weather" : 3,
    "DAB" : 4,
    "Aux" : 5,
    "USB" : 6,
    "CD" : 7,
    "MP3" : 8,
    "Apple iOS" : 9,
    "Android" : 10,
    "Bluetooth" : 11,
    "Sirius XM" : 12,
    "Pandora" : 13,
    "Spotify" : 14,
    "Slacker" : 15,
    "Songza" : 16,
    "Apple Radio" : 17,
    "Last FM" : 18,
    "Ethernet" : 19,
    "Video MP4" : 20,
    "Video DVD" : 21,
    "Video BluRay" : 22,
    "HDMI" : 23,
    "Video" : 24,
}
def lookup_encode_ENTERTAINMENT_SOURCE(value):
    result = lookup_dict_encode_ENTERTAINMENT_SOURCE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ENTERTAINMENT_SOURCE")
    return result

lookup_dict_encode_ENTERTAINMENT_PLAY_STATUS = {
    "Play" : 0,
    "Pause" : 1,
    "Stop" : 2,
    "FF 1x" : 3,
    "FF 2x" : 4,
    "FF 3x" : 5,
    "FF 4x" : 6,
    "RW 1x" : 7,
    "RW 2x" : 8,
    "RW 3x" : 9,
    "RW 4x" : 10,
    "Skip ahead" : 11,
    "Skip back" : 12,
    "Jog ahead" : 13,
    "Jog back" : 14,
    "Seek up" : 15,
    "Seek down" : 16,
    "Scan up" : 17,
    "Scan down" : 18,
    "Tune up" : 19,
    "Tune down" : 20,
    "Slow motion .75x" : 21,
    "Slow motion .5x" : 22,
    "Slow motion .25x" : 23,
    "Slow motion .125x" : 24,
}
def lookup_encode_ENTERTAINMENT_PLAY_STATUS(value):
    result = lookup_dict_encode_ENTERTAINMENT_PLAY_STATUS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ENTERTAINMENT_PLAY_STATUS")
    return result

lookup_dict_encode_ENTERTAINMENT_REPEAT_STATUS = {
    "Off" : 0,
    "One" : 1,
    "All" : 2,
}
def lookup_encode_ENTERTAINMENT_REPEAT_STATUS(value):
    result = lookup_dict_encode_ENTERTAINMENT_REPEAT_STATUS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ENTERTAINMENT_REPEAT_STATUS")
    return result

lookup_dict_encode_ENTERTAINMENT_SHUFFLE_STATUS = {
    "Off" : 0,
    "Play queue" : 1,
    "All" : 2,
}
def lookup_encode_ENTERTAINMENT_SHUFFLE_STATUS(value):
    result = lookup_dict_encode_ENTERTAINMENT_SHUFFLE_STATUS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ENTERTAINMENT_SHUFFLE_STATUS")
    return result

lookup_dict_encode_ENTERTAINMENT_LIKE_STATUS = {
    "None" : 0,
    "Thumbs up" : 1,
    "Thumbs down" : 2,
}
def lookup_encode_ENTERTAINMENT_LIKE_STATUS(value):
    result = lookup_dict_encode_ENTERTAINMENT_LIKE_STATUS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ENTERTAINMENT_LIKE_STATUS")
    return result

lookup_dict_encode_ENTERTAINMENT_TYPE = {
    "File" : 0,
    "Playlist Name" : 1,
    "Genre Name" : 2,
    "Album Name" : 3,
    "Artist Name" : 4,
    "Track Name" : 5,
    "Station Name" : 6,
    "Station Number" : 7,
    "Favourite Number" : 8,
    "Play Queue" : 9,
    "Content Info" : 10,
}
def lookup_encode_ENTERTAINMENT_TYPE(value):
    result = lookup_dict_encode_ENTERTAINMENT_TYPE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ENTERTAINMENT_TYPE")
    return result

lookup_dict_encode_ENTERTAINMENT_GROUP = {
    "File" : 0,
    "Playlist Name" : 1,
    "Genre Name" : 2,
    "Album Name" : 3,
    "Artist Name" : 4,
    "Track Name" : 5,
    "Station Name" : 6,
    "Station Number" : 7,
    "Favourite Number" : 8,
    "Play Queue" : 9,
    "Content Info" : 10,
}
def lookup_encode_ENTERTAINMENT_GROUP(value):
    result = lookup_dict_encode_ENTERTAINMENT_GROUP.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ENTERTAINMENT_GROUP")
    return result

lookup_dict_encode_ENTERTAINMENT_CHANNEL = {
    "All channels" : 0,
    "Stereo full range" : 1,
    "Stereo front" : 2,
    "Stereo back" : 3,
    "Stereo surround" : 4,
    "Center" : 5,
    "Subwoofer" : 6,
    "Front left" : 7,
    "Front right" : 8,
    "Back left" : 9,
    "Back right" : 10,
    "Surround left" : 11,
    "Surround right" : 12,
}
def lookup_encode_ENTERTAINMENT_CHANNEL(value):
    result = lookup_dict_encode_ENTERTAINMENT_CHANNEL.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ENTERTAINMENT_CHANNEL")
    return result

lookup_dict_encode_ENTERTAINMENT_EQ = {
    "Flat" : 0,
    "Rock" : 1,
    "Hall" : 2,
    "Jazz" : 3,
    "Pop" : 4,
    "Live" : 5,
    "Classic" : 6,
    "Vocal" : 7,
    "Arena" : 8,
    "Cinema" : 9,
    "Custom" : 10,
}
def lookup_encode_ENTERTAINMENT_EQ(value):
    result = lookup_dict_encode_ENTERTAINMENT_EQ.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ENTERTAINMENT_EQ")
    return result

lookup_dict_encode_ENTERTAINMENT_FILTER = {
    "Full range" : 0,
    "High pass" : 1,
    "Low pass" : 2,
    "Band pass" : 3,
    "Notch filter" : 4,
}
def lookup_encode_ENTERTAINMENT_FILTER(value):
    result = lookup_dict_encode_ENTERTAINMENT_FILTER.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ENTERTAINMENT_FILTER")
    return result

lookup_dict_encode_ALERT_TYPE = {
    "Emergency Alarm" : 1,
    "Alarm" : 2,
    "Warning" : 5,
    "Caution" : 8,
}
def lookup_encode_ALERT_TYPE(value):
    result = lookup_dict_encode_ALERT_TYPE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ALERT_TYPE")
    return result

lookup_dict_encode_ALERT_CATEGORY = {
    "Navigational" : 0,
    "Technical" : 1,
}
def lookup_encode_ALERT_CATEGORY(value):
    result = lookup_dict_encode_ALERT_CATEGORY.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ALERT_CATEGORY")
    return result

lookup_dict_encode_ALERT_TRIGGER_CONDITION = {
    "Manual" : 0,
    "Auto" : 1,
    "Test" : 2,
    "Disabled" : 3,
}
def lookup_encode_ALERT_TRIGGER_CONDITION(value):
    result = lookup_dict_encode_ALERT_TRIGGER_CONDITION.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ALERT_TRIGGER_CONDITION")
    return result

lookup_dict_encode_ALERT_THRESHOLD_STATUS = {
    "Normal" : 0,
    "Threshold Exceeded" : 1,
    "Extreme Threshold Exceeded" : 2,
    "Low Threshold Exceeded" : 3,
    "Acknowledged" : 4,
    "Awaiting Acknowledge" : 5,
}
def lookup_encode_ALERT_THRESHOLD_STATUS(value):
    result = lookup_dict_encode_ALERT_THRESHOLD_STATUS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ALERT_THRESHOLD_STATUS")
    return result

lookup_dict_encode_ALERT_STATE = {
    "Disabled" : 0,
    "Normal" : 1,
    "Active" : 2,
    "Silenced" : 3,
    "Acknowledged" : 4,
    "Awaiting Acknowledge" : 5,
}
def lookup_encode_ALERT_STATE(value):
    result = lookup_dict_encode_ALERT_STATE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ALERT_STATE")
    return result

lookup_dict_encode_ALERT_LANGUAGE_ID = {
    "English (US)" : 0,
    "English (UK)" : 1,
    "Arabic" : 2,
    "Chinese (simplified)" : 3,
    "Croatian" : 4,
    "Danish" : 5,
    "Dutch" : 6,
    "Finnish" : 7,
    "French" : 8,
    "German" : 9,
    "Greek" : 10,
    "Italian" : 11,
    "Japanese" : 12,
    "Korean" : 13,
    "Norwegian" : 14,
    "Polish" : 15,
    "Portuguese" : 16,
    "Russian" : 17,
    "Spanish" : 18,
    "Swedish" : 19,
}
def lookup_encode_ALERT_LANGUAGE_ID(value):
    result = lookup_dict_encode_ALERT_LANGUAGE_ID.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ALERT_LANGUAGE_ID")
    return result

lookup_dict_encode_ALERT_RESPONSE_COMMAND = {
    "Acknowledge" : 0,
    "Temporary Silence" : 1,
    "Test Command off" : 2,
    "Test Command on" : 3,
}
def lookup_encode_ALERT_RESPONSE_COMMAND(value):
    result = lookup_dict_encode_ALERT_RESPONSE_COMMAND.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ALERT_RESPONSE_COMMAND")
    return result

lookup_dict_encode_CONVERTER_STATE = {
    "Off" : 0,
    "Low Power Mode" : 1,
    "Fault" : 2,
    "Bulk" : 3,
    "Absorption" : 4,
    "Float" : 5,
    "Storage" : 6,
    "Equalize" : 7,
    "Pass thru" : 8,
    "Inverting" : 9,
    "Assisting" : 10,
}
def lookup_encode_CONVERTER_STATE(value):
    result = lookup_dict_encode_CONVERTER_STATE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from CONVERTER_STATE")
    return result

lookup_dict_encode_THRUSTER_DIRECTION_CONTROL = {
    "Off" : 0,
    "Ready" : 1,
    "To Port" : 2,
    "To Starboard" : 3,
}
def lookup_encode_THRUSTER_DIRECTION_CONTROL(value):
    result = lookup_dict_encode_THRUSTER_DIRECTION_CONTROL.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from THRUSTER_DIRECTION_CONTROL")
    return result

lookup_dict_encode_THRUSTER_RETRACT_CONTROL = {
    "Off" : 0,
    "Extend" : 1,
    "Retract" : 2,
}
def lookup_encode_THRUSTER_RETRACT_CONTROL(value):
    result = lookup_dict_encode_THRUSTER_RETRACT_CONTROL.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from THRUSTER_RETRACT_CONTROL")
    return result

lookup_dict_encode_THRUSTER_MOTOR_TYPE = {
    "12VDC" : 0,
    "24VDC" : 1,
    "48VDC" : 2,
    "24VAC" : 3,
    "Hydraulic" : 4,
}
def lookup_encode_THRUSTER_MOTOR_TYPE(value):
    result = lookup_dict_encode_THRUSTER_MOTOR_TYPE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from THRUSTER_MOTOR_TYPE")
    return result

lookup_dict_encode_BOOT_STATE = {
    "in Startup Monitor" : 0,
    "running Bootloader" : 1,
    "running Application" : 2,
}
def lookup_encode_BOOT_STATE(value):
    result = lookup_dict_encode_BOOT_STATE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from BOOT_STATE")
    return result

lookup_dict_encode_ACCESS_LEVEL = {
    "Locked" : 0,
    "unlocked level 1" : 1,
    "unlocked level 2" : 2,
}
def lookup_encode_ACCESS_LEVEL(value):
    result = lookup_dict_encode_ACCESS_LEVEL.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ACCESS_LEVEL")
    return result

lookup_dict_encode_TRANSMISSION_INTERVAL = {
    "Acknowledge" : 0,
    "Transmit Interval/Priority not supported" : 1,
    "Transmit Interval too low" : 2,
    "Access denied" : 3,
    "Not supported" : 4,
}
def lookup_encode_TRANSMISSION_INTERVAL(value):
    result = lookup_dict_encode_TRANSMISSION_INTERVAL.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from TRANSMISSION_INTERVAL")
    return result

lookup_dict_encode_PARAMETER_FIELD = {
    "Acknowledge" : 0,
    "Invalid parameter field" : 1,
    "Temporary error" : 2,
    "Parameter out of range" : 3,
    "Access denied" : 4,
    "Not supported" : 5,
    "Read or Write not supported" : 6,
}
def lookup_encode_PARAMETER_FIELD(value):
    result = lookup_dict_encode_PARAMETER_FIELD.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from PARAMETER_FIELD")
    return result

lookup_dict_encode_PGN_LIST_FUNCTION = {
    "Transmit PGN list" : 0,
    "Receive PGN list" : 1,
}
def lookup_encode_PGN_LIST_FUNCTION(value):
    result = lookup_dict_encode_PGN_LIST_FUNCTION.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from PGN_LIST_FUNCTION")
    return result

lookup_dict_encode_FUSION_COMMAND = {
    "Play" : 1,
    "Pause" : 2,
    "Next" : 4,
    "Prev" : 6,
}
def lookup_encode_FUSION_COMMAND(value):
    result = lookup_dict_encode_FUSION_COMMAND.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from FUSION_COMMAND")
    return result

lookup_dict_encode_FUSION_SIRIUS_COMMAND = {
    "Next" : 1,
    "Prev" : 2,
}
def lookup_encode_FUSION_SIRIUS_COMMAND(value):
    result = lookup_dict_encode_FUSION_SIRIUS_COMMAND.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from FUSION_SIRIUS_COMMAND")
    return result

lookup_dict_encode_FUSION_MUTE_COMMAND = {
    "Mute On" : 1,
    "Mute Off" : 2,
}
def lookup_encode_FUSION_MUTE_COMMAND(value):
    result = lookup_dict_encode_FUSION_MUTE_COMMAND.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from FUSION_MUTE_COMMAND")
    return result

lookup_dict_encode_SEATALK_KEYSTROKE = {
    "Auto" : 1,
    "Standby" : 2,
    "Wind" : 3,
    "-1" : 5,
    "-10" : 6,
    "+1" : 7,
    "+10" : 8,
    "-1 and -10" : 33,
    "+1 and +10" : 34,
    "Track" : 35,
}
def lookup_encode_SEATALK_KEYSTROKE(value):
    result = lookup_dict_encode_SEATALK_KEYSTROKE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SEATALK_KEYSTROKE")
    return result

lookup_dict_encode_SEATALK_DEVICE_ID = {
    "S100" : 3,
    "Course Computer" : 5,
}
def lookup_encode_SEATALK_DEVICE_ID(value):
    result = lookup_dict_encode_SEATALK_DEVICE_ID.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SEATALK_DEVICE_ID")
    return result

lookup_dict_encode_SEATALK_NETWORK_GROUP = {
    "None" : 0,
    "Helm 1" : 1,
    "Helm 2" : 2,
    "Cockpit" : 3,
    "Flybridge" : 4,
    "Mast" : 5,
    "Group 1" : 6,
    "Group 2" : 7,
    "Group 3" : 8,
    "Group 4" : 9,
    "Group 5" : 10,
}
def lookup_encode_SEATALK_NETWORK_GROUP(value):
    result = lookup_dict_encode_SEATALK_NETWORK_GROUP.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SEATALK_NETWORK_GROUP")
    return result

lookup_dict_encode_SEATALK_DISPLAY_COLOR = {
    "Day 1" : 0,
    "Day 2" : 2,
    "Red/Black" : 3,
    "Inverse" : 4,
}
def lookup_encode_SEATALK_DISPLAY_COLOR(value):
    result = lookup_dict_encode_SEATALK_DISPLAY_COLOR.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SEATALK_DISPLAY_COLOR")
    return result

lookup_dict_encode_AIRMAR_CALIBRATE_FUNCTION = {
    "Normal/cancel calibration" : 0,
    "Enter calibration mode" : 1,
    "Reset calibration to 0" : 2,
    "Verify" : 3,
    "Reset compass to defaults" : 4,
    "Reset damping to defaults" : 5,
}
def lookup_encode_AIRMAR_CALIBRATE_FUNCTION(value):
    result = lookup_dict_encode_AIRMAR_CALIBRATE_FUNCTION.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from AIRMAR_CALIBRATE_FUNCTION")
    return result

lookup_dict_encode_AIRMAR_CALIBRATE_STATUS = {
    "Queried" : 0,
    "Passed" : 1,
    "Failed - timeout" : 2,
    "Failed - tilt error" : 3,
    "Failed - other" : 4,
    "In progress" : 5,
}
def lookup_encode_AIRMAR_CALIBRATE_STATUS(value):
    result = lookup_dict_encode_AIRMAR_CALIBRATE_STATUS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from AIRMAR_CALIBRATE_STATUS")
    return result

lookup_dict_encode_AIRMAR_TEMPERATURE_INSTANCE = {
    "Device Sensor" : 0,
    "Onboard Water Sensor" : 1,
    "Optional Water Sensor" : 2,
}
def lookup_encode_AIRMAR_TEMPERATURE_INSTANCE(value):
    result = lookup_dict_encode_AIRMAR_TEMPERATURE_INSTANCE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from AIRMAR_TEMPERATURE_INSTANCE")
    return result

lookup_dict_encode_AIRMAR_FILTER = {
    "No filter" : 0,
    "Basic IIR filter" : 1,
}
def lookup_encode_AIRMAR_FILTER(value):
    result = lookup_dict_encode_AIRMAR_FILTER.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from AIRMAR_FILTER")
    return result

lookup_dict_encode_CONTROLLER_STATE = {
    "Error Active" : 0,
    "Error Passive" : 1,
    "Bus Off" : 2,
}
def lookup_encode_CONTROLLER_STATE(value):
    result = lookup_dict_encode_CONTROLLER_STATE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from CONTROLLER_STATE")
    return result

lookup_dict_encode_EQUIPMENT_STATUS = {
    "Operational" : 0,
    "Fault" : 1,
}
def lookup_encode_EQUIPMENT_STATUS(value):
    result = lookup_dict_encode_EQUIPMENT_STATUS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from EQUIPMENT_STATUS")
    return result

lookup_dict_encode_MOB_STATUS = {
    "MOB Emitter Activated" : 0,
    "Manual on-board MOB Button Activation" : 1,
    "Test mode" : 2,
}
def lookup_encode_MOB_STATUS(value):
    result = lookup_dict_encode_MOB_STATUS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from MOB_STATUS")
    return result

lookup_dict_encode_LOW_BATTERY = {
    "Good" : 0,
    "Low" : 1,
}
def lookup_encode_LOW_BATTERY(value):
    result = lookup_dict_encode_LOW_BATTERY.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from LOW_BATTERY")
    return result

lookup_dict_encode_TURN_MODE = {
    "Rudder limit controlled" : 0,
    "Turn rate controlled" : 1,
    "Radius controlled" : 2,
}
def lookup_encode_TURN_MODE(value):
    result = lookup_dict_encode_TURN_MODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from TURN_MODE")
    return result

lookup_dict_encode_ACCEPTABILITY = {
    "Bad level" : 0,
    "Bad frequency" : 1,
    "Being qualified" : 2,
    "Good" : 3,
}
def lookup_encode_ACCEPTABILITY(value):
    result = lookup_dict_encode_ACCEPTABILITY.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ACCEPTABILITY")
    return result

lookup_dict_encode_LINE = {
    "Line 1" : 0,
    "Line 2" : 1,
    "Line 3" : 2,
}
def lookup_encode_LINE(value):
    result = lookup_dict_encode_LINE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from LINE")
    return result

lookup_dict_encode_WAVEFORM = {
    "Sine wave" : 0,
    "Modified sine wave" : 1,
}
def lookup_encode_WAVEFORM(value):
    result = lookup_dict_encode_WAVEFORM.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from WAVEFORM")
    return result

lookup_dict_encode_TANK_TYPE = {
    "Fuel" : 0,
    "Water" : 1,
    "Gray water" : 2,
    "Live well" : 3,
    "Oil" : 4,
    "Black water" : 5,
}
def lookup_encode_TANK_TYPE(value):
    result = lookup_dict_encode_TANK_TYPE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from TANK_TYPE")
    return result

lookup_dict_encode_DC_SOURCE = {
    "Battery" : 0,
    "Alternator" : 1,
    "Convertor" : 2,
    "Solar cell" : 3,
    "Wind generator" : 4,
}
def lookup_encode_DC_SOURCE(value):
    result = lookup_dict_encode_DC_SOURCE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from DC_SOURCE")
    return result

lookup_dict_encode_CHARGER_STATE = {
    "Not charging" : 0,
    "Bulk" : 1,
    "Absorption" : 2,
    "Overcharge" : 3,
    "Equalise" : 4,
    "Float" : 5,
    "No float" : 6,
    "Constant VI" : 7,
    "Disabled" : 8,
    "Fault" : 9,
}
def lookup_encode_CHARGER_STATE(value):
    result = lookup_dict_encode_CHARGER_STATE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from CHARGER_STATE")
    return result

lookup_dict_encode_CHARGING_ALGORITHM = {
    "Trickle" : 0,
    "Constant voltage / Constant current" : 1,
    "2 stage (no float)" : 2,
    "3 stage" : 3,
}
def lookup_encode_CHARGING_ALGORITHM(value):
    result = lookup_dict_encode_CHARGING_ALGORITHM.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from CHARGING_ALGORITHM")
    return result

lookup_dict_encode_CHARGER_MODE = {
    "Standalone" : 0,
    "Primary" : 1,
    "Secondary" : 2,
    "Echo" : 3,
}
def lookup_encode_CHARGER_MODE(value):
    result = lookup_dict_encode_CHARGER_MODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from CHARGER_MODE")
    return result

lookup_dict_encode_INVERTER_STATE = {
    "Invert" : 0,
    "AC passthru" : 1,
    "Load sense" : 2,
    "Fault" : 3,
    "Disabled" : 4,
}
def lookup_encode_INVERTER_STATE(value):
    result = lookup_dict_encode_INVERTER_STATE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from INVERTER_STATE")
    return result

lookup_dict_encode_BATTERY_TYPE = {
    "Flooded" : 0,
    "Gel" : 1,
    "AGM" : 2,
}
def lookup_encode_BATTERY_TYPE(value):
    result = lookup_dict_encode_BATTERY_TYPE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from BATTERY_TYPE")
    return result

lookup_dict_encode_BATTERY_VOLTAGE = {
    "6V" : 0,
    "12V" : 1,
    "24V" : 2,
    "32V" : 3,
    "36V" : 4,
    "42V" : 5,
    "48V" : 6,
}
def lookup_encode_BATTERY_VOLTAGE(value):
    result = lookup_dict_encode_BATTERY_VOLTAGE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from BATTERY_VOLTAGE")
    return result

lookup_dict_encode_BATTERY_CHEMISTRY = {
    "Pb (Lead)" : 0,
    "Li" : 1,
    "NiCd" : 2,
    "ZnO" : 3,
    "NiMH" : 4,
}
def lookup_encode_BATTERY_CHEMISTRY(value):
    result = lookup_dict_encode_BATTERY_CHEMISTRY.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from BATTERY_CHEMISTRY")
    return result

lookup_dict_encode_GOOD_WARNING_ERROR = {
    "Good" : 0,
    "Warning" : 1,
    "Error" : 2,
}
def lookup_encode_GOOD_WARNING_ERROR(value):
    result = lookup_dict_encode_GOOD_WARNING_ERROR.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from GOOD_WARNING_ERROR")
    return result

lookup_dict_encode_TRACKING = {
    "Cancelled" : 0,
    "Acquiring" : 1,
    "Tracking" : 2,
    "Lost" : 3,
}
def lookup_encode_TRACKING(value):
    result = lookup_dict_encode_TRACKING.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from TRACKING")
    return result

lookup_dict_encode_TARGET_ACQUISITION = {
    "Manual" : 0,
    "Automatic" : 1,
}
def lookup_encode_TARGET_ACQUISITION(value):
    result = lookup_dict_encode_TARGET_ACQUISITION.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from TARGET_ACQUISITION")
    return result

lookup_dict_encode_WINDLASS_DIRECTION = {
    "Off" : 0,
    "Down" : 1,
    "Up" : 2,
}
def lookup_encode_WINDLASS_DIRECTION(value):
    result = lookup_dict_encode_WINDLASS_DIRECTION.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from WINDLASS_DIRECTION")
    return result

lookup_dict_encode_SPEED_TYPE = {
    "Single speed" : 0,
    "Dual speed" : 1,
    "Proportional speed" : 2,
}
def lookup_encode_SPEED_TYPE(value):
    result = lookup_dict_encode_SPEED_TYPE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SPEED_TYPE")
    return result

lookup_dict_encode_WINDLASS_MOTION = {
    "Windlass stopped" : 0,
    "Deployment occurring" : 1,
    "Retrieval occurring" : 2,
}
def lookup_encode_WINDLASS_MOTION(value):
    result = lookup_dict_encode_WINDLASS_MOTION.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from WINDLASS_MOTION")
    return result

lookup_dict_encode_RODE_TYPE = {
    "Chain presently detected" : 0,
    "Rope presently detected" : 1,
}
def lookup_encode_RODE_TYPE(value):
    result = lookup_dict_encode_RODE_TYPE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from RODE_TYPE")
    return result

lookup_dict_encode_DOCKING_STATUS = {
    "Not docked" : 0,
    "Fully docked" : 1,
}
def lookup_encode_DOCKING_STATUS(value):
    result = lookup_dict_encode_DOCKING_STATUS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from DOCKING_STATUS")
    return result

lookup_dict_encode_AIS_TYPE = {
    "SOTDMA" : 0,
    "CS" : 1,
}
def lookup_encode_AIS_TYPE(value):
    result = lookup_dict_encode_AIS_TYPE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from AIS_TYPE")
    return result

lookup_dict_encode_AIS_BAND = {
    "Top 525 kHz of marine band" : 0,
    "Entire marine band" : 1,
}
def lookup_encode_AIS_BAND(value):
    result = lookup_dict_encode_AIS_BAND.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from AIS_BAND")
    return result

lookup_dict_encode_AIS_MODE = {
    "Autonomous" : 0,
    "Assigned" : 1,
}
def lookup_encode_AIS_MODE(value):
    result = lookup_dict_encode_AIS_MODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from AIS_MODE")
    return result

lookup_dict_encode_AIS_COMMUNICATION_STATE = {
    "SOTDMA" : 0,
    "ITDMA" : 1,
}
def lookup_encode_AIS_COMMUNICATION_STATE(value):
    result = lookup_dict_encode_AIS_COMMUNICATION_STATE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from AIS_COMMUNICATION_STATE")
    return result

lookup_dict_encode_AVAILABLE = {
    "Available" : 0,
    "Not available" : 1,
}
def lookup_encode_AVAILABLE(value):
    result = lookup_dict_encode_AVAILABLE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from AVAILABLE")
    return result

lookup_dict_encode_BEARING_MODE = {
    "Great Circle" : 0,
    "Rhumbline" : 1,
}
def lookup_encode_BEARING_MODE(value):
    result = lookup_dict_encode_BEARING_MODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from BEARING_MODE")
    return result

lookup_dict_encode_MARK_TYPE = {
    "Collision" : 0,
    "Turning point" : 1,
    "Reference" : 2,
    "Wheelover" : 3,
    "Waypoint" : 4,
}
def lookup_encode_MARK_TYPE(value):
    result = lookup_dict_encode_MARK_TYPE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from MARK_TYPE")
    return result

lookup_dict_encode_GNSS_MODE = {
    "1D" : 0,
    "2D" : 1,
    "3D" : 2,
    "Auto" : 3,
}
def lookup_encode_GNSS_MODE(value):
    result = lookup_dict_encode_GNSS_MODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from GNSS_MODE")
    return result

lookup_dict_encode_RANGE_RESIDUAL_MODE = {
    "Range residuals were used to calculate data" : 0,
    "Range residuals were calculated after the position" : 1,
}
def lookup_encode_RANGE_RESIDUAL_MODE(value):
    result = lookup_dict_encode_RANGE_RESIDUAL_MODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from RANGE_RESIDUAL_MODE")
    return result

lookup_dict_encode_DGNSS_MODE = {
    "None" : 0,
    "SBAS if available" : 1,
    "SBAS" : 3,
}
def lookup_encode_DGNSS_MODE(value):
    result = lookup_dict_encode_DGNSS_MODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from DGNSS_MODE")
    return result

lookup_dict_encode_SATELLITE_STATUS = {
    "Not tracked" : 0,
    "Tracked" : 1,
    "Used" : 2,
    "Not tracked+Diff" : 3,
    "Tracked+Diff" : 4,
    "Used+Diff" : 5,
}
def lookup_encode_SATELLITE_STATUS(value):
    result = lookup_dict_encode_SATELLITE_STATUS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SATELLITE_STATUS")
    return result

lookup_dict_encode_AIS_VERSION = {
    "ITU-R M.1371-1" : 0,
    "ITU-R M.1371-3" : 1,
    "ITU-R M.1371-5" : 2,
    "ITU-R M.1371 future edition" : 3,
}
def lookup_encode_AIS_VERSION(value):
    result = lookup_dict_encode_AIS_VERSION.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from AIS_VERSION")
    return result

lookup_dict_encode_TIDE = {
    "Falling" : 0,
    "Rising" : 1,
}
def lookup_encode_TIDE(value):
    result = lookup_dict_encode_TIDE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from TIDE")
    return result

lookup_dict_encode_WATERMAKER_STATE = {
    "Stopped" : 0,
    "Starting" : 1,
    "Running" : 2,
    "Stopping" : 3,
    "Flushing" : 4,
    "Rinsing" : 5,
    "Initiating" : 6,
    "Manual" : 7,
}
def lookup_encode_WATERMAKER_STATE(value):
    result = lookup_dict_encode_WATERMAKER_STATE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from WATERMAKER_STATE")
    return result

lookup_dict_encode_ENTERTAINMENT_ID_TYPE = {
    "Group" : 0,
    "File" : 1,
    "Encrypted group" : 2,
    "Encrypted file" : 3,
}
def lookup_encode_ENTERTAINMENT_ID_TYPE(value):
    result = lookup_dict_encode_ENTERTAINMENT_ID_TYPE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ENTERTAINMENT_ID_TYPE")
    return result

lookup_dict_encode_ENTERTAINMENT_DEFAULT_SETTINGS = {
    "Save current settings as user default" : 0,
    "Load user default" : 1,
    "Load manufacturer default" : 2,
}
def lookup_encode_ENTERTAINMENT_DEFAULT_SETTINGS(value):
    result = lookup_dict_encode_ENTERTAINMENT_DEFAULT_SETTINGS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ENTERTAINMENT_DEFAULT_SETTINGS")
    return result

lookup_dict_encode_ENTERTAINMENT_REGIONS = {
    "USA" : 0,
    "Europe" : 1,
    "Asia" : 2,
    "Middle East" : 3,
    "Latin America" : 4,
    "Australia" : 5,
    "Russia" : 6,
    "Japan" : 7,
}
def lookup_encode_ENTERTAINMENT_REGIONS(value):
    result = lookup_dict_encode_ENTERTAINMENT_REGIONS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ENTERTAINMENT_REGIONS")
    return result

lookup_dict_encode_VIDEO_PROTOCOLS = {
    "PAL" : 0,
    "NTSC" : 1,
}
def lookup_encode_VIDEO_PROTOCOLS(value):
    result = lookup_dict_encode_VIDEO_PROTOCOLS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from VIDEO_PROTOCOLS")
    return result

lookup_dict_encode_ENTERTAINMENT_VOLUME_CONTROL = {
    "Up" : 0,
    "Down" : 1,
}
def lookup_encode_ENTERTAINMENT_VOLUME_CONTROL(value):
    result = lookup_dict_encode_ENTERTAINMENT_VOLUME_CONTROL.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ENTERTAINMENT_VOLUME_CONTROL")
    return result

lookup_dict_encode_BLUETOOTH_STATUS = {
    "Connected" : 0,
    "Not connected" : 1,
    "Not paired" : 2,
}
def lookup_encode_BLUETOOTH_STATUS(value):
    result = lookup_dict_encode_BLUETOOTH_STATUS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from BLUETOOTH_STATUS")
    return result

lookup_dict_encode_BLUETOOTH_SOURCE_STATUS = {
    "Reserved" : 0,
    "Connected" : 1,
    "Connecting" : 2,
    "Not connected" : 3,
}
def lookup_encode_BLUETOOTH_SOURCE_STATUS(value):
    result = lookup_dict_encode_BLUETOOTH_SOURCE_STATUS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from BLUETOOTH_SOURCE_STATUS")
    return result

lookup_dict_encode_SONICHUB_COMMAND = {
    "Init #2" : 1,
    "AM Radio" : 4,
    "Zone Info" : 5,
    "Source" : 6,
    "Source List" : 8,
    "Control" : 9,
    "FM Radio" : 12,
    "Playlist" : 13,
    "Track" : 14,
    "Artist" : 15,
    "Album" : 16,
    "Menu Item" : 19,
    "Zones" : 20,
    "Max Volume" : 23,
    "Volume" : 24,
    "Init #1" : 25,
    "Position" : 48,
    "Init #3" : 50,
}
def lookup_encode_SONICHUB_COMMAND(value):
    result = lookup_dict_encode_SONICHUB_COMMAND.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SONICHUB_COMMAND")
    return result

lookup_dict_encode_SIMNET_AP_MODE = {
    "Heading" : 2,
    "Wind" : 3,
    "Nav" : 10,
    "No Drift" : 11,
}
def lookup_encode_SIMNET_AP_MODE(value):
    result = lookup_dict_encode_SIMNET_AP_MODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SIMNET_AP_MODE")
    return result

lookup_dict_encode_SIMNET_DEVICE_MODEL = {
    "AC" : 0,
    "Other device" : 1,
    "NAC" : 100,
}
def lookup_encode_SIMNET_DEVICE_MODEL(value):
    result = lookup_dict_encode_SIMNET_DEVICE_MODEL.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SIMNET_DEVICE_MODEL")
    return result

lookup_dict_encode_SIMNET_DEVICE_REPORT = {
    "Status" : 2,
    "Send Status" : 3,
    "Mode" : 10,
    "Send Mode" : 11,
    "Sailing Processor Status" : 23,
}
def lookup_encode_SIMNET_DEVICE_REPORT(value):
    result = lookup_dict_encode_SIMNET_DEVICE_REPORT.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SIMNET_DEVICE_REPORT")
    return result

lookup_dict_encode_SIMNET_AP_STATUS = {
    "Manual" : 2,
    "Automatic" : 16,
}
def lookup_encode_SIMNET_AP_STATUS(value):
    result = lookup_dict_encode_SIMNET_AP_STATUS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SIMNET_AP_STATUS")
    return result

lookup_dict_encode_SIMNET_COMMAND = {
    "Text" : 50,
}
def lookup_encode_SIMNET_COMMAND(value):
    result = lookup_dict_encode_SIMNET_COMMAND.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SIMNET_COMMAND")
    return result

lookup_dict_encode_SIMNET_EVENT_COMMAND = {
    "Alarm" : 1,
    "AP command" : 2,
    "Autopilot" : 255,
}
def lookup_encode_SIMNET_EVENT_COMMAND(value):
    result = lookup_dict_encode_SIMNET_EVENT_COMMAND.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SIMNET_EVENT_COMMAND")
    return result

lookup_dict_encode_SIMNET_NIGHT_MODE = {
    "Day" : 2,
    "Night" : 4,
}
def lookup_encode_SIMNET_NIGHT_MODE(value):
    result = lookup_dict_encode_SIMNET_NIGHT_MODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SIMNET_NIGHT_MODE")
    return result

lookup_dict_encode_SIMNET_NIGHT_MODE_COLOR = {
    "Red" : 0,
    "Green" : 1,
    "Blue" : 2,
    "White" : 3,
}
def lookup_encode_SIMNET_NIGHT_MODE_COLOR(value):
    result = lookup_dict_encode_SIMNET_NIGHT_MODE_COLOR.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SIMNET_NIGHT_MODE_COLOR")
    return result

lookup_dict_encode_SIMNET_DISPLAY_GROUP = {
    "Default" : 1,
    "Group 1" : 2,
    "Group 2" : 3,
    "Group 3" : 4,
    "Group 4" : 5,
    "Group 5" : 6,
    "Group 6" : 7,
}
def lookup_encode_SIMNET_DISPLAY_GROUP(value):
    result = lookup_dict_encode_SIMNET_DISPLAY_GROUP.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SIMNET_DISPLAY_GROUP")
    return result

lookup_dict_encode_SIMNET_HOUR_DISPLAY = {
    "24 hour" : 0,
    "12 hour" : 1,
}
def lookup_encode_SIMNET_HOUR_DISPLAY(value):
    result = lookup_dict_encode_SIMNET_HOUR_DISPLAY.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SIMNET_HOUR_DISPLAY")
    return result

lookup_dict_encode_SIMNET_TIME_FORMAT = {
    "MM/dd/yyyy" : 1,
    "dd/MM/yyyy" : 2,
}
def lookup_encode_SIMNET_TIME_FORMAT(value):
    result = lookup_dict_encode_SIMNET_TIME_FORMAT.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SIMNET_TIME_FORMAT")
    return result

lookup_dict_encode_SIMNET_BACKLIGHT_LEVEL = {
    "10% (Min)" : 0,
    "Day mode" : 1,
    "Night mode" : 4,
    "20%" : 11,
    "30%" : 22,
    "40%" : 33,
    "50%" : 44,
    "60%" : 55,
    "70%" : 66,
    "80%" : 77,
    "90%" : 88,
    "100% (Max)" : 99,
}
def lookup_encode_SIMNET_BACKLIGHT_LEVEL(value):
    result = lookup_dict_encode_SIMNET_BACKLIGHT_LEVEL.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SIMNET_BACKLIGHT_LEVEL")
    return result

lookup_dict_encode_SIMNET_AP_EVENTS = {
    "Standby" : 6,
    "Auto mode" : 9,
    "Nav mode" : 10,
    "Non Follow Up mode" : 13,
    "Follow Up mode" : 14,
    "Wind mode" : 15,
    "Square (Turn)" : 18,
    "C-Turn" : 19,
    "U-Turn" : 20,
    "Spiral (Turn)" : 21,
    "Zig Zag (Turn)" : 22,
    "Lazy-S (Turn)" : 23,
    "Depth (Turn)" : 24,
    "Change course" : 26,
    "Timer sync" : 61,
    "Ping port end" : 112,
    "Ping starboard end" : 113,
}
def lookup_encode_SIMNET_AP_EVENTS(value):
    result = lookup_dict_encode_SIMNET_AP_EVENTS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SIMNET_AP_EVENTS")
    return result

lookup_dict_encode_SIMNET_DIRECTION = {
    "Port" : 2,
    "Starboard" : 3,
    "Left rudder (port)" : 4,
    "Right rudder (starboard)" : 5,
}
def lookup_encode_SIMNET_DIRECTION(value):
    result = lookup_dict_encode_SIMNET_DIRECTION.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SIMNET_DIRECTION")
    return result

lookup_dict_encode_SIMNET_ALARM = {
    "Low boat speed" : 57,
    "Wind data missing" : 58,
}
def lookup_encode_SIMNET_ALARM(value):
    result = lookup_dict_encode_SIMNET_ALARM.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SIMNET_ALARM")
    return result

lookup_dict_encode_FUSION_MESSAGE_ID = {
    "Request Status" : 1,
    "Source" : 2,
    "Track Info" : 4,
    "Track Title" : 5,
    "Track Artist" : 6,
    "Track Album" : 7,
    "Track Progress" : 9,
    "AM/FM Station" : 11,
    "VHF" : 12,
    "Squelch" : 13,
    "Scan" : 14,
    "Menu Item" : 17,
    "Replay" : 20,
    "Mute" : 23,
    "Set Zone Volume" : 24,
    "Set All Volumes" : 25,
    "Sub Volume" : 26,
    "Tone" : 27,
    "Volume" : 29,
    "Power" : 32,
    "Unit Name" : 33,
    "SiriusXM Channel" : 36,
    "SiriusXM Title" : 37,
    "SiriusXM Artist" : 38,
    "SiriusXM Genre" : 40,
    "Zone Name" : 45,
}
def lookup_encode_FUSION_MESSAGE_ID(value):
    result = lookup_dict_encode_FUSION_MESSAGE_ID.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from FUSION_MESSAGE_ID")
    return result

lookup_dict_encode_SONICHUB_CONTROL = {
    "Set" : 0,
    "Ack" : 128,
}
def lookup_encode_SONICHUB_CONTROL(value):
    result = lookup_dict_encode_SONICHUB_CONTROL.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SONICHUB_CONTROL")
    return result

lookup_dict_encode_SONICHUB_SOURCE = {
    "AM" : 0,
    "FM" : 1,
    "iPod" : 2,
    "USB" : 3,
    "AUX" : 4,
    "AUX 2" : 5,
    "Mic" : 6,
}
def lookup_encode_SONICHUB_SOURCE(value):
    result = lookup_dict_encode_SONICHUB_SOURCE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SONICHUB_SOURCE")
    return result

lookup_dict_encode_ISO_CONTROL = {
    "ACK" : 0,
    "NAK" : 1,
    "Access Denied" : 2,
    "Address Busy" : 3,
}
def lookup_encode_ISO_CONTROL(value):
    result = lookup_dict_encode_ISO_CONTROL.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ISO_CONTROL")
    return result

lookup_dict_encode_ISO_COMMAND = {
    "ACK" : 0,
    "RTS" : 16,
    "CTS" : 17,
    "EOM" : 19,
    "BAM" : 32,
    "Abort" : 255,
}
def lookup_encode_ISO_COMMAND(value):
    result = lookup_dict_encode_ISO_COMMAND.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from ISO_COMMAND")
    return result

lookup_dict_encode_GROUP_FUNCTION = {
    "Request" : 0,
    "Command" : 1,
    "Acknowledge" : 2,
    "Read Fields" : 3,
    "Read Fields Reply" : 4,
    "Write Fields" : 5,
    "Write Fields Reply" : 6,
}
def lookup_encode_GROUP_FUNCTION(value):
    result = lookup_dict_encode_GROUP_FUNCTION.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from GROUP_FUNCTION")
    return result

lookup_dict_encode_AIRMAR_COMMAND = {
    "Attitude Offsets" : 32,
    "Calibrate Compass" : 33,
    "True Wind Options" : 34,
    "Simulate Mode" : 35,
    "Calibrate Depth" : 40,
    "Calibrate Speed" : 41,
    "Calibrate Temperature" : 42,
    "Speed Filter" : 43,
    "Temperature Filter" : 44,
    "NMEA 2000 options" : 46,
}
def lookup_encode_AIRMAR_COMMAND(value):
    result = lookup_dict_encode_AIRMAR_COMMAND.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from AIRMAR_COMMAND")
    return result

lookup_dict_encode_AIRMAR_DEPTH_QUALITY_FACTOR = {
    "Depth unlocked" : 0,
    "Quality 10%" : 1,
    "Quality 20%" : 2,
    "Quality 30%" : 3,
    "Quality 40%" : 4,
    "Quality 50%" : 5,
    "Quality 60%" : 6,
    "Quality 70%" : 7,
    "Quality 80%" : 8,
    "Quality 90%" : 9,
    "Quality 100%" : 10,
}
def lookup_encode_AIRMAR_DEPTH_QUALITY_FACTOR(value):
    result = lookup_dict_encode_AIRMAR_DEPTH_QUALITY_FACTOR.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from AIRMAR_DEPTH_QUALITY_FACTOR")
    return result

lookup_dict_encode_PGN_ERROR_CODE = {
    "Acknowledge" : 0,
    "PGN not supported" : 1,
    "PGN not available" : 2,
    "Access denied" : 3,
    "Not supported" : 4,
    "Tag not supported" : 5,
    "Read or Write not supported" : 6,
}
def lookup_encode_PGN_ERROR_CODE(value):
    result = lookup_dict_encode_PGN_ERROR_CODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from PGN_ERROR_CODE")
    return result

lookup_dict_encode_AIRMAR_TRANSMISSION_INTERVAL = {
    "Measure interval" : 0,
    "Requested by user" : 1,
}
def lookup_encode_AIRMAR_TRANSMISSION_INTERVAL(value):
    result = lookup_dict_encode_AIRMAR_TRANSMISSION_INTERVAL.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from AIRMAR_TRANSMISSION_INTERVAL")
    return result

lookup_dict_encode_MOB_POSITION_SOURCE = {
    "Position estimated by the vessel" : 0,
    "Position reported by MOB emitter" : 1,
}
def lookup_encode_MOB_POSITION_SOURCE(value):
    result = lookup_dict_encode_MOB_POSITION_SOURCE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from MOB_POSITION_SOURCE")
    return result

lookup_dict_encode_STEERING_MODE = {
    "Main Steering" : 0,
    "Non-Follow-Up Device" : 1,
    "Follow-Up Device" : 2,
    "Heading Control Standalone" : 3,
    "Heading Control" : 4,
    "Track Control" : 5,
}
def lookup_encode_STEERING_MODE(value):
    result = lookup_dict_encode_STEERING_MODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from STEERING_MODE")
    return result

lookup_dict_encode_FUSION_RADIO_SOURCE = {
    "AM" : 0,
    "FM" : 1,
}
def lookup_encode_FUSION_RADIO_SOURCE(value):
    result = lookup_dict_encode_FUSION_RADIO_SOURCE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from FUSION_RADIO_SOURCE")
    return result

lookup_dict_encode_FUSION_REPLAY_MODE = {
    "USB repeat" : 9,
    "USB shuffle" : 10,
    "iPod repeat" : 12,
    "iPod shuffle" : 13,
}
def lookup_encode_FUSION_REPLAY_MODE(value):
    result = lookup_dict_encode_FUSION_REPLAY_MODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from FUSION_REPLAY_MODE")
    return result

lookup_dict_encode_FUSION_REPLAY_STATUS = {
    "Off" : 0,
    "One/track" : 1,
    "All/album" : 2,
}
def lookup_encode_FUSION_REPLAY_STATUS(value):
    result = lookup_dict_encode_FUSION_REPLAY_STATUS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from FUSION_REPLAY_STATUS")
    return result

lookup_dict_encode_AIRMAR_POST_CONTROL = {
    "Report previous values" : 0,
    "Generate new values" : 1,
}
def lookup_encode_AIRMAR_POST_CONTROL(value):
    result = lookup_dict_encode_AIRMAR_POST_CONTROL.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from AIRMAR_POST_CONTROL")
    return result

lookup_dict_encode_AIRMAR_POST_ID = {
    "Format Code" : 1,
    "Factory EEPROM" : 2,
    "User EEPROM" : 3,
    "Water Temperature Sensor" : 4,
    "Sonar Transceiver" : 5,
    "Speed sensor" : 6,
    "Internal temperature sensor" : 7,
    "Battery voltage sensor" : 8,
}
def lookup_encode_AIRMAR_POST_ID(value):
    result = lookup_dict_encode_AIRMAR_POST_ID.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from AIRMAR_POST_ID")
    return result

lookup_dict_encode_SONICHUB_TUNING = {
    "Seeking up" : 1,
    "Tuned" : 2,
    "Seeking down" : 3,
}
def lookup_encode_SONICHUB_TUNING(value):
    result = lookup_dict_encode_SONICHUB_TUNING.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SONICHUB_TUNING")
    return result

lookup_dict_encode_SONICHUB_PLAYLIST = {
    "Report" : 1,
    "Next song" : 4,
    "Previous song" : 6,
}
def lookup_encode_SONICHUB_PLAYLIST(value):
    result = lookup_dict_encode_SONICHUB_PLAYLIST.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SONICHUB_PLAYLIST")
    return result

lookup_dict_encode_FUSION_POWER_STATE = {
    "On" : 1,
    "Off" : 2,
}
def lookup_encode_FUSION_POWER_STATE(value):
    result = lookup_dict_encode_FUSION_POWER_STATE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from FUSION_POWER_STATE")
    return result

lookup_dict_encode_PRIORITY = {
    "0" : 0,
    "1" : 1,
    "2" : 2,
    "3" : 3,
    "4" : 4,
    "5" : 5,
    "6" : 6,
    "7" : 7,
    "Leave unchanged" : 8,
    "Reset to default" : 9,
}
def lookup_encode_PRIORITY(value):
    result = lookup_dict_encode_PRIORITY.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from PRIORITY")
    return result

lookup_dict_encode_DEVICE_TEMP_STATE = {
    "Cold" : 0,
    "Warm" : 1,
    "Hot" : 2,
}
def lookup_encode_DEVICE_TEMP_STATE(value):
    result = lookup_dict_encode_DEVICE_TEMP_STATE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from DEVICE_TEMP_STATE")
    return result

lookup_dict_encode_BANDG_DECIMALS = {
    "0" : 0,
    "1" : 1,
    "2" : 2,
    "3" : 3,
    "4" : 4,
    "Auto" : 254,
}
def lookup_encode_BANDG_DECIMALS(value):
    result = lookup_dict_encode_BANDG_DECIMALS.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from BANDG_DECIMALS")
    return result

lookup_dict_encode_GARMIN_COLOR_MODE = {
    "Day" : 0,
    "Night" : 1,
    "Color" : 13,
}
def lookup_encode_GARMIN_COLOR_MODE(value):
    result = lookup_dict_encode_GARMIN_COLOR_MODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from GARMIN_COLOR_MODE")
    return result

lookup_dict_encode_GARMIN_COLOR = {
    "Day full color" : 0,
    "Day high contrast" : 1,
    "Night full color" : 2,
    "Night red/black" : 3,
    "Night green/black" : 4,
}
def lookup_encode_GARMIN_COLOR(value):
    result = lookup_dict_encode_GARMIN_COLOR.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from GARMIN_COLOR")
    return result

lookup_dict_encode_GARMIN_BACKLIGHT_LEVEL = {
    "0%" : 0,
    "5%" : 1,
    "10%" : 2,
    "15%" : 3,
    "20%" : 4,
    "25%" : 5,
    "30%" : 6,
    "35%" : 7,
    "40%" : 8,
    "45%" : 9,
    "50%" : 10,
    "55%" : 11,
    "60%" : 12,
    "65%" : 13,
    "70%" : 14,
    "75%" : 15,
    "80%" : 16,
    "85%" : 17,
    "90%" : 18,
    "95%" : 19,
    "100%" : 20,
}
def lookup_encode_GARMIN_BACKLIGHT_LEVEL(value):
    result = lookup_dict_encode_GARMIN_BACKLIGHT_LEVEL.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from GARMIN_BACKLIGHT_LEVEL")
    return result

lookup_dict_encode_SEATALK_PILOT_MODE_16 = {
    "Standby" : 0,
    "Auto, compass commanded" : 64,
    "Vane, Wind Mode" : 256,
    "Track Mode" : 384,
    "No Drift, COG referenced (In track, course changes)" : 385,
}
def lookup_encode_SEATALK_PILOT_MODE_16(value):
    result = lookup_dict_encode_SEATALK_PILOT_MODE_16.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SEATALK_PILOT_MODE_16")
    return result

lookup_dict_encode_STATION_HEALTH = {
    "Not Working" : 0,
    "Unmonitored" : 1,
    "Healthy Operational" : 2,
    "Healthy Test Mode" : 3,
    "Test Mode" : 4,
}
def lookup_encode_STATION_HEALTH(value):
    result = lookup_dict_encode_STATION_HEALTH.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from STATION_HEALTH")
    return result

lookup_dict_encode_SERIAL_BIT_RATE = {
    "25" : 0,
    "50" : 1,
    "100" : 2,
    "200" : 3,
    "300" : 4,
    "600" : 5,
    "1200" : 6,
    "2400" : 7,
    "4800" : 8,
    "9600" : 9,
    "19200" : 10,
    "19200" : 11,
    "38400" : 12,
    "57600" : 13,
}
def lookup_encode_SERIAL_BIT_RATE(value):
    result = lookup_dict_encode_SERIAL_BIT_RATE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SERIAL_BIT_RATE")
    return result

lookup_dict_encode_SERIAL_DETECTION_MODE = {
    "Auto bit rate" : 0,
    "Manual bit rate" : 1,
}
def lookup_encode_SERIAL_DETECTION_MODE(value):
    result = lookup_dict_encode_SERIAL_DETECTION_MODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from SERIAL_DETECTION_MODE")
    return result

lookup_dict_encode_DIFFERENTIAL_SOURCE = {
    "Auto" : 0,
    "Loran" : 1,
    "MSK Beacon" : 2,
    "FM Subcarrier" : 3,
    "AIS" : 4,
    "Ground based radio" : 5,
    "SBAS" : 6,
    "Satellite" : 7,
}
def lookup_encode_DIFFERENTIAL_SOURCE(value):
    result = lookup_dict_encode_DIFFERENTIAL_SOURCE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from DIFFERENTIAL_SOURCE")
    return result

lookup_dict_encode_DIFFERENTIAL_MODE = {
    "Manual" : 0,
    "Auto Power" : 1,
    "Auto Range" : 2,
}
def lookup_encode_DIFFERENTIAL_MODE(value):
    result = lookup_dict_encode_DIFFERENTIAL_MODE.get(value, None)
    if result is None:
        raise Exception(f"Cant encode this message, {value} is missing from DIFFERENTIAL_MODE")
    return result




lookup_field_type_dict_SIMNET_KEY_VALUE = {
    0: LookupFieldTypeEnumeration("Heading Offset", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    41: LookupFieldTypeEnumeration("Timezone offset", FieldTypes.TIME, 60, "s", 16, None),
    260: LookupFieldTypeEnumeration("True wind high", FieldTypes.NUMBER, 0.01, "m/s", 16, None),
    264: LookupFieldTypeEnumeration("Deep water", FieldTypes.NUMBER, 0.01, "m", 32, None),
    516: LookupFieldTypeEnumeration("True wind low", FieldTypes.NUMBER, 0.01, "m/s", 16, None),
    517: LookupFieldTypeEnumeration("Low boat speed", FieldTypes.NUMBER, 0.01, "m/s", 16, None),
    520: LookupFieldTypeEnumeration("Shallow water", FieldTypes.NUMBER, 0.01, "m", 32, None),
    768: LookupFieldTypeEnumeration("Local field", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    1024: LookupFieldTypeEnumeration("Field angle", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    1800: LookupFieldTypeEnumeration("Anchor depth", FieldTypes.NUMBER, 0.01, "m/s", 16, None),
    4863: LookupFieldTypeEnumeration("Backlight level", FieldTypes.LOOKUP, None, None, 8, "SIMNET_BACKLIGHT_LEVEL"),
    5160: LookupFieldTypeEnumeration("Time format", FieldTypes.LOOKUP, None, None, 8, "SIMNET_TIME_FORMAT"),
    5161: LookupFieldTypeEnumeration("Time hour display", FieldTypes.LOOKUP, None, None, 8, "SIMNET_HOUR_DISPLAY"),
    9983: LookupFieldTypeEnumeration("Night mode", FieldTypes.LOOKUP, None, None, 8, "SIMNET_NIGHT_MODE"),
    11524: LookupFieldTypeEnumeration("True wind shift", FieldTypes.NUMBER, 0.01, "m/s", 16, None),
    22296: LookupFieldTypeEnumeration("AP low boat speed", FieldTypes.NUMBER, 0.01, "m/s", 16, None),
    32789: LookupFieldTypeEnumeration("Alert bits", FieldTypes.BITLOOKUP, None, None, 16, None),
    44079: LookupFieldTypeEnumeration("Night mode color", FieldTypes.LOOKUP, None, None, 8, "SIMNET_NIGHT_MODE_COLOR"),
    55087: LookupFieldTypeEnumeration("Day mode invert", FieldTypes.NUMBER, None, None, 8, None),
}
def lookup_field_type_SIMNET_KEY_VALUE(value):
    return lookup_field_type_dict_SIMNET_KEY_VALUE.get(value)

lookup_field_type_dict_BANDG_KEY_VALUE = {
    0: LookupFieldTypeEnumeration("Altitude", FieldTypes.NUMBER, None, None, 16, None),
    11: LookupFieldTypeEnumeration("Rudder Angle", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    16: LookupFieldTypeEnumeration("User 5", FieldTypes.NUMBER, 0.01, None, 32, None),
    17: LookupFieldTypeEnumeration("User 6", FieldTypes.NUMBER, 0.01, None, 32, None),
    18: LookupFieldTypeEnumeration("User 7", FieldTypes.NUMBER, 0.01, None, 32, None),
    19: LookupFieldTypeEnumeration("User 8", FieldTypes.NUMBER, 0.01, None, 32, None),
    20: LookupFieldTypeEnumeration("User 9", FieldTypes.NUMBER, 0.01, None, 32, None),
    21: LookupFieldTypeEnumeration("User 10", FieldTypes.NUMBER, 0.01, None, 32, None),
    22: LookupFieldTypeEnumeration("User 11", FieldTypes.NUMBER, 0.01, None, 32, None),
    23: LookupFieldTypeEnumeration("User 12", FieldTypes.NUMBER, 0.01, None, 32, None),
    24: LookupFieldTypeEnumeration("User 13", FieldTypes.NUMBER, 0.01, None, 32, None),
    25: LookupFieldTypeEnumeration("User 14", FieldTypes.NUMBER, 0.01, None, 32, None),
    26: LookupFieldTypeEnumeration("User 15", FieldTypes.NUMBER, 0.01, None, 32, None),
    27: LookupFieldTypeEnumeration("User 16", FieldTypes.NUMBER, 0.01, None, 32, None),
    28: LookupFieldTypeEnumeration("Outside Temperature", FieldTypes.NUMBER, 0.01, "K", 16, None),
    29: LookupFieldTypeEnumeration("Outside Temperature", FieldTypes.NUMBER, 0.01, "K", 16, None),
    30: LookupFieldTypeEnumeration("Water Temperature", FieldTypes.NUMBER, 0.01, "K", 16, None),
    31: LookupFieldTypeEnumeration("Water Temperature", FieldTypes.NUMBER, 0.01, "K", 16, None),
    50: LookupFieldTypeEnumeration("Tacking Performance", FieldTypes.NUMBER, 0.1, "%", 16, None),
    52: LookupFieldTypeEnumeration("Attitude Roll", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    53: LookupFieldTypeEnumeration("Optimum Wind Angle", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    56: LookupFieldTypeEnumeration("User 1", FieldTypes.NUMBER, 0.01, None, 32, None),
    57: LookupFieldTypeEnumeration("User 2", FieldTypes.NUMBER, 0.01, None, 32, None),
    58: LookupFieldTypeEnumeration("User 3", FieldTypes.NUMBER, 0.01, None, 32, None),
    59: LookupFieldTypeEnumeration("User 4", FieldTypes.NUMBER, 0.01, None, 32, None),
    60: LookupFieldTypeEnumeration("Roll Rate", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    64: LookupFieldTypeEnumeration("Forestay", FieldTypes.NUMBER, 0.001, None, 32, None),
    65: LookupFieldTypeEnumeration("Water Speed", FieldTypes.NUMBER, 0.01, "m/s", 16, None),
    77: LookupFieldTypeEnumeration("Wind Speed Apparent", FieldTypes.NUMBER, 0.01, "m/s", 16, None),
    79: LookupFieldTypeEnumeration("Wind Speed Apparent", FieldTypes.NUMBER, 0.01, "m/s", 16, None),
    80: LookupFieldTypeEnumeration("Average True Wind Direction", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    81: LookupFieldTypeEnumeration("Wind Angle Apparent", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    83: LookupFieldTypeEnumeration("Target TWA", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    85: LookupFieldTypeEnumeration("Wind Speed True", FieldTypes.NUMBER, 0.01, "m/s", 16, None),
    86: LookupFieldTypeEnumeration("Wind Speed True", FieldTypes.NUMBER, 0.01, "m/s", 16, None),
    89: LookupFieldTypeEnumeration("Wind Angle True", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    100: LookupFieldTypeEnumeration("Unknown", FieldTypes.NUMBER, None, None, 16, None),
    102: LookupFieldTypeEnumeration("Keel Angle", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    103: LookupFieldTypeEnumeration("Canard Angle", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    104: LookupFieldTypeEnumeration("Keel Trim Tab Angle", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    105: LookupFieldTypeEnumeration("Course", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    109: LookupFieldTypeEnumeration("Wind Direction", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    111: LookupFieldTypeEnumeration("Next Leg AWA", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    113: LookupFieldTypeEnumeration("Next Leg AWS", FieldTypes.NUMBER, 0.01, "m/s", 16, None),
    117: LookupFieldTypeEnumeration("Race Timer", FieldTypes.TIME, 0.001, "s", 32, None),
    124: LookupFieldTypeEnumeration("Polar Performance", FieldTypes.NUMBER, 0.1, "%", 16, None),
    125: LookupFieldTypeEnumeration("Target Boat Speed", FieldTypes.NUMBER, 0.01, "m/s", 16, None),
    126: LookupFieldTypeEnumeration("Polar Speed", FieldTypes.NUMBER, 0.01, "m/s", 16, None),
    127: LookupFieldTypeEnumeration("VMG to Wind", FieldTypes.NUMBER, 0.01, "m/s", 16, None),
    129: LookupFieldTypeEnumeration("DR Distance", FieldTypes.NUMBER, 0.01, "m", 32, None),
    130: LookupFieldTypeEnumeration("Leeway Angle", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    131: LookupFieldTypeEnumeration("Current Drift", FieldTypes.NUMBER, 0.01, "m/s", 16, None),
    132: LookupFieldTypeEnumeration("Current Set", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    135: LookupFieldTypeEnumeration("Barometric Pressure", FieldTypes.NUMBER, 100, "Pa", 16, None),
    152: LookupFieldTypeEnumeration("Distance to Start Line", FieldTypes.NUMBER, 0.01, "m", 32, None),
    154: LookupFieldTypeEnumeration("Heading on Opposite Tack", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    155: LookupFieldTypeEnumeration("Attitude Pitch", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    156: LookupFieldTypeEnumeration("Mast Angle", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    157: LookupFieldTypeEnumeration("Wind Angle to Mast", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    158: LookupFieldTypeEnumeration("Pitch Angle", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    163: LookupFieldTypeEnumeration("Daggerboard Position", FieldTypes.NUMBER, None, None, 16, None),
    164: LookupFieldTypeEnumeration("Boom Position", FieldTypes.NUMBER, None, None, 16, None),
    185: LookupFieldTypeEnumeration("MOB DR Bearing", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    186: LookupFieldTypeEnumeration("MOB DR Range", FieldTypes.NUMBER, 0.01, "m", 32, None),
    194: LookupFieldTypeEnumeration("Depth", FieldTypes.NUMBER, 0.01, "m", 32, None),
    195: LookupFieldTypeEnumeration("Depth", FieldTypes.NUMBER, 0.01, "m", 32, None),
    199: LookupFieldTypeEnumeration("Aft Depth", FieldTypes.NUMBER, 0.01, "m", 32, None),
    205: LookupFieldTypeEnumeration("Odometer", FieldTypes.NUMBER, 0.01, "m", 32, None),
    207: LookupFieldTypeEnumeration("Trip Distance", FieldTypes.NUMBER, 0.01, "m", 32, None),
    211: LookupFieldTypeEnumeration("DR Bearing", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    233: LookupFieldTypeEnumeration("Course Over Ground", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    235: LookupFieldTypeEnumeration("Speed Over Ground", FieldTypes.NUMBER, 0.01, "m/s", 16, None),
    239: LookupFieldTypeEnumeration("Remote 0", FieldTypes.NUMBER, 0.001, None, 16, None),
    240: LookupFieldTypeEnumeration("Remote 1", FieldTypes.NUMBER, 0.001, None, 16, None),
    241: LookupFieldTypeEnumeration("Remote 2", FieldTypes.NUMBER, 0.001, None, 16, None),
    242: LookupFieldTypeEnumeration("Remote 3", FieldTypes.NUMBER, 0.001, None, 16, None),
    243: LookupFieldTypeEnumeration("Remote 4", FieldTypes.NUMBER, 0.001, None, 16, None),
    244: LookupFieldTypeEnumeration("Remote 5", FieldTypes.NUMBER, 0.001, None, 16, None),
    245: LookupFieldTypeEnumeration("Remote 6", FieldTypes.NUMBER, 0.001, None, 16, None),
    246: LookupFieldTypeEnumeration("Remote 7", FieldTypes.NUMBER, 0.001, None, 16, None),
    247: LookupFieldTypeEnumeration("Remote 8", FieldTypes.NUMBER, 0.001, None, 16, None),
    248: LookupFieldTypeEnumeration("Remote 9", FieldTypes.NUMBER, 0.001, None, 16, None),
    256: LookupFieldTypeEnumeration("Layline Time", FieldTypes.TIME, 0.001, "s", 32, None),
    258: LookupFieldTypeEnumeration("Layline Distance", FieldTypes.NUMBER, 0.01, "m", 32, None),
    259: LookupFieldTypeEnumeration("Layline Distance", FieldTypes.NUMBER, 0.01, "m", 32, None),
    260: LookupFieldTypeEnumeration("Sailing Time to Waypoint", FieldTypes.TIME, 0.001, "s", 32, None),
    261: LookupFieldTypeEnumeration("Sailing Distance to Waypoint", FieldTypes.NUMBER, 0.01, "m", 32, None),
    262: LookupFieldTypeEnumeration("Sailing ETA", FieldTypes.TIME, 0.001, "s", 32, None),
    265: LookupFieldTypeEnumeration("Trip Time", FieldTypes.TIME, 0.001, "s", 32, None),
    270: LookupFieldTypeEnumeration("Bow Latitude", FieldTypes.NUMBER, 1e-07, "deg", 32, None),
    271: LookupFieldTypeEnumeration("Bow Longitude", FieldTypes.NUMBER, 1e-07, "deg", 32, None),
    272: LookupFieldTypeEnumeration("Start Line Bearing", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    273: LookupFieldTypeEnumeration("Start Line Bias", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    274: LookupFieldTypeEnumeration("Distance to Start Line Port", FieldTypes.NUMBER, 0.01, "m", 32, None),
    275: LookupFieldTypeEnumeration("Distance to Start Line Starboard", FieldTypes.NUMBER, 0.01, "m", 32, None),
    280: LookupFieldTypeEnumeration("Bias Advantage in Boat Lengths", FieldTypes.NUMBER, 0.1, None, 16, None),
    281: LookupFieldTypeEnumeration("Distance to Start Line in Boat Lengths", FieldTypes.NUMBER, 0.1, None, 16, None),
    282: LookupFieldTypeEnumeration("Backstay", FieldTypes.NUMBER, 0.001, None, 32, None),
    283: LookupFieldTypeEnumeration("Boom Vang", FieldTypes.NUMBER, 0.001, None, 32, None),
    284: LookupFieldTypeEnumeration("Chain Length", FieldTypes.NUMBER, 0.01, "m", 32, None),
    285: LookupFieldTypeEnumeration("VMG Performance", FieldTypes.NUMBER, 0.1, "%", 16, None),
    286: LookupFieldTypeEnumeration("Inner Forestay Load", FieldTypes.NUMBER, 0.001, None, 32, None),
    287: LookupFieldTypeEnumeration("Inner Forestay Halyard Load", FieldTypes.NUMBER, 0.001, None, 32, None),
    288: LookupFieldTypeEnumeration("Jib Furl", FieldTypes.NUMBER, 0.01, "m", 32, None),
    289: LookupFieldTypeEnumeration("Jib Halyard Load", FieldTypes.NUMBER, 0.001, None, 32, None),
    290: LookupFieldTypeEnumeration("Outhaul Load", FieldTypes.NUMBER, 0.001, None, 32, None),
    291: LookupFieldTypeEnumeration("Plow Angle", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    292: LookupFieldTypeEnumeration("Cunningham", FieldTypes.NUMBER, 0.001, None, 32, None),
    293: LookupFieldTypeEnumeration("Jacuzzi Temperature", FieldTypes.NUMBER, 0.01, "K", 16, None),
    294: LookupFieldTypeEnumeration("Pool Temperature", FieldTypes.NUMBER, 0.01, "K", 16, None),
    296: LookupFieldTypeEnumeration("Keel Draught", FieldTypes.NUMBER, 0.01, "m", 16, None),
    297: LookupFieldTypeEnumeration("Boom Angle", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    298: LookupFieldTypeEnumeration("Code Zero Load", FieldTypes.NUMBER, 0.001, None, 32, None),
    301: LookupFieldTypeEnumeration("Distance Behind Start Line", FieldTypes.NUMBER, 0.01, "m", 32, None),
    302: LookupFieldTypeEnumeration("Distance Behind Start Line in Boat Lengths", FieldTypes.NUMBER, 0.1, None, 16, None),
    305: LookupFieldTypeEnumeration("Bias Advantage", FieldTypes.NUMBER, 0.01, "m", 32, None),
    306: LookupFieldTypeEnumeration("Opposite Tack COG", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    307: LookupFieldTypeEnumeration("Opposite Tack Target Heading", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    308: LookupFieldTypeEnumeration("Mast Rake", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    309: LookupFieldTypeEnumeration("Next Leg Bearing", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    310: LookupFieldTypeEnumeration("Next Leg Target Speed", FieldTypes.NUMBER, 0.01, "m/s", 16, None),
    311: LookupFieldTypeEnumeration("Ground Wind Direction", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    312: LookupFieldTypeEnumeration("Ground Wind Speed", FieldTypes.NUMBER, 0.01, "m/s", 16, None),
    313: LookupFieldTypeEnumeration("Mast Cant Angle", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    314: LookupFieldTypeEnumeration("Rudder Toe In", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    315: LookupFieldTypeEnumeration("Daggerboard Port", FieldTypes.NUMBER, None, None, 16, None),
    316: LookupFieldTypeEnumeration("Daggerboard Starboard", FieldTypes.NUMBER, None, None, 16, None),
    317: LookupFieldTypeEnumeration("User 17", FieldTypes.NUMBER, 0.01, None, 32, None),
    318: LookupFieldTypeEnumeration("User 18", FieldTypes.NUMBER, 0.01, None, 32, None),
    319: LookupFieldTypeEnumeration("User 19", FieldTypes.NUMBER, 0.01, None, 32, None),
    320: LookupFieldTypeEnumeration("User 20", FieldTypes.NUMBER, 0.01, None, 32, None),
    321: LookupFieldTypeEnumeration("User 21", FieldTypes.NUMBER, 0.01, None, 32, None),
    322: LookupFieldTypeEnumeration("User 22", FieldTypes.NUMBER, 0.01, None, 32, None),
    323: LookupFieldTypeEnumeration("User 23", FieldTypes.NUMBER, 0.01, None, 32, None),
    324: LookupFieldTypeEnumeration("User 24", FieldTypes.NUMBER, 0.01, None, 32, None),
    325: LookupFieldTypeEnumeration("User 25", FieldTypes.NUMBER, 0.01, None, 32, None),
    326: LookupFieldTypeEnumeration("User 26", FieldTypes.NUMBER, 0.01, None, 32, None),
    327: LookupFieldTypeEnumeration("User 27", FieldTypes.NUMBER, 0.01, None, 32, None),
    328: LookupFieldTypeEnumeration("User 28", FieldTypes.NUMBER, 0.01, None, 32, None),
    329: LookupFieldTypeEnumeration("User 29", FieldTypes.NUMBER, 0.01, None, 32, None),
    330: LookupFieldTypeEnumeration("User 30", FieldTypes.NUMBER, 0.01, None, 32, None),
    331: LookupFieldTypeEnumeration("User 31", FieldTypes.NUMBER, 0.01, None, 32, None),
    332: LookupFieldTypeEnumeration("User 32", FieldTypes.NUMBER, 0.01, None, 32, None),
    336: LookupFieldTypeEnumeration("Average True Wind Direction", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    337: LookupFieldTypeEnumeration("Wind Phase", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    338: LookupFieldTypeEnumeration("Wind Lift", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    380: LookupFieldTypeEnumeration("Active Perf Mode", FieldTypes.NUMBER, None, None, 16, None),
    381: LookupFieldTypeEnumeration("Gust Bear Away", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    382: LookupFieldTypeEnumeration("TWS Bear Away", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    383: LookupFieldTypeEnumeration("Heel Compensation", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    384: LookupFieldTypeEnumeration("Pilot Net Course", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    385: LookupFieldTypeEnumeration("Pilot Target Wind Angle", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    386: LookupFieldTypeEnumeration("Pilot Weather Helm", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
    387: LookupFieldTypeEnumeration("Pilot Mean Heel", FieldTypes.NUMBER, 0.0001, "rad", 16, None),
}
def lookup_field_type_BANDG_KEY_VALUE(value):
    return lookup_field_type_dict_BANDG_KEY_VALUE.get(value)

def is_fast_pgn_59392() -> bool:
    """Return True if PGN 59392 is a fast PGN."""
    return False
# ERROR: This PGN is corrupted. It has multiple fields but none of them have a match attribute.
def decode_pgn_59392(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 59392."""
    nmea2000Message = NMEA2000Message(59392, '0xe8000xeeffStandardizedSingleFrameAddressed', '0xE800-0xEEFF: Standardized single-frame addressed')
    running_bit_offset = 0
    # 1:data | Offset: 0, Length: 64, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    data = data_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 64))
    nmea2000Message.fields.append(NMEA2000Field('data', 'Data', None, None, data, data_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 64

    return nmea2000Message

def encode_pgn_59392(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 59392."""
    data_raw = 0
    # data | Offset: 0, Length: 64, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'data')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFF) << 0
    return data_raw

def decode_pgn_59392(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 59392."""
    nmea2000Message = NMEA2000Message(59392, 'isoAcknowledgement', 'ISO Acknowledgement')
    running_bit_offset = 0
    # 1:control | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    control_raw = decode_int(_data_raw_, running_bit_offset, 8)
    control = master_dict['ISO_CONTROL'].get(control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:group_function | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    group_function = group_function_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('group_function', 'Group Function', None, None, group_function, group_function_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:reserved_16 | Offset: 16, Length: 24, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 24)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 24

    # 4:pgn | Offset: 40, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    pgn = pgn_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('pgn', 'PGN', "Parameter Group Number of requested information", None, pgn, pgn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    return nmea2000Message

def encode_pgn_59392(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 59392."""
    data_raw = 0
    # control | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ISO_CONTROL(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # group_function | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'group_function')
    if field is None:
        raise Exception("Cant encode this message, missing 'Group Function'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # reserved_16 | Offset: 16, Length: 24, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 16
    # pgn | Offset: 40, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pgn')
    if field is None:
        raise Exception("Cant encode this message, missing 'PGN'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 40
    return data_raw


def is_fast_pgn_59904() -> bool:
    """Return True if PGN 59904 is a fast PGN."""
    return False
def decode_pgn_59904(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 59904."""
    nmea2000Message = NMEA2000Message(59904, 'isoRequest', 'ISO Request')
    running_bit_offset = 0
    # 1:pgn | Offset: 0, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    pgn = pgn_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('pgn', 'PGN', None, None, pgn, pgn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    return nmea2000Message

def encode_pgn_59904(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 59904."""
    data_raw = 0
    # pgn | Offset: 0, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pgn')
    if field is None:
        raise Exception("Cant encode this message, missing 'PGN'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 0
    return data_raw


def is_fast_pgn_60160() -> bool:
    """Return True if PGN 60160 is a fast PGN."""
    return False
def decode_pgn_60160(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 60160."""
    nmea2000Message = NMEA2000Message(60160, 'isoTransportProtocolDataTransfer', 'ISO Transport Protocol, Data Transfer')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:data | Offset: 8, Length: 56, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    data = data_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 56))
    nmea2000Message.fields.append(NMEA2000Field('data', 'Data', None, None, data, data_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 56

    return nmea2000Message

def encode_pgn_60160(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 60160."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # data | Offset: 8, Length: 56, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'data')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFFFF) << 8
    return data_raw


def is_fast_pgn_60416() -> bool:
    """Return True if PGN 60416 is a fast PGN."""
    return False
# Complex PGN. number of matches: 5
def decode_pgn_60416(data_raw: int) -> NMEA2000Message:
    # isoTransportProtocolConnectionManagementRequestToSend | Description: ISO Transport Protocol, Connection Management - Request To Send
    if (
        (((data_raw >> 0) & 0xFF) == 16)
        ):
        return decode_pgn_60416_isoTransportProtocolConnectionManagementRequestToSend(data_raw)
    
    # isoTransportProtocolConnectionManagementClearToSend | Description: ISO Transport Protocol, Connection Management - Clear To Send
    if (
        (((data_raw >> 0) & 0xFF) == 17)
        ):
        return decode_pgn_60416_isoTransportProtocolConnectionManagementClearToSend(data_raw)
    
    # isoTransportProtocolConnectionManagementEndOfMessage | Description: ISO Transport Protocol, Connection Management - End Of Message
    if (
        (((data_raw >> 0) & 0xFF) == 19)
        ):
        return decode_pgn_60416_isoTransportProtocolConnectionManagementEndOfMessage(data_raw)
    
    # isoTransportProtocolConnectionManagementBroadcastAnnounce | Description: ISO Transport Protocol, Connection Management - Broadcast Announce
    if (
        (((data_raw >> 0) & 0xFF) == 32)
        ):
        return decode_pgn_60416_isoTransportProtocolConnectionManagementBroadcastAnnounce(data_raw)
    
    # isoTransportProtocolConnectionManagementAbort | Description: ISO Transport Protocol, Connection Management - Abort
    if (
        (((data_raw >> 0) & 0xFF) == 255)
        ):
        return decode_pgn_60416_isoTransportProtocolConnectionManagementAbort(data_raw)
    
    
    raise Exception("No matching sub-PGN found")
    
def decode_pgn_60416_isoTransportProtocolConnectionManagementRequestToSend(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 60416."""
    nmea2000Message = NMEA2000Message(60416, 'isoTransportProtocolConnectionManagementRequestToSend', 'ISO Transport Protocol, Connection Management - Request To Send')
    running_bit_offset = 0
    # 1:group_function_code | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 16, PartOfPrimaryKey: ,
    running_bit_offset = 0
    group_function_code_raw = decode_int(_data_raw_, running_bit_offset, 8)
    group_function_code = master_dict['ISO_COMMAND'].get(group_function_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('group_function_code', 'Group Function Code', "RTS", None, group_function_code, group_function_code_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:message_size | Offset: 8, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    message_size = message_size_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('message_size', 'Message size', "bytes", None, message_size, message_size_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:packets | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    packets = packets_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('packets', 'Packets', "packets", None, packets, packets_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:packets_reply | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    packets_reply = packets_reply_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('packets_reply', 'Packets reply', "packets sent in response to CTS", None, packets_reply, packets_reply_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:pgn | Offset: 40, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    pgn = pgn_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('pgn', 'PGN', None, None, pgn, pgn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    return nmea2000Message

def encode_pgn_60416_isoTransportProtocolConnectionManagementRequestToSend(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 60416."""
    data_raw = 0
    # group_function_code | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'group_function_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Group Function Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ISO_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # message_size | Offset: 8, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'message_size')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message size'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 8
    # packets | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'packets')
    if field is None:
        raise Exception("Cant encode this message, missing 'Packets'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # packets_reply | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'packets_reply')
    if field is None:
        raise Exception("Cant encode this message, missing 'Packets reply'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # pgn | Offset: 40, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pgn')
    if field is None:
        raise Exception("Cant encode this message, missing 'PGN'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 40
    return data_raw

def decode_pgn_60416_isoTransportProtocolConnectionManagementClearToSend(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 60416."""
    nmea2000Message = NMEA2000Message(60416, 'isoTransportProtocolConnectionManagementClearToSend', 'ISO Transport Protocol, Connection Management - Clear To Send')
    running_bit_offset = 0
    # 1:group_function_code | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 17, PartOfPrimaryKey: ,
    running_bit_offset = 0
    group_function_code_raw = decode_int(_data_raw_, running_bit_offset, 8)
    group_function_code = master_dict['ISO_COMMAND'].get(group_function_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('group_function_code', 'Group Function Code', "CTS", None, group_function_code, group_function_code_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:max_packets | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    max_packets = max_packets_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('max_packets', 'Max packets', "Number of frames that can be sent before another CTS is required", None, max_packets, max_packets_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:next_sid | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    next_sid = next_sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('next_sid', 'Next SID', "Number of next frame to be transmitted", None, next_sid, next_sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:reserved_24 | Offset: 24, Length: 16, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    reserved_24 = reserved_24_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('reserved_24', 'Reserved', None, None, reserved_24, reserved_24_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 16

    # 5:pgn | Offset: 40, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    pgn = pgn_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('pgn', 'PGN', None, None, pgn, pgn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    return nmea2000Message

def encode_pgn_60416_isoTransportProtocolConnectionManagementClearToSend(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 60416."""
    data_raw = 0
    # group_function_code | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'group_function_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Group Function Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ISO_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # max_packets | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'max_packets')
    if field is None:
        raise Exception("Cant encode this message, missing 'Max packets'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # next_sid | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'next_sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'Next SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # reserved_24 | Offset: 24, Length: 16, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_24')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 24
    # pgn | Offset: 40, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pgn')
    if field is None:
        raise Exception("Cant encode this message, missing 'PGN'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 40
    return data_raw

def decode_pgn_60416_isoTransportProtocolConnectionManagementEndOfMessage(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 60416."""
    nmea2000Message = NMEA2000Message(60416, 'isoTransportProtocolConnectionManagementEndOfMessage', 'ISO Transport Protocol, Connection Management - End Of Message')
    running_bit_offset = 0
    # 1:group_function_code | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 19, PartOfPrimaryKey: ,
    running_bit_offset = 0
    group_function_code_raw = decode_int(_data_raw_, running_bit_offset, 8)
    group_function_code = master_dict['ISO_COMMAND'].get(group_function_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('group_function_code', 'Group Function Code', "EOM", None, group_function_code, group_function_code_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:total_message_size | Offset: 8, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    total_message_size = total_message_size_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('total_message_size', 'Total message size', "bytes", None, total_message_size, total_message_size_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:total_number_of_frames_received | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    total_number_of_frames_received = total_number_of_frames_received_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('total_number_of_frames_received', 'Total number of frames received', "Total number of of frames received", None, total_number_of_frames_received, total_number_of_frames_received_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:reserved_32 | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    reserved_32 = reserved_32_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_32', 'Reserved', None, None, reserved_32, reserved_32_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:pgn | Offset: 40, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    pgn = pgn_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('pgn', 'PGN', None, None, pgn, pgn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    return nmea2000Message

def encode_pgn_60416_isoTransportProtocolConnectionManagementEndOfMessage(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 60416."""
    data_raw = 0
    # group_function_code | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'group_function_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Group Function Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ISO_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # total_message_size | Offset: 8, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'total_message_size')
    if field is None:
        raise Exception("Cant encode this message, missing 'Total message size'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 8
    # total_number_of_frames_received | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'total_number_of_frames_received')
    if field is None:
        raise Exception("Cant encode this message, missing 'Total number of frames received'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # reserved_32 | Offset: 32, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_32')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # pgn | Offset: 40, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pgn')
    if field is None:
        raise Exception("Cant encode this message, missing 'PGN'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 40
    return data_raw

def decode_pgn_60416_isoTransportProtocolConnectionManagementBroadcastAnnounce(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 60416."""
    nmea2000Message = NMEA2000Message(60416, 'isoTransportProtocolConnectionManagementBroadcastAnnounce', 'ISO Transport Protocol, Connection Management - Broadcast Announce')
    running_bit_offset = 0
    # 1:group_function_code | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 32, PartOfPrimaryKey: ,
    running_bit_offset = 0
    group_function_code_raw = decode_int(_data_raw_, running_bit_offset, 8)
    group_function_code = master_dict['ISO_COMMAND'].get(group_function_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('group_function_code', 'Group Function Code', "BAM", None, group_function_code, group_function_code_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:message_size | Offset: 8, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    message_size = message_size_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('message_size', 'Message size', "bytes", None, message_size, message_size_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:packets | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    packets = packets_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('packets', 'Packets', "frames", None, packets, packets_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:reserved_32 | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    reserved_32 = reserved_32_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_32', 'Reserved', None, None, reserved_32, reserved_32_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:pgn | Offset: 40, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    pgn = pgn_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('pgn', 'PGN', None, None, pgn, pgn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    return nmea2000Message

def encode_pgn_60416_isoTransportProtocolConnectionManagementBroadcastAnnounce(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 60416."""
    data_raw = 0
    # group_function_code | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'group_function_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Group Function Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ISO_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # message_size | Offset: 8, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'message_size')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message size'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 8
    # packets | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'packets')
    if field is None:
        raise Exception("Cant encode this message, missing 'Packets'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # reserved_32 | Offset: 32, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_32')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # pgn | Offset: 40, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pgn')
    if field is None:
        raise Exception("Cant encode this message, missing 'PGN'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 40
    return data_raw

def decode_pgn_60416_isoTransportProtocolConnectionManagementAbort(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 60416."""
    nmea2000Message = NMEA2000Message(60416, 'isoTransportProtocolConnectionManagementAbort', 'ISO Transport Protocol, Connection Management - Abort')
    running_bit_offset = 0
    # 1:group_function_code | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 255, PartOfPrimaryKey: ,
    running_bit_offset = 0
    group_function_code_raw = decode_int(_data_raw_, running_bit_offset, 8)
    group_function_code = master_dict['ISO_COMMAND'].get(group_function_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('group_function_code', 'Group Function Code', "Abort", None, group_function_code, group_function_code_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:reason | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    reason = reason_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 8))
    nmea2000Message.fields.append(NMEA2000Field('reason', 'Reason', None, None, reason, reason_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 8

    # 3:reserved_16 | Offset: 16, Length: 24, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 24)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 24

    # 4:pgn | Offset: 40, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    pgn = pgn_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('pgn', 'PGN', None, None, pgn, pgn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    return nmea2000Message

def encode_pgn_60416_isoTransportProtocolConnectionManagementAbort(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 60416."""
    data_raw = 0
    # group_function_code | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'group_function_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Group Function Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ISO_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # reason | Offset: 8, Length: 8, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'reason')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reason'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # reserved_16 | Offset: 16, Length: 24, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 16
    # pgn | Offset: 40, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pgn')
    if field is None:
        raise Exception("Cant encode this message, missing 'PGN'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 40
    return data_raw


def is_fast_pgn_60928() -> bool:
    """Return True if PGN 60928 is a fast PGN."""
    return False
def decode_pgn_60928(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 60928."""
    nmea2000Message = NMEA2000Message(60928, 'isoAddressClaim', 'ISO Address Claim')
    running_bit_offset = 0
    # 1:unique_number | Offset: 0, Length: 21, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    unique_number = unique_number_raw = decode_number(_data_raw_, running_bit_offset, 21, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unique_number', 'Unique Number', "ISO Identity Number", None, unique_number, unique_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 21

    # 2:manufacturer_code | Offset: 21, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 21
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', None, None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 3:device_instance_lower | Offset: 32, Length: 3, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 32
    device_instance_lower = device_instance_lower_raw = decode_number(_data_raw_, running_bit_offset, 3, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('device_instance_lower', 'Device Instance Lower', "ISO ECU Instance", None, device_instance_lower, device_instance_lower_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 3

    # 4:device_instance_upper | Offset: 35, Length: 5, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 35
    device_instance_upper = device_instance_upper_raw = decode_number(_data_raw_, running_bit_offset, 5, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('device_instance_upper', 'Device Instance Upper', "ISO Function Instance", None, device_instance_upper, device_instance_upper_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 5

    # 5:device_function | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: INDIRECT_LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    device_function_raw = decode_int(_data_raw_, running_bit_offset, 8)
    device_function = 'TEMP_VAL'
    nmea2000Message.fields.append(NMEA2000Field('device_function', 'Device Function', "ISO Function", None, device_function, device_function_raw, None, FieldTypes.INDIRECT_LOOKUP, False))
    running_bit_offset += 8

    # 6:spare | Offset: 48, Length: 1, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 1)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 1

    # 7:device_class | Offset: 49, Length: 7, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 49
    device_class_raw = decode_int(_data_raw_, running_bit_offset, 7)
    device_class = master_dict['DEVICE_CLASS'].get(device_class_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('device_class', 'Device Class', None, None, device_class, device_class_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 7
    combined_key = str(device_class_raw) + "_" + str(device_function_raw)
    device_function = master_indirect_lookup_dict['DEVICE_FUNCTION'].get(combined_key, None)
    nmea2000Message.fields[4].value = device_function

    # 8:system_instance | Offset: 56, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 56
    system_instance = system_instance_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('system_instance', 'System Instance', "ISO Device Class Instance", None, system_instance, system_instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 4

    # 9:industry_group | Offset: 60, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 60
    industry_group_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_group = master_dict['INDUSTRY_CODE'].get(industry_group_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_group', 'Industry Group', None, None, industry_group, industry_group_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 10:arbitrary_address_capable | Offset: 63, Length: 1, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 63
    arbitrary_address_capable = arbitrary_address_capable_raw = decode_number(_data_raw_, running_bit_offset, 1, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('arbitrary_address_capable', 'Arbitrary address capable', "Field indicates whether the device is capable to claim arbitrary source address. Value is 1 for NMEA200 devices. Could be 0 for J1939 device claims", None, arbitrary_address_capable, arbitrary_address_capable_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 1

    return nmea2000Message

def encode_pgn_60928(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 60928."""
    data_raw = 0
    # unique_number | Offset: 0, Length: 21, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unique_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unique Number'")
    field_value = field.value
    data_raw |= (field_value & 0x1FFFFF) << 0
    # manufacturer_code | Offset: 21, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 21
    # device_instance_lower | Offset: 32, Length: 3, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'device_instance_lower')
    if field is None:
        raise Exception("Cant encode this message, missing 'Device Instance Lower'")
    field_value = field.value
    data_raw |= (field_value & 0x7) << 32
    # device_instance_upper | Offset: 35, Length: 5, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'device_instance_upper')
    if field is None:
        raise Exception("Cant encode this message, missing 'Device Instance Upper'")
    field_value = field.value
    data_raw |= (field_value & 0x1F) << 35
    # device_function | Offset: 40, Length: 8, Resolution: 1, Field Type: INDIRECT_LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'device_function')
    if field is None:
        raise Exception("Cant encode this message, missing 'Device Function'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # spare | Offset: 48, Length: 1, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0x1) << 48
    # device_class | Offset: 49, Length: 7, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'device_class')
    if field is None:
        raise Exception("Cant encode this message, missing 'Device Class'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DEVICE_CLASS(field.value)
    data_raw |= (field_value & 0x7F) << 49
    # system_instance | Offset: 56, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'system_instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'System Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 56
    # industry_group | Offset: 60, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_group')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Group'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 60
    # arbitrary_address_capable | Offset: 63, Length: 1, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'arbitrary_address_capable')
    if field is None:
        raise Exception("Cant encode this message, missing 'Arbitrary address capable'")
    field_value = field.value
    data_raw |= (field_value & 0x1) << 63
    return data_raw


def is_fast_pgn_61184() -> bool:
    """Return True if PGN 61184 is a fast PGN."""
    return False
# Complex PGN. number of matches: 4
def decode_pgn_61184(data_raw: int) -> NMEA2000Message:
    # seatalkWirelessKeypadLightControl | Description: Seatalk: Wireless Keypad Light Control
    if (
        (((data_raw >> 0) & 0x7FF) == 1851) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 1)
        ):
        return decode_pgn_61184_seatalkWirelessKeypadLightControl(data_raw)
    
    # seatalkWirelessKeypadControl | Description: Seatalk: Wireless Keypad Control
    if (
        (((data_raw >> 0) & 0x7FF) == 1851) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_61184_seatalkWirelessKeypadControl(data_raw)
    
    # victronBatteryRegister | Description: Victron Battery Register
    if (
        (((data_raw >> 0) & 0x7FF) == 358) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_61184_victronBatteryRegister(data_raw)
    
    return decode_pgn_61184_0xef00ManufacturerProprietarySingleFrameAddressed(data_raw)
    
def decode_pgn_61184_0xef00ManufacturerProprietarySingleFrameAddressed(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 61184."""
    nmea2000Message = NMEA2000Message(61184, '0xef00ManufacturerProprietarySingleFrameAddressed', '0xEF00: Manufacturer Proprietary single-frame addressed')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', None, None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', None, None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:data | Offset: 16, Length: 48, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    data = data_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 48))
    nmea2000Message.fields.append(NMEA2000Field('data', 'Data', None, None, data, data_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 48

    return nmea2000Message

def encode_pgn_61184_0xef00ManufacturerProprietarySingleFrameAddressed(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 61184."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # data | Offset: 16, Length: 48, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'data')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFF) << 16
    return data_raw

def decode_pgn_61184_seatalkWirelessKeypadLightControl(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 61184."""
    nmea2000Message = NMEA2000Message(61184, 'seatalkWirelessKeypadLightControl', 'Seatalk: Wireless Keypad Light Control')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1851, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Raymarine", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 1, PartOfPrimaryKey: True,
    running_bit_offset = 16
    proprietary_id = proprietary_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Wireless Keypad Light Control", None, proprietary_id, proprietary_id_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 5:variant | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    variant = variant_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('variant', 'Variant', None, None, variant, variant_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:wireless_setting | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    wireless_setting = wireless_setting_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('wireless_setting', 'Wireless Setting', None, None, wireless_setting, wireless_setting_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:wired_setting | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    wired_setting = wired_setting_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('wired_setting', 'Wired Setting', None, None, wired_setting, wired_setting_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:reserved_48 | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    reserved_48 = reserved_48_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('reserved_48', 'Reserved', None, None, reserved_48, reserved_48_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_61184_seatalkWirelessKeypadLightControl(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 61184."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # variant | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'variant')
    if field is None:
        raise Exception("Cant encode this message, missing 'Variant'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # wireless_setting | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'wireless_setting')
    if field is None:
        raise Exception("Cant encode this message, missing 'Wireless Setting'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # wired_setting | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'wired_setting')
    if field is None:
        raise Exception("Cant encode this message, missing 'Wired Setting'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # reserved_48 | Offset: 48, Length: 16, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_48')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw

def decode_pgn_61184_seatalkWirelessKeypadControl(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 61184."""
    nmea2000Message = NMEA2000Message(61184, 'seatalkWirelessKeypadControl', 'Seatalk: Wireless Keypad Control')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1851, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Raymarine", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:pid | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 16
    pid = pid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('pid', 'PID', None, None, pid, pid_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 5:variant | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    variant = variant_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('variant', 'Variant', None, None, variant, variant_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:beep_control | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    beep_control = beep_control_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('beep_control', 'Beep Control', None, None, beep_control, beep_control_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:reserved_40 | Offset: 40, Length: 24, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    reserved_40 = reserved_40_raw = decode_int(_data_raw_, running_bit_offset, 24)
    nmea2000Message.fields.append(NMEA2000Field('reserved_40', 'Reserved', None, None, reserved_40, reserved_40_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 24

    return nmea2000Message

def encode_pgn_61184_seatalkWirelessKeypadControl(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 61184."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # pid | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pid')
    if field is None:
        raise Exception("Cant encode this message, missing 'PID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # variant | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'variant')
    if field is None:
        raise Exception("Cant encode this message, missing 'Variant'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # beep_control | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'beep_control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Beep Control'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # reserved_40 | Offset: 40, Length: 24, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_40')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 40
    return data_raw

def decode_pgn_61184_victronBatteryRegister(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 61184."""
    nmea2000Message = NMEA2000Message(61184, 'victronBatteryRegister', 'Victron Battery Register')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 358, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Victron Energy", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:register_id | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    register_id = register_id_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('register_id', 'Register Id', None, None, register_id, register_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:payload | Offset: 32, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    payload = payload_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('payload', 'Payload', None, None, payload, payload_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_61184_victronBatteryRegister(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 61184."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # register_id | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'register_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Register Id'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # payload | Offset: 32, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'payload')
    if field is None:
        raise Exception("Cant encode this message, missing 'Payload'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw


def is_fast_pgn_61440() -> bool:
    """Return True if PGN 61440 is a fast PGN."""
    return False
def decode_pgn_61440(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 61440."""
    nmea2000Message = NMEA2000Message(61440, '0xf0000xfeffStandardizedSingleFrameNonAddressed', '0xF000-0xFEFF: Standardized single-frame non-addressed')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', None, None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', None, None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:data | Offset: 16, Length: 48, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    data = data_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 48))
    nmea2000Message.fields.append(NMEA2000Field('data', 'Data', None, None, data, data_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 48

    return nmea2000Message

def encode_pgn_61440(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 61440."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # data | Offset: 16, Length: 48, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'data')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFF) << 16
    return data_raw


def is_fast_pgn_65001() -> bool:
    """Return True if PGN 65001 is a fast PGN."""
    return False
def decode_pgn_65001(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65001."""
    nmea2000Message = NMEA2000Message(65001, 'bus1PhaseCBasicAcQuantities', 'Bus #1 Phase C Basic AC Quantities')
    running_bit_offset = 0
    # 1:line_line_ac_rms_voltage | Offset: 0, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    line_line_ac_rms_voltage = line_line_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_line_ac_rms_voltage', 'Line-Line AC RMS Voltage', None, 'V', line_line_ac_rms_voltage, line_line_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    line_neutral_ac_rms_voltage = line_neutral_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_neutral_ac_rms_voltage', 'Line-Neutral AC RMS Voltage', None, 'V', line_neutral_ac_rms_voltage, line_neutral_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:ac_frequency | Offset: 32, Length: 16, Signed: False Resolution: 0.0078125, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    ac_frequency = ac_frequency_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0078125)
    nmea2000Message.fields.append(NMEA2000Field('ac_frequency', 'AC Frequency', None, 'Hz', ac_frequency, ac_frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:reserved_48 | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    reserved_48 = reserved_48_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('reserved_48', 'Reserved', None, None, reserved_48, reserved_48_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_65001(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65001."""
    data_raw = 0
    # line_line_ac_rms_voltage | Offset: 0, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_line_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Line AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 0
    # line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_neutral_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Neutral AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # ac_frequency | Offset: 32, Length: 16, Resolution: 0.0078125, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC Frequency'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0078125) & 0xFFFF) << 32
    
    # reserved_48 | Offset: 48, Length: 16, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_48')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_65002() -> bool:
    """Return True if PGN 65002 is a fast PGN."""
    return False
def decode_pgn_65002(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65002."""
    nmea2000Message = NMEA2000Message(65002, 'bus1PhaseBBasicAcQuantities', 'Bus #1 Phase B Basic AC Quantities')
    running_bit_offset = 0
    # 1:line_line_ac_rms_voltage | Offset: 0, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    line_line_ac_rms_voltage = line_line_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_line_ac_rms_voltage', 'Line-Line AC RMS Voltage', None, 'V', line_line_ac_rms_voltage, line_line_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    line_neutral_ac_rms_voltage = line_neutral_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_neutral_ac_rms_voltage', 'Line-Neutral AC RMS Voltage', None, 'V', line_neutral_ac_rms_voltage, line_neutral_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:ac_frequency | Offset: 32, Length: 16, Signed: False Resolution: 0.0078125, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    ac_frequency = ac_frequency_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0078125)
    nmea2000Message.fields.append(NMEA2000Field('ac_frequency', 'AC Frequency', None, 'Hz', ac_frequency, ac_frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:reserved_48 | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    reserved_48 = reserved_48_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('reserved_48', 'Reserved', None, None, reserved_48, reserved_48_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_65002(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65002."""
    data_raw = 0
    # line_line_ac_rms_voltage | Offset: 0, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_line_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Line AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 0
    # line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_neutral_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Neutral AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # ac_frequency | Offset: 32, Length: 16, Resolution: 0.0078125, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC Frequency'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0078125) & 0xFFFF) << 32
    
    # reserved_48 | Offset: 48, Length: 16, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_48')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_65003() -> bool:
    """Return True if PGN 65003 is a fast PGN."""
    return False
def decode_pgn_65003(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65003."""
    nmea2000Message = NMEA2000Message(65003, 'bus1PhaseABasicAcQuantities', 'Bus #1 Phase A Basic AC Quantities')
    running_bit_offset = 0
    # 1:line_line_ac_rms_voltage | Offset: 0, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    line_line_ac_rms_voltage = line_line_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_line_ac_rms_voltage', 'Line-Line AC RMS Voltage', None, 'V', line_line_ac_rms_voltage, line_line_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    line_neutral_ac_rms_voltage = line_neutral_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_neutral_ac_rms_voltage', 'Line-Neutral AC RMS Voltage', None, 'V', line_neutral_ac_rms_voltage, line_neutral_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:ac_frequency | Offset: 32, Length: 16, Signed: False Resolution: 0.0078125, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    ac_frequency = ac_frequency_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0078125)
    nmea2000Message.fields.append(NMEA2000Field('ac_frequency', 'AC Frequency', None, 'Hz', ac_frequency, ac_frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:reserved_48 | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    reserved_48 = reserved_48_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('reserved_48', 'Reserved', None, None, reserved_48, reserved_48_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_65003(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65003."""
    data_raw = 0
    # line_line_ac_rms_voltage | Offset: 0, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_line_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Line AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 0
    # line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_neutral_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Neutral AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # ac_frequency | Offset: 32, Length: 16, Resolution: 0.0078125, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC Frequency'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0078125) & 0xFFFF) << 32
    
    # reserved_48 | Offset: 48, Length: 16, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_48')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_65004() -> bool:
    """Return True if PGN 65004 is a fast PGN."""
    return False
def decode_pgn_65004(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65004."""
    nmea2000Message = NMEA2000Message(65004, 'bus1AverageBasicAcQuantities', 'Bus #1 Average Basic AC Quantities')
    running_bit_offset = 0
    # 1:line_line_ac_rms_voltage | Offset: 0, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    line_line_ac_rms_voltage = line_line_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_line_ac_rms_voltage', 'Line-Line AC RMS Voltage', None, 'V', line_line_ac_rms_voltage, line_line_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    line_neutral_ac_rms_voltage = line_neutral_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_neutral_ac_rms_voltage', 'Line-Neutral AC RMS Voltage', None, 'V', line_neutral_ac_rms_voltage, line_neutral_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:ac_frequency | Offset: 32, Length: 16, Signed: False Resolution: 0.0078125, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    ac_frequency = ac_frequency_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0078125)
    nmea2000Message.fields.append(NMEA2000Field('ac_frequency', 'AC Frequency', None, 'Hz', ac_frequency, ac_frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:reserved_48 | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    reserved_48 = reserved_48_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('reserved_48', 'Reserved', None, None, reserved_48, reserved_48_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_65004(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65004."""
    data_raw = 0
    # line_line_ac_rms_voltage | Offset: 0, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_line_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Line AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 0
    # line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_neutral_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Neutral AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # ac_frequency | Offset: 32, Length: 16, Resolution: 0.0078125, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC Frequency'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0078125) & 0xFFFF) << 32
    
    # reserved_48 | Offset: 48, Length: 16, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_48')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_65005() -> bool:
    """Return True if PGN 65005 is a fast PGN."""
    return False
def decode_pgn_65005(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65005."""
    nmea2000Message = NMEA2000Message(65005, 'utilityTotalAcEnergy', 'Utility Total AC Energy')
    running_bit_offset = 0
    # 1:total_energy_export | Offset: 0, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    total_energy_export = total_energy_export_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('total_energy_export', 'Total Energy Export', None, 'kWh', total_energy_export, total_energy_export_raw, PhysicalQuantities.ELECTRICAL_ENERGY, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:total_energy_import | Offset: 32, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    total_energy_import = total_energy_import_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('total_energy_import', 'Total Energy Import', None, 'kWh', total_energy_import, total_energy_import_raw, PhysicalQuantities.ELECTRICAL_ENERGY, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_65005(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65005."""
    data_raw = 0
    # total_energy_export | Offset: 0, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'total_energy_export')
    if field is None:
        raise Exception("Cant encode this message, missing 'Total Energy Export'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # total_energy_import | Offset: 32, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'total_energy_import')
    if field is None:
        raise Exception("Cant encode this message, missing 'Total Energy Import'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw


def is_fast_pgn_65006() -> bool:
    """Return True if PGN 65006 is a fast PGN."""
    return False
def decode_pgn_65006(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65006."""
    nmea2000Message = NMEA2000Message(65006, 'utilityPhaseCAcReactivePower', 'Utility Phase C AC Reactive Power')
    running_bit_offset = 0
    # 1:reactive_power | Offset: 0, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    reactive_power = reactive_power_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('reactive_power', 'Reactive Power', None, 'VAR', reactive_power, reactive_power_raw, PhysicalQuantities.ELECTRICAL_REACTIVE_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:power_factor | Offset: 16, Length: 16, Signed: False Resolution: 6.10352e-05, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    power_factor = power_factor_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 6.10352e-05)
    nmea2000Message.fields.append(NMEA2000Field('power_factor', 'Power factor', None, 'Cos Phi', power_factor, power_factor_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:power_factor_lagging | Offset: 32, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    power_factor_lagging_raw = decode_int(_data_raw_, running_bit_offset, 2)
    power_factor_lagging = master_dict['POWER_FACTOR'].get(power_factor_lagging_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('power_factor_lagging', 'Power Factor Lagging', None, None, power_factor_lagging, power_factor_lagging_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:reserved_34 | Offset: 34, Length: 30, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 34
    reserved_34 = reserved_34_raw = decode_int(_data_raw_, running_bit_offset, 30)
    nmea2000Message.fields.append(NMEA2000Field('reserved_34', 'Reserved', None, None, reserved_34, reserved_34_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 30

    return nmea2000Message

def encode_pgn_65006(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65006."""
    data_raw = 0
    # reactive_power | Offset: 0, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'reactive_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reactive Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 0
    # power_factor | Offset: 16, Length: 16, Resolution: 6.10352e-05, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'power_factor')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power factor'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 6.10352e-05) & 0xFFFF) << 16
    
    # power_factor_lagging | Offset: 32, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'power_factor_lagging')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power Factor Lagging'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_POWER_FACTOR(field.value)
    data_raw |= (field_value & 0x3) << 32
    # reserved_34 | Offset: 34, Length: 30, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_34')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3FFFFFFF) << 34
    return data_raw


def is_fast_pgn_65007() -> bool:
    """Return True if PGN 65007 is a fast PGN."""
    return False
def decode_pgn_65007(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65007."""
    nmea2000Message = NMEA2000Message(65007, 'utilityPhaseCAcPower', 'Utility Phase C AC Power')
    running_bit_offset = 0
    # 1:real_power | Offset: 0, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    real_power = real_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('real_power', 'Real Power', None, 'W', real_power, real_power_raw, PhysicalQuantities.ELECTRICAL_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:apparent_power | Offset: 32, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    apparent_power = apparent_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('apparent_power', 'Apparent Power', None, 'VA', apparent_power, apparent_power_raw, PhysicalQuantities.ELECTRICAL_APPARENT_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_65007(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65007."""
    data_raw = 0
    # real_power | Offset: 0, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'real_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Real Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # apparent_power | Offset: 32, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'apparent_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Apparent Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw


def is_fast_pgn_65008() -> bool:
    """Return True if PGN 65008 is a fast PGN."""
    return False
def decode_pgn_65008(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65008."""
    nmea2000Message = NMEA2000Message(65008, 'utilityPhaseCBasicAcQuantities', 'Utility Phase C Basic AC Quantities')
    running_bit_offset = 0
    # 1:line_line_ac_rms_voltage | Offset: 0, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    line_line_ac_rms_voltage = line_line_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_line_ac_rms_voltage', 'Line-Line AC RMS Voltage', None, 'V', line_line_ac_rms_voltage, line_line_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    line_neutral_ac_rms_voltage = line_neutral_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_neutral_ac_rms_voltage', 'Line-Neutral AC RMS Voltage', None, 'V', line_neutral_ac_rms_voltage, line_neutral_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:ac_frequency | Offset: 32, Length: 16, Signed: False Resolution: 0.0078125, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    ac_frequency = ac_frequency_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0078125)
    nmea2000Message.fields.append(NMEA2000Field('ac_frequency', 'AC Frequency', None, 'Hz', ac_frequency, ac_frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:ac_rms_current | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    ac_rms_current = ac_rms_current_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('ac_rms_current', 'AC RMS Current', None, 'A', ac_rms_current, ac_rms_current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_65008(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65008."""
    data_raw = 0
    # line_line_ac_rms_voltage | Offset: 0, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_line_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Line AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 0
    # line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_neutral_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Neutral AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # ac_frequency | Offset: 32, Length: 16, Resolution: 0.0078125, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC Frequency'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0078125) & 0xFFFF) << 32
    
    # ac_rms_current | Offset: 48, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_rms_current')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC RMS Current'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_65009() -> bool:
    """Return True if PGN 65009 is a fast PGN."""
    return False
def decode_pgn_65009(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65009."""
    nmea2000Message = NMEA2000Message(65009, 'utilityPhaseBAcReactivePower', 'Utility Phase B AC Reactive Power')
    running_bit_offset = 0
    # 1:reactive_power | Offset: 0, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    reactive_power = reactive_power_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('reactive_power', 'Reactive Power', None, 'VAR', reactive_power, reactive_power_raw, PhysicalQuantities.ELECTRICAL_REACTIVE_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:power_factor | Offset: 16, Length: 16, Signed: False Resolution: 6.10352e-05, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    power_factor = power_factor_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 6.10352e-05)
    nmea2000Message.fields.append(NMEA2000Field('power_factor', 'Power factor', None, 'Cos Phi', power_factor, power_factor_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:power_factor_lagging | Offset: 32, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    power_factor_lagging_raw = decode_int(_data_raw_, running_bit_offset, 2)
    power_factor_lagging = master_dict['POWER_FACTOR'].get(power_factor_lagging_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('power_factor_lagging', 'Power Factor Lagging', None, None, power_factor_lagging, power_factor_lagging_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:reserved_34 | Offset: 34, Length: 30, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 34
    reserved_34 = reserved_34_raw = decode_int(_data_raw_, running_bit_offset, 30)
    nmea2000Message.fields.append(NMEA2000Field('reserved_34', 'Reserved', None, None, reserved_34, reserved_34_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 30

    return nmea2000Message

def encode_pgn_65009(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65009."""
    data_raw = 0
    # reactive_power | Offset: 0, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'reactive_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reactive Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 0
    # power_factor | Offset: 16, Length: 16, Resolution: 6.10352e-05, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'power_factor')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power factor'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 6.10352e-05) & 0xFFFF) << 16
    
    # power_factor_lagging | Offset: 32, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'power_factor_lagging')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power Factor Lagging'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_POWER_FACTOR(field.value)
    data_raw |= (field_value & 0x3) << 32
    # reserved_34 | Offset: 34, Length: 30, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_34')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3FFFFFFF) << 34
    return data_raw


def is_fast_pgn_65010() -> bool:
    """Return True if PGN 65010 is a fast PGN."""
    return False
def decode_pgn_65010(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65010."""
    nmea2000Message = NMEA2000Message(65010, 'utilityPhaseBAcPower', 'Utility Phase B AC Power')
    running_bit_offset = 0
    # 1:real_power | Offset: 0, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    real_power = real_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('real_power', 'Real Power', None, 'W', real_power, real_power_raw, PhysicalQuantities.ELECTRICAL_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:apparent_power | Offset: 32, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    apparent_power = apparent_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('apparent_power', 'Apparent Power', None, 'VA', apparent_power, apparent_power_raw, PhysicalQuantities.ELECTRICAL_APPARENT_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_65010(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65010."""
    data_raw = 0
    # real_power | Offset: 0, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'real_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Real Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # apparent_power | Offset: 32, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'apparent_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Apparent Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw


def is_fast_pgn_65011() -> bool:
    """Return True if PGN 65011 is a fast PGN."""
    return False
def decode_pgn_65011(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65011."""
    nmea2000Message = NMEA2000Message(65011, 'utilityPhaseBBasicAcQuantities', 'Utility Phase B Basic AC Quantities')
    running_bit_offset = 0
    # 1:line_line_ac_rms_voltage | Offset: 0, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    line_line_ac_rms_voltage = line_line_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_line_ac_rms_voltage', 'Line-Line AC RMS Voltage', None, 'V', line_line_ac_rms_voltage, line_line_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    line_neutral_ac_rms_voltage = line_neutral_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_neutral_ac_rms_voltage', 'Line-Neutral AC RMS Voltage', None, 'V', line_neutral_ac_rms_voltage, line_neutral_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:ac_frequency | Offset: 32, Length: 16, Signed: False Resolution: 0.0078125, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    ac_frequency = ac_frequency_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0078125)
    nmea2000Message.fields.append(NMEA2000Field('ac_frequency', 'AC Frequency', None, 'Hz', ac_frequency, ac_frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:ac_rms_current | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    ac_rms_current = ac_rms_current_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('ac_rms_current', 'AC RMS Current', None, 'A', ac_rms_current, ac_rms_current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_65011(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65011."""
    data_raw = 0
    # line_line_ac_rms_voltage | Offset: 0, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_line_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Line AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 0
    # line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_neutral_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Neutral AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # ac_frequency | Offset: 32, Length: 16, Resolution: 0.0078125, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC Frequency'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0078125) & 0xFFFF) << 32
    
    # ac_rms_current | Offset: 48, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_rms_current')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC RMS Current'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_65012() -> bool:
    """Return True if PGN 65012 is a fast PGN."""
    return False
def decode_pgn_65012(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65012."""
    nmea2000Message = NMEA2000Message(65012, 'utilityPhaseAAcReactivePower', 'Utility Phase A AC Reactive Power')
    running_bit_offset = 0
    # 1:reactive_power | Offset: 0, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    reactive_power = reactive_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('reactive_power', 'Reactive Power', None, 'VAR', reactive_power, reactive_power_raw, PhysicalQuantities.ELECTRICAL_REACTIVE_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:power_factor | Offset: 32, Length: 16, Signed: False Resolution: 6.10352e-05, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    power_factor = power_factor_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 6.10352e-05)
    nmea2000Message.fields.append(NMEA2000Field('power_factor', 'Power factor', None, 'Cos Phi', power_factor, power_factor_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:power_factor_lagging | Offset: 48, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    power_factor_lagging_raw = decode_int(_data_raw_, running_bit_offset, 2)
    power_factor_lagging = master_dict['POWER_FACTOR'].get(power_factor_lagging_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('power_factor_lagging', 'Power Factor Lagging', None, None, power_factor_lagging, power_factor_lagging_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:reserved_50 | Offset: 50, Length: 14, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 50
    reserved_50 = reserved_50_raw = decode_int(_data_raw_, running_bit_offset, 14)
    nmea2000Message.fields.append(NMEA2000Field('reserved_50', 'Reserved', None, None, reserved_50, reserved_50_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 14

    return nmea2000Message

def encode_pgn_65012(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65012."""
    data_raw = 0
    # reactive_power | Offset: 0, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'reactive_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reactive Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # power_factor | Offset: 32, Length: 16, Resolution: 6.10352e-05, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'power_factor')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power factor'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 6.10352e-05) & 0xFFFF) << 32
    
    # power_factor_lagging | Offset: 48, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'power_factor_lagging')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power Factor Lagging'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_POWER_FACTOR(field.value)
    data_raw |= (field_value & 0x3) << 48
    # reserved_50 | Offset: 50, Length: 14, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_50')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3FFF) << 50
    return data_raw


def is_fast_pgn_65013() -> bool:
    """Return True if PGN 65013 is a fast PGN."""
    return False
def decode_pgn_65013(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65013."""
    nmea2000Message = NMEA2000Message(65013, 'utilityPhaseAAcPower', 'Utility Phase A AC Power')
    running_bit_offset = 0
    # 1:real_power | Offset: 0, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    real_power = real_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('real_power', 'Real Power', None, 'W', real_power, real_power_raw, PhysicalQuantities.ELECTRICAL_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:apparent_power | Offset: 32, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    apparent_power = apparent_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('apparent_power', 'Apparent Power', None, 'VA', apparent_power, apparent_power_raw, PhysicalQuantities.ELECTRICAL_APPARENT_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_65013(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65013."""
    data_raw = 0
    # real_power | Offset: 0, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'real_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Real Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # apparent_power | Offset: 32, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'apparent_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Apparent Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw


def is_fast_pgn_65014() -> bool:
    """Return True if PGN 65014 is a fast PGN."""
    return False
def decode_pgn_65014(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65014."""
    nmea2000Message = NMEA2000Message(65014, 'utilityPhaseABasicAcQuantities', 'Utility Phase A Basic AC Quantities')
    running_bit_offset = 0
    # 1:line_line_ac_rms_voltage | Offset: 0, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    line_line_ac_rms_voltage = line_line_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_line_ac_rms_voltage', 'Line-Line AC RMS Voltage', None, 'V', line_line_ac_rms_voltage, line_line_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    line_neutral_ac_rms_voltage = line_neutral_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_neutral_ac_rms_voltage', 'Line-Neutral AC RMS Voltage', None, 'V', line_neutral_ac_rms_voltage, line_neutral_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:ac_frequency | Offset: 32, Length: 16, Signed: False Resolution: 0.0078125, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    ac_frequency = ac_frequency_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0078125)
    nmea2000Message.fields.append(NMEA2000Field('ac_frequency', 'AC Frequency', None, 'Hz', ac_frequency, ac_frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:ac_rms_current | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    ac_rms_current = ac_rms_current_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('ac_rms_current', 'AC RMS Current', None, 'A', ac_rms_current, ac_rms_current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_65014(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65014."""
    data_raw = 0
    # line_line_ac_rms_voltage | Offset: 0, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_line_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Line AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 0
    # line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_neutral_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Neutral AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # ac_frequency | Offset: 32, Length: 16, Resolution: 0.0078125, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC Frequency'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0078125) & 0xFFFF) << 32
    
    # ac_rms_current | Offset: 48, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_rms_current')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC RMS Current'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_65015() -> bool:
    """Return True if PGN 65015 is a fast PGN."""
    return False
def decode_pgn_65015(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65015."""
    nmea2000Message = NMEA2000Message(65015, 'utilityTotalAcReactivePower', 'Utility Total AC Reactive Power')
    running_bit_offset = 0
    # 1:reactive_power | Offset: 0, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    reactive_power = reactive_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('reactive_power', 'Reactive Power', None, 'VAR', reactive_power, reactive_power_raw, PhysicalQuantities.ELECTRICAL_REACTIVE_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:power_factor | Offset: 32, Length: 16, Signed: False Resolution: 6.10352e-05, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    power_factor = power_factor_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 6.10352e-05)
    nmea2000Message.fields.append(NMEA2000Field('power_factor', 'Power factor', None, 'Cos Phi', power_factor, power_factor_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:power_factor_lagging | Offset: 48, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    power_factor_lagging_raw = decode_int(_data_raw_, running_bit_offset, 2)
    power_factor_lagging = master_dict['POWER_FACTOR'].get(power_factor_lagging_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('power_factor_lagging', 'Power Factor Lagging', None, None, power_factor_lagging, power_factor_lagging_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:reserved_50 | Offset: 50, Length: 14, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 50
    reserved_50 = reserved_50_raw = decode_int(_data_raw_, running_bit_offset, 14)
    nmea2000Message.fields.append(NMEA2000Field('reserved_50', 'Reserved', None, None, reserved_50, reserved_50_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 14

    return nmea2000Message

def encode_pgn_65015(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65015."""
    data_raw = 0
    # reactive_power | Offset: 0, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'reactive_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reactive Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # power_factor | Offset: 32, Length: 16, Resolution: 6.10352e-05, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'power_factor')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power factor'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 6.10352e-05) & 0xFFFF) << 32
    
    # power_factor_lagging | Offset: 48, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'power_factor_lagging')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power Factor Lagging'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_POWER_FACTOR(field.value)
    data_raw |= (field_value & 0x3) << 48
    # reserved_50 | Offset: 50, Length: 14, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_50')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3FFF) << 50
    return data_raw


def is_fast_pgn_65016() -> bool:
    """Return True if PGN 65016 is a fast PGN."""
    return False
def decode_pgn_65016(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65016."""
    nmea2000Message = NMEA2000Message(65016, 'utilityTotalAcPower', 'Utility Total AC Power')
    running_bit_offset = 0
    # 1:real_power | Offset: 0, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    real_power = real_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('real_power', 'Real Power', None, 'W', real_power, real_power_raw, PhysicalQuantities.ELECTRICAL_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:apparent_power | Offset: 32, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    apparent_power = apparent_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('apparent_power', 'Apparent Power', None, 'VA', apparent_power, apparent_power_raw, PhysicalQuantities.ELECTRICAL_APPARENT_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_65016(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65016."""
    data_raw = 0
    # real_power | Offset: 0, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'real_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Real Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # apparent_power | Offset: 32, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'apparent_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Apparent Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw


def is_fast_pgn_65017() -> bool:
    """Return True if PGN 65017 is a fast PGN."""
    return False
def decode_pgn_65017(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65017."""
    nmea2000Message = NMEA2000Message(65017, 'utilityAverageBasicAcQuantities', 'Utility Average Basic AC Quantities')
    running_bit_offset = 0
    # 1:line_line_ac_rms_voltage | Offset: 0, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    line_line_ac_rms_voltage = line_line_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_line_ac_rms_voltage', 'Line-Line AC RMS Voltage', None, 'V', line_line_ac_rms_voltage, line_line_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    line_neutral_ac_rms_voltage = line_neutral_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_neutral_ac_rms_voltage', 'Line-Neutral AC RMS Voltage', None, 'V', line_neutral_ac_rms_voltage, line_neutral_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:ac_frequency | Offset: 32, Length: 16, Signed: False Resolution: 0.0078125, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    ac_frequency = ac_frequency_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0078125)
    nmea2000Message.fields.append(NMEA2000Field('ac_frequency', 'AC Frequency', None, 'Hz', ac_frequency, ac_frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:ac_rms_current | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    ac_rms_current = ac_rms_current_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('ac_rms_current', 'AC RMS Current', None, 'A', ac_rms_current, ac_rms_current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_65017(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65017."""
    data_raw = 0
    # line_line_ac_rms_voltage | Offset: 0, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_line_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Line AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 0
    # line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_neutral_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Neutral AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # ac_frequency | Offset: 32, Length: 16, Resolution: 0.0078125, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC Frequency'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0078125) & 0xFFFF) << 32
    
    # ac_rms_current | Offset: 48, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_rms_current')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC RMS Current'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_65018() -> bool:
    """Return True if PGN 65018 is a fast PGN."""
    return False
def decode_pgn_65018(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65018."""
    nmea2000Message = NMEA2000Message(65018, 'generatorTotalAcEnergy', 'Generator Total AC Energy')
    running_bit_offset = 0
    # 1:total_energy_export | Offset: 0, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    total_energy_export = total_energy_export_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('total_energy_export', 'Total Energy Export', None, 'kWh', total_energy_export, total_energy_export_raw, PhysicalQuantities.ELECTRICAL_ENERGY, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:total_energy_import | Offset: 32, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    total_energy_import = total_energy_import_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('total_energy_import', 'Total Energy Import', None, 'kWh', total_energy_import, total_energy_import_raw, PhysicalQuantities.ELECTRICAL_ENERGY, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_65018(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65018."""
    data_raw = 0
    # total_energy_export | Offset: 0, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'total_energy_export')
    if field is None:
        raise Exception("Cant encode this message, missing 'Total Energy Export'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # total_energy_import | Offset: 32, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'total_energy_import')
    if field is None:
        raise Exception("Cant encode this message, missing 'Total Energy Import'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw


def is_fast_pgn_65019() -> bool:
    """Return True if PGN 65019 is a fast PGN."""
    return False
def decode_pgn_65019(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65019."""
    nmea2000Message = NMEA2000Message(65019, 'generatorPhaseCAcReactivePower', 'Generator Phase C AC Reactive Power')
    running_bit_offset = 0
    # 1:reactive_power | Offset: 0, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    reactive_power = reactive_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('reactive_power', 'Reactive Power', None, 'VAR', reactive_power, reactive_power_raw, PhysicalQuantities.ELECTRICAL_REACTIVE_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:power_factor | Offset: 32, Length: 16, Signed: False Resolution: 6.10352e-05, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    power_factor = power_factor_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 6.10352e-05)
    nmea2000Message.fields.append(NMEA2000Field('power_factor', 'Power factor', None, 'Cos Phi', power_factor, power_factor_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:power_factor_lagging | Offset: 48, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    power_factor_lagging_raw = decode_int(_data_raw_, running_bit_offset, 2)
    power_factor_lagging = master_dict['POWER_FACTOR'].get(power_factor_lagging_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('power_factor_lagging', 'Power Factor Lagging', None, None, power_factor_lagging, power_factor_lagging_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:reserved_50 | Offset: 50, Length: 14, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 50
    reserved_50 = reserved_50_raw = decode_int(_data_raw_, running_bit_offset, 14)
    nmea2000Message.fields.append(NMEA2000Field('reserved_50', 'Reserved', None, None, reserved_50, reserved_50_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 14

    return nmea2000Message

def encode_pgn_65019(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65019."""
    data_raw = 0
    # reactive_power | Offset: 0, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'reactive_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reactive Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # power_factor | Offset: 32, Length: 16, Resolution: 6.10352e-05, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'power_factor')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power factor'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 6.10352e-05) & 0xFFFF) << 32
    
    # power_factor_lagging | Offset: 48, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'power_factor_lagging')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power Factor Lagging'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_POWER_FACTOR(field.value)
    data_raw |= (field_value & 0x3) << 48
    # reserved_50 | Offset: 50, Length: 14, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_50')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3FFF) << 50
    return data_raw


def is_fast_pgn_65020() -> bool:
    """Return True if PGN 65020 is a fast PGN."""
    return False
def decode_pgn_65020(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65020."""
    nmea2000Message = NMEA2000Message(65020, 'generatorPhaseCAcPower', 'Generator Phase C AC Power')
    running_bit_offset = 0
    # 1:real_power | Offset: 0, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    real_power = real_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('real_power', 'Real Power', None, 'W', real_power, real_power_raw, PhysicalQuantities.ELECTRICAL_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:apparent_power | Offset: 32, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    apparent_power = apparent_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('apparent_power', 'Apparent Power', None, 'VAR', apparent_power, apparent_power_raw, PhysicalQuantities.ELECTRICAL_REACTIVE_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_65020(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65020."""
    data_raw = 0
    # real_power | Offset: 0, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'real_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Real Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # apparent_power | Offset: 32, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'apparent_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Apparent Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw


def is_fast_pgn_65021() -> bool:
    """Return True if PGN 65021 is a fast PGN."""
    return False
def decode_pgn_65021(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65021."""
    nmea2000Message = NMEA2000Message(65021, 'generatorPhaseCBasicAcQuantities', 'Generator Phase C Basic AC Quantities')
    running_bit_offset = 0
    # 1:line_line_ac_rms_voltage | Offset: 0, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    line_line_ac_rms_voltage = line_line_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_line_ac_rms_voltage', 'Line-Line AC RMS Voltage', None, 'V', line_line_ac_rms_voltage, line_line_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    line_neutral_ac_rms_voltage = line_neutral_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_neutral_ac_rms_voltage', 'Line-Neutral AC RMS Voltage', None, 'V', line_neutral_ac_rms_voltage, line_neutral_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:ac_frequency | Offset: 32, Length: 16, Signed: False Resolution: 0.0078125, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    ac_frequency = ac_frequency_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0078125)
    nmea2000Message.fields.append(NMEA2000Field('ac_frequency', 'AC Frequency', None, 'Hz', ac_frequency, ac_frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:ac_rms_current | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    ac_rms_current = ac_rms_current_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('ac_rms_current', 'AC RMS Current', None, 'A', ac_rms_current, ac_rms_current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_65021(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65021."""
    data_raw = 0
    # line_line_ac_rms_voltage | Offset: 0, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_line_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Line AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 0
    # line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_neutral_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Neutral AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # ac_frequency | Offset: 32, Length: 16, Resolution: 0.0078125, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC Frequency'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0078125) & 0xFFFF) << 32
    
    # ac_rms_current | Offset: 48, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_rms_current')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC RMS Current'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_65022() -> bool:
    """Return True if PGN 65022 is a fast PGN."""
    return False
def decode_pgn_65022(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65022."""
    nmea2000Message = NMEA2000Message(65022, 'generatorPhaseBAcReactivePower', 'Generator Phase B AC Reactive Power')
    running_bit_offset = 0
    # 1:reactive_power | Offset: 0, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    reactive_power = reactive_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('reactive_power', 'Reactive Power', None, 'VAR', reactive_power, reactive_power_raw, PhysicalQuantities.ELECTRICAL_REACTIVE_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:power_factor | Offset: 32, Length: 16, Signed: False Resolution: 6.10352e-05, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    power_factor = power_factor_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 6.10352e-05)
    nmea2000Message.fields.append(NMEA2000Field('power_factor', 'Power factor', None, 'Cos Phi', power_factor, power_factor_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:power_factor_lagging | Offset: 48, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    power_factor_lagging_raw = decode_int(_data_raw_, running_bit_offset, 2)
    power_factor_lagging = master_dict['POWER_FACTOR'].get(power_factor_lagging_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('power_factor_lagging', 'Power Factor Lagging', None, None, power_factor_lagging, power_factor_lagging_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:reserved_50 | Offset: 50, Length: 14, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 50
    reserved_50 = reserved_50_raw = decode_int(_data_raw_, running_bit_offset, 14)
    nmea2000Message.fields.append(NMEA2000Field('reserved_50', 'Reserved', None, None, reserved_50, reserved_50_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 14

    return nmea2000Message

def encode_pgn_65022(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65022."""
    data_raw = 0
    # reactive_power | Offset: 0, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'reactive_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reactive Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # power_factor | Offset: 32, Length: 16, Resolution: 6.10352e-05, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'power_factor')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power factor'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 6.10352e-05) & 0xFFFF) << 32
    
    # power_factor_lagging | Offset: 48, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'power_factor_lagging')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power Factor Lagging'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_POWER_FACTOR(field.value)
    data_raw |= (field_value & 0x3) << 48
    # reserved_50 | Offset: 50, Length: 14, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_50')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3FFF) << 50
    return data_raw


def is_fast_pgn_65023() -> bool:
    """Return True if PGN 65023 is a fast PGN."""
    return False
def decode_pgn_65023(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65023."""
    nmea2000Message = NMEA2000Message(65023, 'generatorPhaseBAcPower', 'Generator Phase B AC Power')
    running_bit_offset = 0
    # 1:real_power | Offset: 0, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    real_power = real_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('real_power', 'Real Power', None, 'W', real_power, real_power_raw, PhysicalQuantities.ELECTRICAL_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:apparent_power | Offset: 32, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    apparent_power = apparent_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('apparent_power', 'Apparent Power', None, 'VA', apparent_power, apparent_power_raw, PhysicalQuantities.ELECTRICAL_APPARENT_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_65023(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65023."""
    data_raw = 0
    # real_power | Offset: 0, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'real_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Real Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # apparent_power | Offset: 32, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'apparent_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Apparent Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw


def is_fast_pgn_65024() -> bool:
    """Return True if PGN 65024 is a fast PGN."""
    return False
def decode_pgn_65024(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65024."""
    nmea2000Message = NMEA2000Message(65024, 'generatorPhaseBBasicAcQuantities', 'Generator Phase B Basic AC Quantities')
    running_bit_offset = 0
    # 1:line_line_ac_rms_voltage | Offset: 0, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    line_line_ac_rms_voltage = line_line_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_line_ac_rms_voltage', 'Line-Line AC RMS Voltage', None, 'V', line_line_ac_rms_voltage, line_line_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    line_neutral_ac_rms_voltage = line_neutral_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_neutral_ac_rms_voltage', 'Line-Neutral AC RMS Voltage', None, 'V', line_neutral_ac_rms_voltage, line_neutral_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:ac_frequency | Offset: 32, Length: 16, Signed: False Resolution: 0.0078125, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    ac_frequency = ac_frequency_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0078125)
    nmea2000Message.fields.append(NMEA2000Field('ac_frequency', 'AC Frequency', None, 'Hz', ac_frequency, ac_frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:ac_rms_current | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    ac_rms_current = ac_rms_current_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('ac_rms_current', 'AC RMS Current', None, 'A', ac_rms_current, ac_rms_current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_65024(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65024."""
    data_raw = 0
    # line_line_ac_rms_voltage | Offset: 0, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_line_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Line AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 0
    # line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_neutral_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Neutral AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # ac_frequency | Offset: 32, Length: 16, Resolution: 0.0078125, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC Frequency'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0078125) & 0xFFFF) << 32
    
    # ac_rms_current | Offset: 48, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_rms_current')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC RMS Current'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_65025() -> bool:
    """Return True if PGN 65025 is a fast PGN."""
    return False
def decode_pgn_65025(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65025."""
    nmea2000Message = NMEA2000Message(65025, 'generatorPhaseAAcReactivePower', 'Generator Phase A AC Reactive Power')
    running_bit_offset = 0
    # 1:reactive_power | Offset: 0, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    reactive_power = reactive_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('reactive_power', 'Reactive Power', None, 'VAR', reactive_power, reactive_power_raw, PhysicalQuantities.ELECTRICAL_REACTIVE_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:power_factor | Offset: 32, Length: 16, Signed: False Resolution: 6.10352e-05, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    power_factor = power_factor_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 6.10352e-05)
    nmea2000Message.fields.append(NMEA2000Field('power_factor', 'Power factor', None, 'Cos Phi', power_factor, power_factor_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:power_factor_lagging | Offset: 48, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    power_factor_lagging_raw = decode_int(_data_raw_, running_bit_offset, 2)
    power_factor_lagging = master_dict['POWER_FACTOR'].get(power_factor_lagging_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('power_factor_lagging', 'Power Factor Lagging', None, None, power_factor_lagging, power_factor_lagging_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:reserved_50 | Offset: 50, Length: 14, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 50
    reserved_50 = reserved_50_raw = decode_int(_data_raw_, running_bit_offset, 14)
    nmea2000Message.fields.append(NMEA2000Field('reserved_50', 'Reserved', None, None, reserved_50, reserved_50_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 14

    return nmea2000Message

def encode_pgn_65025(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65025."""
    data_raw = 0
    # reactive_power | Offset: 0, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'reactive_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reactive Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # power_factor | Offset: 32, Length: 16, Resolution: 6.10352e-05, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'power_factor')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power factor'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 6.10352e-05) & 0xFFFF) << 32
    
    # power_factor_lagging | Offset: 48, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'power_factor_lagging')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power Factor Lagging'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_POWER_FACTOR(field.value)
    data_raw |= (field_value & 0x3) << 48
    # reserved_50 | Offset: 50, Length: 14, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_50')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3FFF) << 50
    return data_raw


def is_fast_pgn_65026() -> bool:
    """Return True if PGN 65026 is a fast PGN."""
    return False
def decode_pgn_65026(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65026."""
    nmea2000Message = NMEA2000Message(65026, 'generatorPhaseAAcPower', 'Generator Phase A AC Power')
    running_bit_offset = 0
    # 1:real_power | Offset: 0, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    real_power = real_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('real_power', 'Real Power', None, 'W', real_power, real_power_raw, PhysicalQuantities.ELECTRICAL_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:apparent_power | Offset: 32, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    apparent_power = apparent_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('apparent_power', 'Apparent Power', None, 'VA', apparent_power, apparent_power_raw, PhysicalQuantities.ELECTRICAL_APPARENT_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_65026(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65026."""
    data_raw = 0
    # real_power | Offset: 0, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'real_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Real Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # apparent_power | Offset: 32, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'apparent_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Apparent Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw


def is_fast_pgn_65027() -> bool:
    """Return True if PGN 65027 is a fast PGN."""
    return False
def decode_pgn_65027(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65027."""
    nmea2000Message = NMEA2000Message(65027, 'generatorPhaseABasicAcQuantities', 'Generator Phase A Basic AC Quantities')
    running_bit_offset = 0
    # 1:line_line_ac_rms_voltage | Offset: 0, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    line_line_ac_rms_voltage = line_line_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_line_ac_rms_voltage', 'Line-Line AC RMS Voltage', None, 'V', line_line_ac_rms_voltage, line_line_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    line_neutral_ac_rms_voltage = line_neutral_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_neutral_ac_rms_voltage', 'Line-Neutral AC RMS Voltage', None, 'V', line_neutral_ac_rms_voltage, line_neutral_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:ac_frequency | Offset: 32, Length: 16, Signed: False Resolution: 0.0078125, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    ac_frequency = ac_frequency_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0078125)
    nmea2000Message.fields.append(NMEA2000Field('ac_frequency', 'AC Frequency', None, 'Hz', ac_frequency, ac_frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:ac_rms_current | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    ac_rms_current = ac_rms_current_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('ac_rms_current', 'AC RMS Current', None, 'A', ac_rms_current, ac_rms_current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_65027(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65027."""
    data_raw = 0
    # line_line_ac_rms_voltage | Offset: 0, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_line_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Line AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 0
    # line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_neutral_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Neutral AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # ac_frequency | Offset: 32, Length: 16, Resolution: 0.0078125, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC Frequency'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0078125) & 0xFFFF) << 32
    
    # ac_rms_current | Offset: 48, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_rms_current')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC RMS Current'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_65028() -> bool:
    """Return True if PGN 65028 is a fast PGN."""
    return False
def decode_pgn_65028(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65028."""
    nmea2000Message = NMEA2000Message(65028, 'generatorTotalAcReactivePower', 'Generator Total AC Reactive Power')
    running_bit_offset = 0
    # 1:reactive_power | Offset: 0, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    reactive_power = reactive_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('reactive_power', 'Reactive Power', None, 'VAR', reactive_power, reactive_power_raw, PhysicalQuantities.ELECTRICAL_REACTIVE_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:power_factor | Offset: 32, Length: 16, Signed: False Resolution: 6.10352e-05, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    power_factor = power_factor_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 6.10352e-05)
    nmea2000Message.fields.append(NMEA2000Field('power_factor', 'Power factor', None, 'Cos Phi', power_factor, power_factor_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:power_factor_lagging | Offset: 48, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    power_factor_lagging_raw = decode_int(_data_raw_, running_bit_offset, 2)
    power_factor_lagging = master_dict['POWER_FACTOR'].get(power_factor_lagging_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('power_factor_lagging', 'Power Factor Lagging', None, None, power_factor_lagging, power_factor_lagging_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:reserved_50 | Offset: 50, Length: 14, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 50
    reserved_50 = reserved_50_raw = decode_int(_data_raw_, running_bit_offset, 14)
    nmea2000Message.fields.append(NMEA2000Field('reserved_50', 'Reserved', None, None, reserved_50, reserved_50_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 14

    return nmea2000Message

def encode_pgn_65028(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65028."""
    data_raw = 0
    # reactive_power | Offset: 0, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'reactive_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reactive Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # power_factor | Offset: 32, Length: 16, Resolution: 6.10352e-05, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'power_factor')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power factor'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 6.10352e-05) & 0xFFFF) << 32
    
    # power_factor_lagging | Offset: 48, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'power_factor_lagging')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power Factor Lagging'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_POWER_FACTOR(field.value)
    data_raw |= (field_value & 0x3) << 48
    # reserved_50 | Offset: 50, Length: 14, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_50')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3FFF) << 50
    return data_raw


def is_fast_pgn_65029() -> bool:
    """Return True if PGN 65029 is a fast PGN."""
    return False
def decode_pgn_65029(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65029."""
    nmea2000Message = NMEA2000Message(65029, 'generatorTotalAcPower', 'Generator Total AC Power')
    running_bit_offset = 0
    # 1:real_power | Offset: 0, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    real_power = real_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('real_power', 'Real Power', None, 'W', real_power, real_power_raw, PhysicalQuantities.ELECTRICAL_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:apparent_power | Offset: 32, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    apparent_power = apparent_power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('apparent_power', 'Apparent Power', None, 'VA', apparent_power, apparent_power_raw, PhysicalQuantities.ELECTRICAL_APPARENT_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_65029(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65029."""
    data_raw = 0
    # real_power | Offset: 0, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'real_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Real Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # apparent_power | Offset: 32, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'apparent_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Apparent Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw


def is_fast_pgn_65030() -> bool:
    """Return True if PGN 65030 is a fast PGN."""
    return False
def decode_pgn_65030(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65030."""
    nmea2000Message = NMEA2000Message(65030, 'generatorAverageBasicAcQuantities', 'Generator Average Basic AC Quantities')
    running_bit_offset = 0
    # 1:line_line_ac_rms_voltage | Offset: 0, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    line_line_ac_rms_voltage = line_line_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_line_ac_rms_voltage', 'Line-Line AC RMS Voltage', None, 'V', line_line_ac_rms_voltage, line_line_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    line_neutral_ac_rms_voltage = line_neutral_ac_rms_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line_neutral_ac_rms_voltage', 'Line-Neutral AC RMS Voltage', None, 'V', line_neutral_ac_rms_voltage, line_neutral_ac_rms_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:ac_frequency | Offset: 32, Length: 16, Signed: False Resolution: 0.0078125, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    ac_frequency = ac_frequency_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0078125)
    nmea2000Message.fields.append(NMEA2000Field('ac_frequency', 'AC Frequency', None, 'Hz', ac_frequency, ac_frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:ac_rms_current | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    ac_rms_current = ac_rms_current_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('ac_rms_current', 'AC RMS Current', None, 'A', ac_rms_current, ac_rms_current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_65030(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65030."""
    data_raw = 0
    # line_line_ac_rms_voltage | Offset: 0, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_line_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Line AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 0
    # line_neutral_ac_rms_voltage | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line_neutral_ac_rms_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line-Neutral AC RMS Voltage'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # ac_frequency | Offset: 32, Length: 16, Resolution: 0.0078125, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC Frequency'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0078125) & 0xFFFF) << 32
    
    # ac_rms_current | Offset: 48, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_rms_current')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC RMS Current'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_65240() -> bool:
    """Return True if PGN 65240 is a fast PGN."""
    raise Exception('PGEN type ISO not supported')

def decode_pgn_65240(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65240."""
    nmea2000Message = NMEA2000Message(65240, 'isoCommandedAddress', 'ISO Commanded Address')
    running_bit_offset = 0
    # 1:unique_number | Offset: 0, Length: 21, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    unique_number = unique_number_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 21))
    nmea2000Message.fields.append(NMEA2000Field('unique_number', 'Unique Number', "ISO Identity Number", None, unique_number, unique_number_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 21

    # 2:manufacturer_code | Offset: 21, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 21
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', None, 'Manufacturer Code', manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 3:device_instance_lower | Offset: 32, Length: 3, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 32
    device_instance_lower = device_instance_lower_raw = decode_number(_data_raw_, running_bit_offset, 3, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('device_instance_lower', 'Device Instance Lower', "ISO ECU Instance", None, device_instance_lower, device_instance_lower_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 3

    # 4:device_instance_upper | Offset: 35, Length: 5, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 35
    device_instance_upper = device_instance_upper_raw = decode_number(_data_raw_, running_bit_offset, 5, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('device_instance_upper', 'Device Instance Upper', "ISO Function Instance", None, device_instance_upper, device_instance_upper_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 5

    # 5:device_function | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: INDIRECT_LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    device_function_raw = decode_int(_data_raw_, running_bit_offset, 8)
    device_function = 'TEMP_VAL'
    nmea2000Message.fields.append(NMEA2000Field('device_function', 'Device Function', "ISO Function", None, device_function, device_function_raw, None, FieldTypes.INDIRECT_LOOKUP, False))
    running_bit_offset += 8

    # 6:reserved_48 | Offset: 48, Length: 1, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    reserved_48 = reserved_48_raw = decode_int(_data_raw_, running_bit_offset, 1)
    nmea2000Message.fields.append(NMEA2000Field('reserved_48', 'Reserved', None, None, reserved_48, reserved_48_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 1

    # 7:device_class | Offset: 49, Length: 7, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 49
    device_class_raw = decode_int(_data_raw_, running_bit_offset, 7)
    device_class = master_dict['DEVICE_CLASS'].get(device_class_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('device_class', 'Device Class', None, None, device_class, device_class_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 7
    combined_key = str(device_class_raw) + "_" + str(device_function_raw)
    device_function = master_indirect_lookup_dict['DEVICE_FUNCTION'].get(combined_key, None)
    nmea2000Message.fields[4].value = device_function

    # 8:system_instance | Offset: 56, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 56
    system_instance = system_instance_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('system_instance', 'System Instance', "ISO Device Class Instance", None, system_instance, system_instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 4

    # 9:industry_code | Offset: 60, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 60
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', None, None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 10:reserved_63 | Offset: 63, Length: 1, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 63
    reserved_63 = reserved_63_raw = decode_int(_data_raw_, running_bit_offset, 1)
    nmea2000Message.fields.append(NMEA2000Field('reserved_63', 'Reserved', None, None, reserved_63, reserved_63_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 1

    # 11:new_source_address | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    new_source_address = new_source_address_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('new_source_address', 'New Source Address', None, None, new_source_address, new_source_address_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_65240(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65240."""
    data_raw = 0
    # unique_number | Offset: 0, Length: 21, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'unique_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unique Number'")
    field_value = field.value
    data_raw |= (field_value & 0x1FFFFF) << 0
    # manufacturer_code | Offset: 21, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 21
    # device_instance_lower | Offset: 32, Length: 3, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'device_instance_lower')
    if field is None:
        raise Exception("Cant encode this message, missing 'Device Instance Lower'")
    field_value = field.value
    data_raw |= (field_value & 0x7) << 32
    # device_instance_upper | Offset: 35, Length: 5, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'device_instance_upper')
    if field is None:
        raise Exception("Cant encode this message, missing 'Device Instance Upper'")
    field_value = field.value
    data_raw |= (field_value & 0x1F) << 35
    # device_function | Offset: 40, Length: 8, Resolution: 1, Field Type: INDIRECT_LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'device_function')
    if field is None:
        raise Exception("Cant encode this message, missing 'Device Function'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # reserved_48 | Offset: 48, Length: 1, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_48')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1) << 48
    # device_class | Offset: 49, Length: 7, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'device_class')
    if field is None:
        raise Exception("Cant encode this message, missing 'Device Class'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DEVICE_CLASS(field.value)
    data_raw |= (field_value & 0x7F) << 49
    # system_instance | Offset: 56, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'system_instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'System Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 56
    # industry_code | Offset: 60, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 60
    # reserved_63 | Offset: 63, Length: 1, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_63')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1) << 63
    # new_source_address | Offset: 64, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'new_source_address')
    if field is None:
        raise Exception("Cant encode this message, missing 'New Source Address'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 64
    return data_raw


def is_fast_pgn_65280() -> bool:
    """Return True if PGN 65280 is a fast PGN."""
    return False
# Complex PGN. number of matches: 2
def decode_pgn_65280(data_raw: int) -> NMEA2000Message:
    # furunoHeave | Description: Furuno: Heave
    if (
        (((data_raw >> 0) & 0x7FF) == 1855) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_65280_furunoHeave(data_raw)
    
    return decode_pgn_65280_0xff000xffffManufacturerProprietarySingleFrameNonAddressed(data_raw)
    
def decode_pgn_65280_0xff000xffffManufacturerProprietarySingleFrameNonAddressed(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65280."""
    nmea2000Message = NMEA2000Message(65280, '0xff000xffffManufacturerProprietarySingleFrameNonAddressed', '0xFF00-0xFFFF: Manufacturer Proprietary single-frame non-addressed')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', None, None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', None, None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:data | Offset: 16, Length: 48, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    data = data_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 48))
    nmea2000Message.fields.append(NMEA2000Field('data', 'Data', None, None, data, data_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 48

    return nmea2000Message

def encode_pgn_65280_0xff000xffffManufacturerProprietarySingleFrameNonAddressed(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65280."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # data | Offset: 16, Length: 48, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'data')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFF) << 16
    return data_raw

def decode_pgn_65280_furunoHeave(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65280."""
    nmea2000Message = NMEA2000Message(65280, 'furunoHeave', 'Furuno: Heave')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1855, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Furuno", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:heave | Offset: 16, Length: 32, Signed: True Resolution: 0.001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    heave = heave_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 0.001)
    nmea2000Message.fields.append(NMEA2000Field('heave', 'Heave', None, 'm', heave, heave_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 5:reserved_48 | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    reserved_48 = reserved_48_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('reserved_48', 'Reserved', None, None, reserved_48, reserved_48_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_65280_furunoHeave(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65280."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # heave | Offset: 16, Length: 32, Resolution: 0.001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'heave')
    if field is None:
        raise Exception("Cant encode this message, missing 'Heave'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFFFFFF) << 16
    
    # reserved_48 | Offset: 48, Length: 16, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_48')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_65284() -> bool:
    """Return True if PGN 65284 is a fast PGN."""
    return False
def decode_pgn_65284(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65284."""
    nmea2000Message = NMEA2000Message(65284, 'maretronProprietaryDcBreakerCurrent', 'Maretron: Proprietary DC Breaker Current')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 137, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Maretron", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:bank_instance | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 16
    bank_instance = bank_instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('bank_instance', 'Bank Instance', None, None, bank_instance, bank_instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 5:indicator_number | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    indicator_number = indicator_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('indicator_number', 'Indicator Number', None, None, indicator_number, indicator_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:breaker_current | Offset: 32, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    breaker_current = breaker_current_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('breaker_current', 'Breaker Current', None, 'A', breaker_current, breaker_current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:reserved_48 | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    reserved_48 = reserved_48_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('reserved_48', 'Reserved', None, None, reserved_48, reserved_48_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_65284(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65284."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # bank_instance | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'bank_instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Bank Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # indicator_number | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # breaker_current | Offset: 32, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'breaker_current')
    if field is None:
        raise Exception("Cant encode this message, missing 'Breaker Current'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 32
    
    # reserved_48 | Offset: 48, Length: 16, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_48')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_65285() -> bool:
    """Return True if PGN 65285 is a fast PGN."""
    return False
# Complex PGN. number of matches: 2
def decode_pgn_65285(data_raw: int) -> NMEA2000Message:
    # airmarBootStateAcknowledgment | Description: Airmar: Boot State Acknowledgment
    if (
        (((data_raw >> 0) & 0x7FF) == 135) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_65285_airmarBootStateAcknowledgment(data_raw)
    
    # lowranceTemperature | Description: Lowrance: Temperature
    if (
        (((data_raw >> 0) & 0x7FF) == 140) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_65285_lowranceTemperature(data_raw)
    
    
    raise Exception("No matching sub-PGN found")
    
def decode_pgn_65285_airmarBootStateAcknowledgment(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65285."""
    nmea2000Message = NMEA2000Message(65285, 'airmarBootStateAcknowledgment', 'Airmar: Boot State Acknowledgment')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:boot_state | Offset: 16, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    boot_state_raw = decode_int(_data_raw_, running_bit_offset, 3)
    boot_state = master_dict['BOOT_STATE'].get(boot_state_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('boot_state', 'Boot State', None, None, boot_state, boot_state_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 5:reserved_19 | Offset: 19, Length: 45, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 19
    reserved_19 = reserved_19_raw = decode_int(_data_raw_, running_bit_offset, 45)
    nmea2000Message.fields.append(NMEA2000Field('reserved_19', 'Reserved', None, None, reserved_19, reserved_19_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 45

    return nmea2000Message

def encode_pgn_65285_airmarBootStateAcknowledgment(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65285."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # boot_state | Offset: 16, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'boot_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'Boot State'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_BOOT_STATE(field.value)
    data_raw |= (field_value & 0x7) << 16
    # reserved_19 | Offset: 19, Length: 45, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_19')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1FFFFFFFFFFF) << 19
    return data_raw

def decode_pgn_65285_lowranceTemperature(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65285."""
    nmea2000Message = NMEA2000Message(65285, 'lowranceTemperature', 'Lowrance: Temperature')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 140, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Lowrance", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:temperature_source | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    temperature_source_raw = decode_int(_data_raw_, running_bit_offset, 8)
    temperature_source = master_dict['TEMPERATURE_SOURCE'].get(temperature_source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('temperature_source', 'Temperature Source', None, None, temperature_source, temperature_source_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:actual_temperature | Offset: 24, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    actual_temperature = actual_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('actual_temperature', 'Actual Temperature', None, 'K', actual_temperature, actual_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:reserved_40 | Offset: 40, Length: 24, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    reserved_40 = reserved_40_raw = decode_int(_data_raw_, running_bit_offset, 24)
    nmea2000Message.fields.append(NMEA2000Field('reserved_40', 'Reserved', None, None, reserved_40, reserved_40_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 24

    return nmea2000Message

def encode_pgn_65285_lowranceTemperature(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65285."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # temperature_source | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'temperature_source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Temperature Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_TEMPERATURE_SOURCE(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # actual_temperature | Offset: 24, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'actual_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Actual Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 24
    
    # reserved_40 | Offset: 40, Length: 24, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_40')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 40
    return data_raw


def is_fast_pgn_65286() -> bool:
    """Return True if PGN 65286 is a fast PGN."""
    return False
# Complex PGN. number of matches: 2
def decode_pgn_65286(data_raw: int) -> NMEA2000Message:
    # chetcoDimmer | Description: Chetco: Dimmer
    if (
        (((data_raw >> 0) & 0x7FF) == 409) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_65286_chetcoDimmer(data_raw)
    
    # airmarBootStateRequest | Description: Airmar: Boot State Request
    if (
        (((data_raw >> 0) & 0x7FF) == 135) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_65286_airmarBootStateRequest(data_raw)
    
    
    raise Exception("No matching sub-PGN found")
    
def decode_pgn_65286_chetcoDimmer(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65286."""
    nmea2000Message = NMEA2000Message(65286, 'chetcoDimmer', 'Chetco: Dimmer')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 409, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Chetco", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:instance | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 16
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 5:dimmer1 | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    dimmer1 = dimmer1_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('dimmer1', 'Dimmer1', None, None, dimmer1, dimmer1_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:dimmer2 | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    dimmer2 = dimmer2_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('dimmer2', 'Dimmer2', None, None, dimmer2, dimmer2_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:dimmer3 | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    dimmer3 = dimmer3_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('dimmer3', 'Dimmer3', None, None, dimmer3, dimmer3_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:dimmer4 | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    dimmer4 = dimmer4_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('dimmer4', 'Dimmer4', None, None, dimmer4, dimmer4_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:control | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    control = control_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_65286_chetcoDimmer(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65286."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # instance | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # dimmer1 | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'dimmer1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Dimmer1'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # dimmer2 | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'dimmer2')
    if field is None:
        raise Exception("Cant encode this message, missing 'Dimmer2'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # dimmer3 | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'dimmer3')
    if field is None:
        raise Exception("Cant encode this message, missing 'Dimmer3'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # dimmer4 | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'dimmer4')
    if field is None:
        raise Exception("Cant encode this message, missing 'Dimmer4'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # control | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw

def decode_pgn_65286_airmarBootStateRequest(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65286."""
    nmea2000Message = NMEA2000Message(65286, 'airmarBootStateRequest', 'Airmar: Boot State Request')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 48, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 48)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 48

    return nmea2000Message

def encode_pgn_65286_airmarBootStateRequest(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65286."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 48, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFF) << 16
    return data_raw


def is_fast_pgn_65287() -> bool:
    """Return True if PGN 65287 is a fast PGN."""
    return False
# Complex PGN. number of matches: 2
def decode_pgn_65287(data_raw: int) -> NMEA2000Message:
    # airmarAccessLevel | Description: Airmar: Access Level
    if (
        (((data_raw >> 0) & 0x7FF) == 135) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_65287_airmarAccessLevel(data_raw)
    
    # simnetConfigureTemperatureSensor | Description: Simnet: Configure Temperature Sensor
    if (
        (((data_raw >> 0) & 0x7FF) == 1857) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_65287_simnetConfigureTemperatureSensor(data_raw)
    
    
    raise Exception("No matching sub-PGN found")
    
def decode_pgn_65287_airmarAccessLevel(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65287."""
    nmea2000Message = NMEA2000Message(65287, 'airmarAccessLevel', 'Airmar: Access Level')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:format_code | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    format_code = format_code_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('format_code', 'Format Code', None, None, format_code, format_code_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:access_level | Offset: 24, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    access_level_raw = decode_int(_data_raw_, running_bit_offset, 3)
    access_level = master_dict['ACCESS_LEVEL'].get(access_level_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('access_level', 'Access Level', None, None, access_level, access_level_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 6:reserved_27 | Offset: 27, Length: 5, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 27
    reserved_27 = reserved_27_raw = decode_int(_data_raw_, running_bit_offset, 5)
    nmea2000Message.fields.append(NMEA2000Field('reserved_27', 'Reserved', None, None, reserved_27, reserved_27_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 5

    # 7:access_seed_key | Offset: 32, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    access_seed_key = access_seed_key_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('access_seed_key', 'Access Seed/Key', "When transmitted, it provides a seed for an unlock operation. It is used to provide the key during PGN 126208.", None, access_seed_key, access_seed_key_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_65287_airmarAccessLevel(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65287."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # format_code | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'format_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Format Code'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # access_level | Offset: 24, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'access_level')
    if field is None:
        raise Exception("Cant encode this message, missing 'Access Level'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ACCESS_LEVEL(field.value)
    data_raw |= (field_value & 0x7) << 24
    # reserved_27 | Offset: 27, Length: 5, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_27')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1F) << 27
    # access_seed_key | Offset: 32, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'access_seed_key')
    if field is None:
        raise Exception("Cant encode this message, missing 'Access Seed/Key'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw

def decode_pgn_65287_simnetConfigureTemperatureSensor(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65287."""
    nmea2000Message = NMEA2000Message(65287, 'simnetConfigureTemperatureSensor', 'Simnet: Configure Temperature Sensor')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 48, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 48)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 48

    return nmea2000Message

def encode_pgn_65287_simnetConfigureTemperatureSensor(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65287."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 48, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFF) << 16
    return data_raw


def is_fast_pgn_65288() -> bool:
    """Return True if PGN 65288 is a fast PGN."""
    return False
def decode_pgn_65288(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65288."""
    nmea2000Message = NMEA2000Message(65288, 'seatalkAlarm', 'Seatalk: Alarm')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1851, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Raymarine", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:sid | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    sid = sid_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 8))
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 8

    # 5:alarm_status | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    alarm_status_raw = decode_int(_data_raw_, running_bit_offset, 8)
    alarm_status = master_dict['SEATALK_ALARM_STATUS'].get(alarm_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('alarm_status', 'Alarm Status', None, None, alarm_status, alarm_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 6:alarm_id | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    alarm_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    alarm_id = master_dict['SEATALK_ALARM_ID'].get(alarm_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('alarm_id', 'Alarm ID', None, None, alarm_id, alarm_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:alarm_group | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    alarm_group_raw = decode_int(_data_raw_, running_bit_offset, 8)
    alarm_group = master_dict['SEATALK_ALARM_GROUP'].get(alarm_group_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('alarm_group', 'Alarm Group', None, None, alarm_group, alarm_group_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 8:alarm_priority | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    alarm_priority = alarm_priority_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 16))
    nmea2000Message.fields.append(NMEA2000Field('alarm_priority', 'Alarm Priority', None, None, alarm_priority, alarm_priority_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_65288(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65288."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # sid | Offset: 16, Length: 8, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # alarm_status | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'alarm_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alarm Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SEATALK_ALARM_STATUS(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # alarm_id | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'alarm_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alarm ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SEATALK_ALARM_ID(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # alarm_group | Offset: 40, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'alarm_group')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alarm Group'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SEATALK_ALARM_GROUP(field.value)
    data_raw |= (field_value & 0xFF) << 40
    # alarm_priority | Offset: 48, Length: 16, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'alarm_priority')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alarm Priority'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_65289() -> bool:
    """Return True if PGN 65289 is a fast PGN."""
    return False
def decode_pgn_65289(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65289."""
    nmea2000Message = NMEA2000Message(65289, 'simnetTrimTabSensorCalibration', 'Simnet: Trim Tab Sensor Calibration')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 48, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 48)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 48

    return nmea2000Message

def encode_pgn_65289(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65289."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 48, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFF) << 16
    return data_raw


def is_fast_pgn_65290() -> bool:
    """Return True if PGN 65290 is a fast PGN."""
    return False
def decode_pgn_65290(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65290."""
    nmea2000Message = NMEA2000Message(65290, 'simnetPaddleWheelSpeedConfiguration', 'Simnet: Paddle Wheel Speed Configuration')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 48, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 48)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 48

    return nmea2000Message

def encode_pgn_65290(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65290."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 48, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFF) << 16
    return data_raw


def is_fast_pgn_65292() -> bool:
    """Return True if PGN 65292 is a fast PGN."""
    return False
def decode_pgn_65292(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65292."""
    nmea2000Message = NMEA2000Message(65292, 'simnetClearFluidLevelWarnings', 'Simnet: Clear Fluid Level Warnings')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 48, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 48)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 48

    return nmea2000Message

def encode_pgn_65292(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65292."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 48, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFF) << 16
    return data_raw


def is_fast_pgn_65293() -> bool:
    """Return True if PGN 65293 is a fast PGN."""
    return False
# Complex PGN. number of matches: 2
def decode_pgn_65293(data_raw: int) -> NMEA2000Message:
    # simnetLgc2000Configuration | Description: Simnet: LGC-2000 Configuration
    if (
        (((data_raw >> 0) & 0x7FF) == 1857) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_65293_simnetLgc2000Configuration(data_raw)
    
    # diverseYachtServicesLoadCell | Description: Diverse Yacht Services: Load Cell
    if (
        (((data_raw >> 0) & 0x7FF) == 641) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_65293_diverseYachtServicesLoadCell(data_raw)
    
    
    raise Exception("No matching sub-PGN found")
    
def decode_pgn_65293_simnetLgc2000Configuration(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65293."""
    nmea2000Message = NMEA2000Message(65293, 'simnetLgc2000Configuration', 'Simnet: LGC-2000 Configuration')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 48, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 48)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 48

    return nmea2000Message

def encode_pgn_65293_simnetLgc2000Configuration(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65293."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 48, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFF) << 16
    return data_raw

def decode_pgn_65293_diverseYachtServicesLoadCell(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65293."""
    nmea2000Message = NMEA2000Message(65293, 'diverseYachtServicesLoadCell', 'Diverse Yacht Services: Load Cell')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 641, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Diverse Yacht Services", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:instance | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 16
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 5:reserved_24 | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    reserved_24 = reserved_24_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_24', 'Reserved', None, None, reserved_24, reserved_24_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 6:load_cell | Offset: 32, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    load_cell = load_cell_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('load_cell', 'Load Cell', None, None, load_cell, load_cell_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_65293_diverseYachtServicesLoadCell(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65293."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # instance | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # reserved_24 | Offset: 24, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_24')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # load_cell | Offset: 32, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'load_cell')
    if field is None:
        raise Exception("Cant encode this message, missing 'Load Cell'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw


def is_fast_pgn_65302() -> bool:
    """Return True if PGN 65302 is a fast PGN."""
    return False
def decode_pgn_65302(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65302."""
    nmea2000Message = NMEA2000Message(65302, 'simnetApUnknown1', 'Simnet: AP Unknown 1')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:a | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:b | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:c | Offset: 32, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:d | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    d = d_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('d', 'D', None, None, d, d_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_65302(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65302."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # a | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # b | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # c | Offset: 32, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 32
    # d | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'd')
    if field is None:
        raise Exception("Cant encode this message, missing 'D'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_65305() -> bool:
    """Return True if PGN 65305 is a fast PGN."""
    return False
# Complex PGN. number of matches: 5
def decode_pgn_65305(data_raw: int) -> NMEA2000Message:
    # simnetDeviceStatus | Description: Simnet: Device Status
    if (
        (((data_raw >> 0) & 0x7FF) == 1857) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 2)
        ):
        return decode_pgn_65305_simnetDeviceStatus(data_raw)
    
    # simnetDeviceStatusRequest | Description: Simnet: Device Status Request
    if (
        (((data_raw >> 0) & 0x7FF) == 1857) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 3)
        ):
        return decode_pgn_65305_simnetDeviceStatusRequest(data_raw)
    
    # simnetPilotMode | Description: Simnet: Pilot Mode
    if (
        (((data_raw >> 0) & 0x7FF) == 1857) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 10)
        ):
        return decode_pgn_65305_simnetPilotMode(data_raw)
    
    # simnetDeviceModeRequest | Description: Simnet: Device Mode Request
    if (
        (((data_raw >> 0) & 0x7FF) == 1857) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 11)
        ):
        return decode_pgn_65305_simnetDeviceModeRequest(data_raw)
    
    # simnetSailingProcessorStatus | Description: Simnet: Sailing Processor Status
    if (
        (((data_raw >> 0) & 0x7FF) == 1857) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 23)
        ):
        return decode_pgn_65305_simnetSailingProcessorStatus(data_raw)
    
    
    raise Exception("No matching sub-PGN found")
    
def decode_pgn_65305_simnetDeviceStatus(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65305."""
    nmea2000Message = NMEA2000Message(65305, 'simnetDeviceStatus', 'Simnet: Device Status')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:model | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    model_raw = decode_int(_data_raw_, running_bit_offset, 8)
    model = master_dict['SIMNET_DEVICE_MODEL'].get(model_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('model', 'Model', None, None, model, model_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:report | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 2, PartOfPrimaryKey: ,
    running_bit_offset = 24
    report_raw = decode_int(_data_raw_, running_bit_offset, 8)
    report = master_dict['SIMNET_DEVICE_REPORT'].get(report_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('report', 'Report', "Status", None, report, report_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 6:status | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    status_raw = decode_int(_data_raw_, running_bit_offset, 8)
    status = master_dict['SIMNET_AP_STATUS'].get(status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('status', 'Status', None, None, status, status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:spare | Offset: 40, Length: 24, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 24)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 24

    return nmea2000Message

def encode_pgn_65305_simnetDeviceStatus(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65305."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # model | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'model')
    if field is None:
        raise Exception("Cant encode this message, missing 'Model'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_DEVICE_MODEL(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # report | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'report')
    if field is None:
        raise Exception("Cant encode this message, missing 'Report'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_DEVICE_REPORT(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # status | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_AP_STATUS(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # spare | Offset: 40, Length: 24, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 40
    return data_raw

def decode_pgn_65305_simnetDeviceStatusRequest(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65305."""
    nmea2000Message = NMEA2000Message(65305, 'simnetDeviceStatusRequest', 'Simnet: Device Status Request')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:model | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    model_raw = decode_int(_data_raw_, running_bit_offset, 8)
    model = master_dict['SIMNET_DEVICE_MODEL'].get(model_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('model', 'Model', None, None, model, model_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:report | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 3, PartOfPrimaryKey: ,
    running_bit_offset = 24
    report_raw = decode_int(_data_raw_, running_bit_offset, 8)
    report = master_dict['SIMNET_DEVICE_REPORT'].get(report_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('report', 'Report', "Send Status", None, report, report_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 6:spare | Offset: 32, Length: 32, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 32)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_65305_simnetDeviceStatusRequest(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65305."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # model | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'model')
    if field is None:
        raise Exception("Cant encode this message, missing 'Model'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_DEVICE_MODEL(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # report | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'report')
    if field is None:
        raise Exception("Cant encode this message, missing 'Report'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_DEVICE_REPORT(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # spare | Offset: 32, Length: 32, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw

def decode_pgn_65305_simnetPilotMode(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65305."""
    nmea2000Message = NMEA2000Message(65305, 'simnetPilotMode', 'Simnet: Pilot Mode')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:model | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    model_raw = decode_int(_data_raw_, running_bit_offset, 8)
    model = master_dict['SIMNET_DEVICE_MODEL'].get(model_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('model', 'Model', None, None, model, model_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:report | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 10, PartOfPrimaryKey: ,
    running_bit_offset = 24
    report_raw = decode_int(_data_raw_, running_bit_offset, 8)
    report = master_dict['SIMNET_DEVICE_REPORT'].get(report_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('report', 'Report', "Mode", None, report, report_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 6:mode | Offset: 32, Length: 16, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    mode_raw = decode_int(_data_raw_, running_bit_offset, 16)
    mode = decode_bit_lookup(mode_raw, master_flags_dict['SIMNET_AP_MODE_BITFIELD'])
    nmea2000Message.fields.append(NMEA2000Field('mode', 'Mode', None, None, mode, mode_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 16

    # 7:spare | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_65305_simnetPilotMode(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65305."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # model | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'model')
    if field is None:
        raise Exception("Cant encode this message, missing 'Model'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_DEVICE_MODEL(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # report | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'report')
    if field is None:
        raise Exception("Cant encode this message, missing 'Report'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_DEVICE_REPORT(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # mode | Offset: 32, Length: 16, Resolution: 1, Field Type: BITLOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mode'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 32
    # spare | Offset: 48, Length: 16, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw

def decode_pgn_65305_simnetDeviceModeRequest(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65305."""
    nmea2000Message = NMEA2000Message(65305, 'simnetDeviceModeRequest', 'Simnet: Device Mode Request')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:model | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    model_raw = decode_int(_data_raw_, running_bit_offset, 8)
    model = master_dict['SIMNET_DEVICE_MODEL'].get(model_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('model', 'Model', None, None, model, model_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:report | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 11, PartOfPrimaryKey: ,
    running_bit_offset = 24
    report_raw = decode_int(_data_raw_, running_bit_offset, 8)
    report = master_dict['SIMNET_DEVICE_REPORT'].get(report_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('report', 'Report', "Send Mode", None, report, report_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 6:spare | Offset: 32, Length: 32, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 32)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_65305_simnetDeviceModeRequest(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65305."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # model | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'model')
    if field is None:
        raise Exception("Cant encode this message, missing 'Model'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_DEVICE_MODEL(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # report | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'report')
    if field is None:
        raise Exception("Cant encode this message, missing 'Report'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_DEVICE_REPORT(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # spare | Offset: 32, Length: 32, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw

def decode_pgn_65305_simnetSailingProcessorStatus(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65305."""
    nmea2000Message = NMEA2000Message(65305, 'simnetSailingProcessorStatus', 'Simnet: Sailing Processor Status')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:model | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    model_raw = decode_int(_data_raw_, running_bit_offset, 8)
    model = master_dict['SIMNET_DEVICE_MODEL'].get(model_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('model', 'Model', None, None, model, model_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:report | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 23, PartOfPrimaryKey: ,
    running_bit_offset = 24
    report_raw = decode_int(_data_raw_, running_bit_offset, 8)
    report = master_dict['SIMNET_DEVICE_REPORT'].get(report_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('report', 'Report', "Sailing Processor Status", None, report, report_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 6:data | Offset: 32, Length: 32, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    data = data_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 32))
    nmea2000Message.fields.append(NMEA2000Field('data', 'Data', None, None, data, data_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_65305_simnetSailingProcessorStatus(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65305."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # model | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'model')
    if field is None:
        raise Exception("Cant encode this message, missing 'Model'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_DEVICE_MODEL(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # report | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'report')
    if field is None:
        raise Exception("Cant encode this message, missing 'Report'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_DEVICE_REPORT(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # data | Offset: 32, Length: 32, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'data')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw


def is_fast_pgn_65309() -> bool:
    """Return True if PGN 65309 is a fast PGN."""
    return False
def decode_pgn_65309(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65309."""
    nmea2000Message = NMEA2000Message(65309, 'navicoWirelessBatteryStatus', 'Navico: Wireless Battery Status')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:status | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    status = status_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('status', 'Status', None, None, status, status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:battery_status | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    battery_status = battery_status_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('battery_status', 'Battery Status', None, '%', battery_status, battery_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:battery_charge_status | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    battery_charge_status = battery_charge_status_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('battery_charge_status', 'Battery Charge Status', None, '%', battery_charge_status, battery_charge_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:reserved_40 | Offset: 40, Length: 24, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    reserved_40 = reserved_40_raw = decode_int(_data_raw_, running_bit_offset, 24)
    nmea2000Message.fields.append(NMEA2000Field('reserved_40', 'Reserved', None, None, reserved_40, reserved_40_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 24

    return nmea2000Message

def encode_pgn_65309(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65309."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # status | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Status'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # battery_status | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'battery_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Battery Status'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # battery_charge_status | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'battery_charge_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Battery Charge Status'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # reserved_40 | Offset: 40, Length: 24, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_40')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 40
    return data_raw


def is_fast_pgn_65312() -> bool:
    """Return True if PGN 65312 is a fast PGN."""
    return False
def decode_pgn_65312(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65312."""
    nmea2000Message = NMEA2000Message(65312, 'navicoWirelessSignalStatus', 'Navico: Wireless Signal Status')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:unknown | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    unknown = unknown_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unknown', 'Unknown', None, None, unknown, unknown_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:signal_strength | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    signal_strength = signal_strength_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('signal_strength', 'Signal Strength', None, '%', signal_strength, signal_strength_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:reserved_32 | Offset: 32, Length: 32, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    reserved_32 = reserved_32_raw = decode_int(_data_raw_, running_bit_offset, 32)
    nmea2000Message.fields.append(NMEA2000Field('reserved_32', 'Reserved', None, None, reserved_32, reserved_32_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_65312(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65312."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # unknown | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # signal_strength | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'signal_strength')
    if field is None:
        raise Exception("Cant encode this message, missing 'Signal Strength'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # reserved_32 | Offset: 32, Length: 32, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_32')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw


def is_fast_pgn_65340() -> bool:
    """Return True if PGN 65340 is a fast PGN."""
    return False
def decode_pgn_65340(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65340."""
    nmea2000Message = NMEA2000Message(65340, 'simnetApUnknown2', 'Simnet: AP Unknown 2')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:a | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:b | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:c | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:d | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    d = d_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('d', 'D', None, None, d, d_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:e | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    e = e_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('e', 'E', None, None, e, e_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_65340(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65340."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # a | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # b | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # c | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # d | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'd')
    if field is None:
        raise Exception("Cant encode this message, missing 'D'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # e | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'e')
    if field is None:
        raise Exception("Cant encode this message, missing 'E'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_65341() -> bool:
    """Return True if PGN 65341 is a fast PGN."""
    return False
def decode_pgn_65341(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65341."""
    nmea2000Message = NMEA2000Message(65341, 'simnetAutopilotAngle', 'Simnet: Autopilot Angle')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 16

    # 5:mode | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    mode_raw = decode_int(_data_raw_, running_bit_offset, 8)
    mode = master_dict['SIMNET_AP_MODE'].get(mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('mode', 'Mode', None, None, mode, mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 6:reserved_40 | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    reserved_40 = reserved_40_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_40', 'Reserved', None, None, reserved_40, reserved_40_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 7:angle | Offset: 48, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    angle = angle_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('angle', 'Angle', None, 'rad', angle, angle_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_65341(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65341."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 16, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # mode | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_AP_MODE(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # reserved_40 | Offset: 40, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_40')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # angle | Offset: 48, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'angle')
    if field is None:
        raise Exception("Cant encode this message, missing 'Angle'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 48
    
    return data_raw


def is_fast_pgn_65345() -> bool:
    """Return True if PGN 65345 is a fast PGN."""
    return False
def decode_pgn_65345(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65345."""
    nmea2000Message = NMEA2000Message(65345, 'seatalkPilotWindDatum', 'Seatalk: Pilot Wind Datum')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1851, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Raymarine", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:wind_datum | Offset: 16, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    wind_datum = wind_datum_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('wind_datum', 'Wind Datum', None, 'rad', wind_datum, wind_datum_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:rolling_average_wind_angle | Offset: 32, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    rolling_average_wind_angle = rolling_average_wind_angle_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('rolling_average_wind_angle', 'Rolling Average Wind Angle', None, 'rad', rolling_average_wind_angle, rolling_average_wind_angle_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:reserved_48 | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    reserved_48 = reserved_48_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('reserved_48', 'Reserved', None, None, reserved_48, reserved_48_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_65345(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65345."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # wind_datum | Offset: 16, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'wind_datum')
    if field is None:
        raise Exception("Cant encode this message, missing 'Wind Datum'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 16
    
    # rolling_average_wind_angle | Offset: 32, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'rolling_average_wind_angle')
    if field is None:
        raise Exception("Cant encode this message, missing 'Rolling Average Wind Angle'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 32
    
    # reserved_48 | Offset: 48, Length: 16, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_48')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_65350() -> bool:
    """Return True if PGN 65350 is a fast PGN."""
    return False
def decode_pgn_65350(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65350."""
    nmea2000Message = NMEA2000Message(65350, 'simnetMagneticField', 'Simnet: Magnetic Field')
    running_bit_offset = 0
    # 1:a | Offset: 0, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, 'rad', a, a_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:b | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, '%', b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:c | Offset: 24, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, 'rad', c, c_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:d | Offset: 40, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    d = d_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('d', 'D', None, 'rad', d, d_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_65350(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65350."""
    data_raw = 0
    # a | Offset: 0, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 0
    
    # b | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # c | Offset: 24, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 24
    
    # d | Offset: 40, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'd')
    if field is None:
        raise Exception("Cant encode this message, missing 'D'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 40
    
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_65359() -> bool:
    """Return True if PGN 65359 is a fast PGN."""
    return False
def decode_pgn_65359(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65359."""
    nmea2000Message = NMEA2000Message(65359, 'seatalkPilotHeading', 'Seatalk: Pilot Heading')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1851, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Raymarine", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:sid | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    sid = sid_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 8))
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 8

    # 5:heading_true | Offset: 24, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    heading_true = heading_true_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('heading_true', 'Heading True', None, 'rad', heading_true, heading_true_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:heading_magnetic | Offset: 40, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    heading_magnetic = heading_magnetic_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('heading_magnetic', 'Heading Magnetic', None, 'rad', heading_magnetic, heading_magnetic_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_65359(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65359."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # sid | Offset: 16, Length: 8, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # heading_true | Offset: 24, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'heading_true')
    if field is None:
        raise Exception("Cant encode this message, missing 'Heading True'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 24
    
    # heading_magnetic | Offset: 40, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'heading_magnetic')
    if field is None:
        raise Exception("Cant encode this message, missing 'Heading Magnetic'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 40
    
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_65360() -> bool:
    """Return True if PGN 65360 is a fast PGN."""
    return False
def decode_pgn_65360(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65360."""
    nmea2000Message = NMEA2000Message(65360, 'seatalkPilotLockedHeading', 'Seatalk: Pilot Locked Heading')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1851, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Raymarine", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:sid | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    sid = sid_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 8))
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 8

    # 5:target_heading_true | Offset: 24, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    target_heading_true = target_heading_true_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('target_heading_true', 'Target Heading True', None, 'rad', target_heading_true, target_heading_true_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:target_heading_magnetic | Offset: 40, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    target_heading_magnetic = target_heading_magnetic_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('target_heading_magnetic', 'Target Heading Magnetic', None, 'rad', target_heading_magnetic, target_heading_magnetic_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_65360(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65360."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # sid | Offset: 16, Length: 8, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # target_heading_true | Offset: 24, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'target_heading_true')
    if field is None:
        raise Exception("Cant encode this message, missing 'Target Heading True'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 24
    
    # target_heading_magnetic | Offset: 40, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'target_heading_magnetic')
    if field is None:
        raise Exception("Cant encode this message, missing 'Target Heading Magnetic'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 40
    
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_65361() -> bool:
    """Return True if PGN 65361 is a fast PGN."""
    return False
def decode_pgn_65361(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65361."""
    nmea2000Message = NMEA2000Message(65361, 'seatalkSilenceAlarm', 'Seatalk: Silence Alarm')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1851, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Raymarine", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:alarm_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    alarm_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    alarm_id = master_dict['SEATALK_ALARM_ID'].get(alarm_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('alarm_id', 'Alarm ID', None, None, alarm_id, alarm_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:alarm_group | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    alarm_group_raw = decode_int(_data_raw_, running_bit_offset, 8)
    alarm_group = master_dict['SEATALK_ALARM_GROUP'].get(alarm_group_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('alarm_group', 'Alarm Group', None, None, alarm_group, alarm_group_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 6:reserved_32 | Offset: 32, Length: 32, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    reserved_32 = reserved_32_raw = decode_int(_data_raw_, running_bit_offset, 32)
    nmea2000Message.fields.append(NMEA2000Field('reserved_32', 'Reserved', None, None, reserved_32, reserved_32_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_65361(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65361."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # alarm_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'alarm_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alarm ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SEATALK_ALARM_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # alarm_group | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'alarm_group')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alarm Group'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SEATALK_ALARM_GROUP(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # reserved_32 | Offset: 32, Length: 32, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_32')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw


def is_fast_pgn_65371() -> bool:
    """Return True if PGN 65371 is a fast PGN."""
    return False
def decode_pgn_65371(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65371."""
    nmea2000Message = NMEA2000Message(65371, 'seatalkKeypadMessage', 'Seatalk: Keypad Message')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1851, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Raymarine", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 16
    proprietary_id = proprietary_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', None, None, proprietary_id, proprietary_id_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 5:first_key | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    first_key = first_key_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('first_key', 'First key', None, None, first_key, first_key_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:second_key | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    second_key = second_key_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('second_key', 'Second key', None, None, second_key, second_key_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:first_key_state | Offset: 40, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    first_key_state = first_key_state_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('first_key_state', 'First key state', None, None, first_key_state, first_key_state_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 8:second_key_state | Offset: 42, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 42
    second_key_state = second_key_state_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('second_key_state', 'Second key state', None, None, second_key_state, second_key_state_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 9:reserved_44 | Offset: 44, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 44
    reserved_44 = reserved_44_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_44', 'Reserved', None, None, reserved_44, reserved_44_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 10:encoder_position | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    encoder_position = encoder_position_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('encoder_position', 'Encoder Position', None, None, encoder_position, encoder_position_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 11:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_65371(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65371."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # first_key | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'first_key')
    if field is None:
        raise Exception("Cant encode this message, missing 'First key'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # second_key | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'second_key')
    if field is None:
        raise Exception("Cant encode this message, missing 'Second key'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # first_key_state | Offset: 40, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'first_key_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'First key state'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 40
    # second_key_state | Offset: 42, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'second_key_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'Second key state'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 42
    # reserved_44 | Offset: 44, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_44')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 44
    # encoder_position | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'encoder_position')
    if field is None:
        raise Exception("Cant encode this message, missing 'Encoder Position'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_65374() -> bool:
    """Return True if PGN 65374 is a fast PGN."""
    return False
def decode_pgn_65374(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65374."""
    nmea2000Message = NMEA2000Message(65374, 'seatalkKeypadHeartbeat', 'SeaTalk: Keypad Heartbeat')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1851, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Raymarine", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 16
    proprietary_id = proprietary_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', None, None, proprietary_id, proprietary_id_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 5:variant | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    variant = variant_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('variant', 'Variant', None, None, variant, variant_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:status | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    status = status_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('status', 'Status', None, None, status, status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:reserved_40 | Offset: 40, Length: 24, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    reserved_40 = reserved_40_raw = decode_int(_data_raw_, running_bit_offset, 24)
    nmea2000Message.fields.append(NMEA2000Field('reserved_40', 'Reserved', None, None, reserved_40, reserved_40_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 24

    return nmea2000Message

def encode_pgn_65374(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65374."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # variant | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'variant')
    if field is None:
        raise Exception("Cant encode this message, missing 'Variant'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # status | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Status'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # reserved_40 | Offset: 40, Length: 24, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_40')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 40
    return data_raw


def is_fast_pgn_65379() -> bool:
    """Return True if PGN 65379 is a fast PGN."""
    return False
def decode_pgn_65379(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65379."""
    nmea2000Message = NMEA2000Message(65379, 'seatalkPilotMode', 'Seatalk: Pilot Mode')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1851, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Raymarine", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:pilot_mode | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    pilot_mode_raw = decode_int(_data_raw_, running_bit_offset, 16)
    pilot_mode = master_dict['SEATALK_PILOT_MODE_16'].get(pilot_mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('pilot_mode', 'Pilot Mode', None, None, pilot_mode, pilot_mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 16

    # 5:sub_mode | Offset: 32, Length: 16, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    sub_mode = sub_mode_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 16))
    nmea2000Message.fields.append(NMEA2000Field('sub_mode', 'Sub Mode', None, None, sub_mode, sub_mode_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 16

    # 6:pilot_mode_data | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    pilot_mode_data = pilot_mode_data_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 8))
    nmea2000Message.fields.append(NMEA2000Field('pilot_mode_data', 'Pilot Mode Data', None, None, pilot_mode_data, pilot_mode_data_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 8

    # 7:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_65379(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65379."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # pilot_mode | Offset: 16, Length: 16, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'pilot_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Pilot Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SEATALK_PILOT_MODE_16(field.value)
    data_raw |= (field_value & 0xFFFF) << 16
    # sub_mode | Offset: 32, Length: 16, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'sub_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Sub Mode'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 32
    # pilot_mode_data | Offset: 48, Length: 8, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'pilot_mode_data')
    if field is None:
        raise Exception("Cant encode this message, missing 'Pilot Mode Data'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_65408() -> bool:
    """Return True if PGN 65408 is a fast PGN."""
    return False
def decode_pgn_65408(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65408."""
    nmea2000Message = NMEA2000Message(65408, 'airmarDepthQualityFactor', 'Airmar: Depth Quality Factor')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:sid | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:depth_quality_factor | Offset: 24, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    depth_quality_factor_raw = decode_int(_data_raw_, running_bit_offset, 4)
    depth_quality_factor = master_dict['AIRMAR_DEPTH_QUALITY_FACTOR'].get(depth_quality_factor_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('depth_quality_factor', 'Depth Quality Factor', None, None, depth_quality_factor, depth_quality_factor_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 6:reserved_28 | Offset: 28, Length: 36, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 28
    reserved_28 = reserved_28_raw = decode_int(_data_raw_, running_bit_offset, 36)
    nmea2000Message.fields.append(NMEA2000Field('reserved_28', 'Reserved', None, None, reserved_28, reserved_28_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 36

    return nmea2000Message

def encode_pgn_65408(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65408."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # sid | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # depth_quality_factor | Offset: 24, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'depth_quality_factor')
    if field is None:
        raise Exception("Cant encode this message, missing 'Depth Quality Factor'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIRMAR_DEPTH_QUALITY_FACTOR(field.value)
    data_raw |= (field_value & 0xF) << 24
    # reserved_28 | Offset: 28, Length: 36, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_28')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFF) << 28
    return data_raw


def is_fast_pgn_65409() -> bool:
    """Return True if PGN 65409 is a fast PGN."""
    return False
def decode_pgn_65409(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65409."""
    nmea2000Message = NMEA2000Message(65409, 'airmarSpeedPulseCount', 'Airmar: Speed Pulse Count')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:sid | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:duration_of_interval | Offset: 24, Length: 16, Signed: False Resolution: 0.001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    duration_of_interval_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.001)
    duration_of_interval = decode_time(duration_of_interval_raw)
    nmea2000Message.fields.append(NMEA2000Field('duration_of_interval', 'Duration of interval', None, 's', duration_of_interval, duration_of_interval_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    # 6:number_of_pulses_received | Offset: 40, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    number_of_pulses_received = number_of_pulses_received_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_pulses_received', 'Number of pulses received', None, None, number_of_pulses_received, number_of_pulses_received_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_65409(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65409."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # sid | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # duration_of_interval | Offset: 24, Length: 16, Resolution: 0.001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'duration_of_interval')
    if field is None:
        raise Exception("Cant encode this message, missing 'Duration of interval'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFF) << 24
    
    # number_of_pulses_received | Offset: 40, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_pulses_received')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of pulses received'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 40
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_65410() -> bool:
    """Return True if PGN 65410 is a fast PGN."""
    return False
def decode_pgn_65410(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65410."""
    nmea2000Message = NMEA2000Message(65410, 'airmarDeviceInformation', 'Airmar: Device Information')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:sid | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:internal_device_temperature | Offset: 24, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    internal_device_temperature = internal_device_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('internal_device_temperature', 'Internal Device Temperature', None, 'K', internal_device_temperature, internal_device_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:supply_voltage | Offset: 40, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    supply_voltage = supply_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('supply_voltage', 'Supply Voltage', None, 'V', supply_voltage, supply_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_65410(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65410."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # sid | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # internal_device_temperature | Offset: 24, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'internal_device_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Internal Device Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 24
    
    # supply_voltage | Offset: 40, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'supply_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Supply Voltage'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 40
    
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_65420() -> bool:
    """Return True if PGN 65420 is a fast PGN."""
    return False
def decode_pgn_65420(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65420."""
    nmea2000Message = NMEA2000Message(65420, 'simnetApUnknown3', 'Simnet: AP Unknown 3')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:a | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:b | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:c | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:d | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    d = d_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('d', 'D', None, None, d, d_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:e | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    e = e_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('e', 'E', None, None, e, e_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_65420(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65420."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # a | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # b | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # c | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # d | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'd')
    if field is None:
        raise Exception("Cant encode this message, missing 'D'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # e | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'e')
    if field is None:
        raise Exception("Cant encode this message, missing 'E'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_65480() -> bool:
    """Return True if PGN 65480 is a fast PGN."""
    return False
def decode_pgn_65480(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 65480."""
    nmea2000Message = NMEA2000Message(65480, 'simnetAutopilotMode', 'Simnet: Autopilot Mode')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 48, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 48)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 48

    return nmea2000Message

def encode_pgn_65480(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 65480."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 48, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFF) << 16
    return data_raw


def is_fast_pgn_126208() -> bool:
    """Return True if PGN 126208 is a fast PGN."""
    return True
# Complex PGN. number of matches: 8
def decode_pgn_126208(data_raw: int) -> NMEA2000Message:
    # nmeaRequestGroupFunction | Description: NMEA - Request group function
    if (
        (((data_raw >> 0) & 0xFF) == 0)
        ):
        return decode_pgn_126208_nmeaRequestGroupFunction(data_raw)
    
    # nmeaCommandGroupFunction | Description: NMEA - Command group function
    if (
        (((data_raw >> 0) & 0xFF) == 1)
        ):
        return decode_pgn_126208_nmeaCommandGroupFunction(data_raw)
    
    # nmeaAcknowledgeGroupFunction | Description: NMEA - Acknowledge group function
    if (
        (((data_raw >> 0) & 0xFF) == 2)
        ):
        return decode_pgn_126208_nmeaAcknowledgeGroupFunction(data_raw)
    
    # nmeaReadFieldsGroupFunction | Description: NMEA - Read Fields group function
    if (
        (((data_raw >> 0) & 0xFF) == 3)
        ):
        return decode_pgn_126208_nmeaReadFieldsGroupFunction(data_raw)
    
    # nmeaReadFieldsReplyGroupFunction | Description: NMEA - Read Fields reply group function
    if (
        (((data_raw >> 0) & 0xFF) == 4)
        ):
        return decode_pgn_126208_nmeaReadFieldsReplyGroupFunction(data_raw)
    
    # nmeaWriteFieldsGroupFunction | Description: NMEA - Write Fields group function
    if (
        (((data_raw >> 0) & 0xFF) == 5)
        ):
        return decode_pgn_126208_nmeaWriteFieldsGroupFunction(data_raw)
    
    # nmeaWriteFieldsReplyGroupFunction | Description: NMEA - Write Fields reply group function
    if (
        (((data_raw >> 0) & 0xFF) == 6)
        ):
        return decode_pgn_126208_nmeaWriteFieldsReplyGroupFunction(data_raw)
    
    return decode_pgn_126208_0x1ed000x1ee00StandardizedFastPacketAddressed(data_raw)
    
def decode_pgn_126208_0x1ed000x1ee00StandardizedFastPacketAddressed(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126208."""
    nmea2000Message = NMEA2000Message(126208, '0x1ed000x1ee00StandardizedFastPacketAddressed', '0x1ED00 - 0x1EE00: Standardized fast-packet addressed')
    running_bit_offset = 0
    # 1:data | Offset: 0, Length: 1784, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    data = data_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 1784))
    nmea2000Message.fields.append(NMEA2000Field('data', 'Data', None, None, data, data_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 1784

    return nmea2000Message

def encode_pgn_126208_0x1ed000x1ee00StandardizedFastPacketAddressed(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126208."""
    data_raw = 0
    # data | Offset: 0, Length: 1784, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'data')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data'")
    # Skipping fields longer than 256
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 0
    return data_raw

def decode_pgn_126208_nmeaRequestGroupFunction(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126208."""
    nmea2000Message = NMEA2000Message(126208, 'nmeaRequestGroupFunction', 'NMEA - Request group function')
    running_bit_offset = 0
    # 1:function_code | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 0, PartOfPrimaryKey: ,
    running_bit_offset = 0
    function_code_raw = decode_int(_data_raw_, running_bit_offset, 8)
    function_code = master_dict['GROUP_FUNCTION'].get(function_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('function_code', 'Function Code', "Request", None, function_code, function_code_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:pgn | Offset: 8, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    pgn = pgn_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('pgn', 'PGN', "Requested PGN", None, pgn, pgn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    # 3:transmission_interval | Offset: 32, Length: 32, Signed: False Resolution: 0.001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    transmission_interval_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.001)
    transmission_interval = decode_time(transmission_interval_raw)
    nmea2000Message.fields.append(NMEA2000Field('transmission_interval', 'Transmission interval', None, 's', transmission_interval, transmission_interval_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 4:transmission_interval_offset | Offset: 64, Length: 16, Signed: False Resolution: 0.01, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    transmission_interval_offset_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    transmission_interval_offset = decode_time(transmission_interval_offset_raw)
    nmea2000Message.fields.append(NMEA2000Field('transmission_interval_offset', 'Transmission interval offset', None, 's', transmission_interval_offset, transmission_interval_offset_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    # 5:number_of_parameters | Offset: 80, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    number_of_parameters = number_of_parameters_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_parameters', 'Number of Parameters', "How many parameter pairs will follow", None, number_of_parameters, number_of_parameters_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:parameter | Offset: 88, Length: 8, Signed: False Resolution: 1, Field Type: FIELD_INDEX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    raise Exception("FieldType (FIELD_INDEX) not supported")
    nmea2000Message.fields.append(NMEA2000Field('parameter', 'Parameter', "Parameter index", None, parameter, parameter_raw, None, FieldTypes.FIELD_INDEX, False))
    running_bit_offset += 8

    # 7:value | Offset: , Length: , Signed: False Resolution: , Field Type: VARIABLE, Match: , PartOfPrimaryKey: ,
    raise Exception("FieldType (VARIABLE) not supported")
    nmea2000Message.fields.append(NMEA2000Field('value', 'Value', "Parameter value", None, value, value_raw, None, FieldTypes.VARIABLE, False))
    

    return nmea2000Message

def encode_pgn_126208_nmeaRequestGroupFunction(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126208."""
    data_raw = 0
    # function_code | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'function_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Function Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GROUP_FUNCTION(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # pgn | Offset: 8, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pgn')
    if field is None:
        raise Exception("Cant encode this message, missing 'PGN'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 8
    # transmission_interval | Offset: 32, Length: 32, Resolution: 0.001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'transmission_interval')
    if field is None:
        raise Exception("Cant encode this message, missing 'Transmission interval'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFFFFFF) << 32
    
    # transmission_interval_offset | Offset: 64, Length: 16, Resolution: 0.01, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'transmission_interval_offset')
    if field is None:
        raise Exception("Cant encode this message, missing 'Transmission interval offset'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 64
    
    # number_of_parameters | Offset: 80, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_parameters')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of Parameters'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 80
    # parameter | Offset: 88, Length: 8, Resolution: 1, Field Type: FIELD_INDEX
    field = next(f for f in nmea2000Message.fields if f.id == 'parameter')
    if field is None:
        raise Exception("Cant encode this message, missing 'Parameter'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 88
    raise Exception ("PGN 126208 not supporting encoding for now as Value is missing BitLength or BitOffset")
    return data_raw

def decode_pgn_126208_nmeaCommandGroupFunction(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126208."""
    nmea2000Message = NMEA2000Message(126208, 'nmeaCommandGroupFunction', 'NMEA - Command group function')
    running_bit_offset = 0
    # 1:function_code | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1, PartOfPrimaryKey: ,
    running_bit_offset = 0
    function_code_raw = decode_int(_data_raw_, running_bit_offset, 8)
    function_code = master_dict['GROUP_FUNCTION'].get(function_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('function_code', 'Function Code', "Command", None, function_code, function_code_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:pgn | Offset: 8, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    pgn = pgn_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('pgn', 'PGN', "Commanded PGN", None, pgn, pgn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    # 3:priority | Offset: 32, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    priority_raw = decode_int(_data_raw_, running_bit_offset, 4)
    priority = master_dict['PRIORITY'].get(priority_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('priority', 'Priority', None, None, priority, priority_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 4:reserved_36 | Offset: 36, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 36
    reserved_36 = reserved_36_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_36', 'Reserved', None, None, reserved_36, reserved_36_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 5:number_of_parameters | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    number_of_parameters = number_of_parameters_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_parameters', 'Number of Parameters', "How many parameter pairs will follow", None, number_of_parameters, number_of_parameters_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:parameter | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: FIELD_INDEX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    raise Exception("FieldType (FIELD_INDEX) not supported")
    nmea2000Message.fields.append(NMEA2000Field('parameter', 'Parameter', "Parameter index", None, parameter, parameter_raw, None, FieldTypes.FIELD_INDEX, False))
    running_bit_offset += 8

    # 7:value | Offset: , Length: , Signed: False Resolution: , Field Type: VARIABLE, Match: , PartOfPrimaryKey: ,
    raise Exception("FieldType (VARIABLE) not supported")
    nmea2000Message.fields.append(NMEA2000Field('value', 'Value', "Parameter value", None, value, value_raw, None, FieldTypes.VARIABLE, False))
    

    return nmea2000Message

def encode_pgn_126208_nmeaCommandGroupFunction(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126208."""
    data_raw = 0
    # function_code | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'function_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Function Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GROUP_FUNCTION(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # pgn | Offset: 8, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pgn')
    if field is None:
        raise Exception("Cant encode this message, missing 'PGN'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 8
    # priority | Offset: 32, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'priority')
    if field is None:
        raise Exception("Cant encode this message, missing 'Priority'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_PRIORITY(field.value)
    data_raw |= (field_value & 0xF) << 32
    # reserved_36 | Offset: 36, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_36')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 36
    # number_of_parameters | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_parameters')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of Parameters'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # parameter | Offset: 48, Length: 8, Resolution: 1, Field Type: FIELD_INDEX
    field = next(f for f in nmea2000Message.fields if f.id == 'parameter')
    if field is None:
        raise Exception("Cant encode this message, missing 'Parameter'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    raise Exception ("PGN 126208 not supporting encoding for now as Value is missing BitLength or BitOffset")
    return data_raw

def decode_pgn_126208_nmeaAcknowledgeGroupFunction(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126208."""
    nmea2000Message = NMEA2000Message(126208, 'nmeaAcknowledgeGroupFunction', 'NMEA - Acknowledge group function')
    running_bit_offset = 0
    # 1:function_code | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 2, PartOfPrimaryKey: ,
    running_bit_offset = 0
    function_code_raw = decode_int(_data_raw_, running_bit_offset, 8)
    function_code = master_dict['GROUP_FUNCTION'].get(function_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('function_code', 'Function Code', "Acknowledge", None, function_code, function_code_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:pgn | Offset: 8, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    pgn = pgn_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('pgn', 'PGN', "Commanded PGN", None, pgn, pgn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    # 3:pgn_error_code | Offset: 32, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    pgn_error_code_raw = decode_int(_data_raw_, running_bit_offset, 4)
    pgn_error_code = master_dict['PGN_ERROR_CODE'].get(pgn_error_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('pgn_error_code', 'PGN error code', None, None, pgn_error_code, pgn_error_code_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 4:transmission_interval_priority_error_code | Offset: 36, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 36
    transmission_interval_priority_error_code_raw = decode_int(_data_raw_, running_bit_offset, 4)
    transmission_interval_priority_error_code = master_dict['TRANSMISSION_INTERVAL'].get(transmission_interval_priority_error_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('transmission_interval_priority_error_code', 'Transmission interval/Priority error code', None, None, transmission_interval_priority_error_code, transmission_interval_priority_error_code_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 5:number_of_parameters | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    number_of_parameters = number_of_parameters_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_parameters', 'Number of Parameters', None, None, number_of_parameters, number_of_parameters_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:parameter | Offset: 48, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    parameter_raw = decode_int(_data_raw_, running_bit_offset, 4)
    parameter = master_dict['PARAMETER_FIELD'].get(parameter_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('parameter', 'Parameter', None, None, parameter, parameter_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    return nmea2000Message

def encode_pgn_126208_nmeaAcknowledgeGroupFunction(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126208."""
    data_raw = 0
    # function_code | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'function_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Function Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GROUP_FUNCTION(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # pgn | Offset: 8, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pgn')
    if field is None:
        raise Exception("Cant encode this message, missing 'PGN'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 8
    # pgn_error_code | Offset: 32, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'pgn_error_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'PGN error code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_PGN_ERROR_CODE(field.value)
    data_raw |= (field_value & 0xF) << 32
    # transmission_interval_priority_error_code | Offset: 36, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'transmission_interval_priority_error_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Transmission interval/Priority error code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_TRANSMISSION_INTERVAL(field.value)
    data_raw |= (field_value & 0xF) << 36
    # number_of_parameters | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_parameters')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of Parameters'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # parameter | Offset: 48, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'parameter')
    if field is None:
        raise Exception("Cant encode this message, missing 'Parameter'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_PARAMETER_FIELD(field.value)
    data_raw |= (field_value & 0xF) << 48
    return data_raw

def decode_pgn_126208_nmeaReadFieldsGroupFunction(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126208."""
    nmea2000Message = NMEA2000Message(126208, 'nmeaReadFieldsGroupFunction', 'NMEA - Read Fields group function')
    running_bit_offset = 0
    # 1:function_code | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 3, PartOfPrimaryKey: ,
    running_bit_offset = 0
    function_code_raw = decode_int(_data_raw_, running_bit_offset, 8)
    function_code = master_dict['GROUP_FUNCTION'].get(function_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('function_code', 'Function Code', "Read Fields", None, function_code, function_code_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:pgn | Offset: 8, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    pgn = pgn_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('pgn', 'PGN', "Commanded PGN", None, pgn, pgn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    # 3:manufacturer_code | Offset: 32, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 32
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Only in PGN when Commanded PGN is proprietary", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 4:reserved_ | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    reserved_ = reserved__raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_', 'Reserved', "Only in PGN when Commanded PGN is proprietary", None, reserved_, reserved__raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 5:industry_code | Offset: , Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Only in PGN when Commanded PGN is proprietary", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 6:unique_id | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    unique_id = unique_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unique_id', 'Unique ID', None, None, unique_id, unique_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:number_of_selection_pairs | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    number_of_selection_pairs = number_of_selection_pairs_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_selection_pairs', 'Number of Selection Pairs', None, None, number_of_selection_pairs, number_of_selection_pairs_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:number_of_parameters | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    number_of_parameters = number_of_parameters_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_parameters', 'Number of Parameters', None, None, number_of_parameters, number_of_parameters_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:selection_parameter | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: FIELD_INDEX, Match: , PartOfPrimaryKey: ,
    raise Exception("FieldType (FIELD_INDEX) not supported")
    nmea2000Message.fields.append(NMEA2000Field('selection_parameter', 'Selection Parameter', "Parameter index", None, selection_parameter, selection_parameter_raw, None, FieldTypes.FIELD_INDEX, False))
    running_bit_offset += 8

    # 10:selection_value | Offset: , Length: , Signed: False Resolution: , Field Type: VARIABLE, Match: , PartOfPrimaryKey: ,
    raise Exception("FieldType (VARIABLE) not supported")
    nmea2000Message.fields.append(NMEA2000Field('selection_value', 'Selection Value', None, None, selection_value, selection_value_raw, None, FieldTypes.VARIABLE, False))
    

    # 11:parameter | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: FIELD_INDEX, Match: , PartOfPrimaryKey: ,
    raise Exception("FieldType (FIELD_INDEX) not supported")
    nmea2000Message.fields.append(NMEA2000Field('parameter', 'Parameter', "Parameter index", None, parameter, parameter_raw, None, FieldTypes.FIELD_INDEX, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_126208_nmeaReadFieldsGroupFunction(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126208."""
    data_raw = 0
    # function_code | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'function_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Function Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GROUP_FUNCTION(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # pgn | Offset: 8, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pgn')
    if field is None:
        raise Exception("Cant encode this message, missing 'PGN'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 8
    # manufacturer_code | Offset: 32, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 32
    raise Exception ("PGN 126208 not supporting encoding for now as Reserved is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Industry Code is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Unique ID is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Number of Selection Pairs is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Number of Parameters is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Selection Parameter is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Selection Value is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Parameter is missing BitLength or BitOffset")
    return data_raw

def decode_pgn_126208_nmeaReadFieldsReplyGroupFunction(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126208."""
    nmea2000Message = NMEA2000Message(126208, 'nmeaReadFieldsReplyGroupFunction', 'NMEA - Read Fields reply group function')
    running_bit_offset = 0
    # 1:function_code | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: ,
    running_bit_offset = 0
    function_code_raw = decode_int(_data_raw_, running_bit_offset, 8)
    function_code = master_dict['GROUP_FUNCTION'].get(function_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('function_code', 'Function Code', "Read Fields Reply", None, function_code, function_code_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:pgn | Offset: 8, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    pgn = pgn_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('pgn', 'PGN', "Commanded PGN", None, pgn, pgn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    # 3:manufacturer_code | Offset: 32, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 32
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Only in PGN when Commanded PGN is proprietary", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 4:reserved_ | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    reserved_ = reserved__raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_', 'Reserved', "Only in PGN when Commanded PGN is proprietary", None, reserved_, reserved__raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 5:industry_code | Offset: , Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Only in PGN when Commanded PGN is proprietary", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 6:unique_id | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    unique_id = unique_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unique_id', 'Unique ID', None, None, unique_id, unique_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:number_of_selection_pairs | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    number_of_selection_pairs = number_of_selection_pairs_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_selection_pairs', 'Number of Selection Pairs', None, None, number_of_selection_pairs, number_of_selection_pairs_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:number_of_parameters | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    number_of_parameters = number_of_parameters_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_parameters', 'Number of Parameters', None, None, number_of_parameters, number_of_parameters_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:selection_parameter | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: FIELD_INDEX, Match: , PartOfPrimaryKey: ,
    raise Exception("FieldType (FIELD_INDEX) not supported")
    nmea2000Message.fields.append(NMEA2000Field('selection_parameter', 'Selection Parameter', "Parameter index", None, selection_parameter, selection_parameter_raw, None, FieldTypes.FIELD_INDEX, False))
    running_bit_offset += 8

    # 10:selection_value | Offset: , Length: , Signed: False Resolution: , Field Type: VARIABLE, Match: , PartOfPrimaryKey: ,
    raise Exception("FieldType (VARIABLE) not supported")
    nmea2000Message.fields.append(NMEA2000Field('selection_value', 'Selection Value', None, None, selection_value, selection_value_raw, None, FieldTypes.VARIABLE, False))
    

    # 11:parameter | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: FIELD_INDEX, Match: , PartOfPrimaryKey: ,
    raise Exception("FieldType (FIELD_INDEX) not supported")
    nmea2000Message.fields.append(NMEA2000Field('parameter', 'Parameter', "Parameter index", None, parameter, parameter_raw, None, FieldTypes.FIELD_INDEX, False))
    running_bit_offset += 8

    # 12:value | Offset: , Length: , Signed: False Resolution: , Field Type: VARIABLE, Match: , PartOfPrimaryKey: ,
    raise Exception("FieldType (VARIABLE) not supported")
    nmea2000Message.fields.append(NMEA2000Field('value', 'Value', None, None, value, value_raw, None, FieldTypes.VARIABLE, False))
    

    return nmea2000Message

def encode_pgn_126208_nmeaReadFieldsReplyGroupFunction(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126208."""
    data_raw = 0
    # function_code | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'function_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Function Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GROUP_FUNCTION(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # pgn | Offset: 8, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pgn')
    if field is None:
        raise Exception("Cant encode this message, missing 'PGN'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 8
    # manufacturer_code | Offset: 32, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 32
    raise Exception ("PGN 126208 not supporting encoding for now as Reserved is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Industry Code is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Unique ID is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Number of Selection Pairs is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Number of Parameters is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Selection Parameter is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Selection Value is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Parameter is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Value is missing BitLength or BitOffset")
    return data_raw

def decode_pgn_126208_nmeaWriteFieldsGroupFunction(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126208."""
    nmea2000Message = NMEA2000Message(126208, 'nmeaWriteFieldsGroupFunction', 'NMEA - Write Fields group function')
    running_bit_offset = 0
    # 1:function_code | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 5, PartOfPrimaryKey: ,
    running_bit_offset = 0
    function_code_raw = decode_int(_data_raw_, running_bit_offset, 8)
    function_code = master_dict['GROUP_FUNCTION'].get(function_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('function_code', 'Function Code', "Write Fields", None, function_code, function_code_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:pgn | Offset: 8, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    pgn = pgn_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('pgn', 'PGN', "Commanded PGN", None, pgn, pgn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    # 3:manufacturer_code | Offset: 32, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 32
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Only in PGN when Commanded PGN is proprietary", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 4:reserved_ | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    reserved_ = reserved__raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_', 'Reserved', "Only in PGN when Commanded PGN is proprietary", None, reserved_, reserved__raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 5:industry_code | Offset: , Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Only in PGN when Commanded PGN is proprietary", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 6:unique_id | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    unique_id = unique_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unique_id', 'Unique ID', None, None, unique_id, unique_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:number_of_selection_pairs | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    number_of_selection_pairs = number_of_selection_pairs_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_selection_pairs', 'Number of Selection Pairs', None, None, number_of_selection_pairs, number_of_selection_pairs_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:number_of_parameters | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    number_of_parameters = number_of_parameters_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_parameters', 'Number of Parameters', None, None, number_of_parameters, number_of_parameters_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:selection_parameter | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: FIELD_INDEX, Match: , PartOfPrimaryKey: ,
    raise Exception("FieldType (FIELD_INDEX) not supported")
    nmea2000Message.fields.append(NMEA2000Field('selection_parameter', 'Selection Parameter', "Parameter index", None, selection_parameter, selection_parameter_raw, None, FieldTypes.FIELD_INDEX, False))
    running_bit_offset += 8

    # 10:selection_value | Offset: , Length: , Signed: False Resolution: , Field Type: VARIABLE, Match: , PartOfPrimaryKey: ,
    raise Exception("FieldType (VARIABLE) not supported")
    nmea2000Message.fields.append(NMEA2000Field('selection_value', 'Selection Value', None, None, selection_value, selection_value_raw, None, FieldTypes.VARIABLE, False))
    

    # 11:parameter | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: FIELD_INDEX, Match: , PartOfPrimaryKey: ,
    raise Exception("FieldType (FIELD_INDEX) not supported")
    nmea2000Message.fields.append(NMEA2000Field('parameter', 'Parameter', "Parameter index", None, parameter, parameter_raw, None, FieldTypes.FIELD_INDEX, False))
    running_bit_offset += 8

    # 12:value | Offset: , Length: , Signed: False Resolution: , Field Type: VARIABLE, Match: , PartOfPrimaryKey: ,
    raise Exception("FieldType (VARIABLE) not supported")
    nmea2000Message.fields.append(NMEA2000Field('value', 'Value', None, None, value, value_raw, None, FieldTypes.VARIABLE, False))
    

    return nmea2000Message

def encode_pgn_126208_nmeaWriteFieldsGroupFunction(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126208."""
    data_raw = 0
    # function_code | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'function_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Function Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GROUP_FUNCTION(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # pgn | Offset: 8, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pgn')
    if field is None:
        raise Exception("Cant encode this message, missing 'PGN'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 8
    # manufacturer_code | Offset: 32, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 32
    raise Exception ("PGN 126208 not supporting encoding for now as Reserved is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Industry Code is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Unique ID is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Number of Selection Pairs is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Number of Parameters is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Selection Parameter is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Selection Value is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Parameter is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Value is missing BitLength or BitOffset")
    return data_raw

def decode_pgn_126208_nmeaWriteFieldsReplyGroupFunction(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126208."""
    nmea2000Message = NMEA2000Message(126208, 'nmeaWriteFieldsReplyGroupFunction', 'NMEA - Write Fields reply group function')
    running_bit_offset = 0
    # 1:function_code | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 6, PartOfPrimaryKey: ,
    running_bit_offset = 0
    function_code_raw = decode_int(_data_raw_, running_bit_offset, 8)
    function_code = master_dict['GROUP_FUNCTION'].get(function_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('function_code', 'Function Code', "Write Fields Reply", None, function_code, function_code_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:pgn | Offset: 8, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    pgn = pgn_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('pgn', 'PGN', "Commanded PGN", None, pgn, pgn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    # 3:manufacturer_code | Offset: 32, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 32
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Only in PGN when Commanded PGN is proprietary", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 4:reserved_ | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    reserved_ = reserved__raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_', 'Reserved', "Only in PGN when Commanded PGN is proprietary", None, reserved_, reserved__raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 5:industry_code | Offset: , Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Only in PGN when Commanded PGN is proprietary", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 6:unique_id | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    unique_id = unique_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unique_id', 'Unique ID', None, None, unique_id, unique_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:number_of_selection_pairs | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    number_of_selection_pairs = number_of_selection_pairs_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_selection_pairs', 'Number of Selection Pairs', None, None, number_of_selection_pairs, number_of_selection_pairs_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:number_of_parameters | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    number_of_parameters = number_of_parameters_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_parameters', 'Number of Parameters', None, None, number_of_parameters, number_of_parameters_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:selection_parameter | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: FIELD_INDEX, Match: , PartOfPrimaryKey: ,
    raise Exception("FieldType (FIELD_INDEX) not supported")
    nmea2000Message.fields.append(NMEA2000Field('selection_parameter', 'Selection Parameter', "Parameter index", None, selection_parameter, selection_parameter_raw, None, FieldTypes.FIELD_INDEX, False))
    running_bit_offset += 8

    # 10:selection_value | Offset: , Length: , Signed: False Resolution: , Field Type: VARIABLE, Match: , PartOfPrimaryKey: ,
    raise Exception("FieldType (VARIABLE) not supported")
    nmea2000Message.fields.append(NMEA2000Field('selection_value', 'Selection Value', None, None, selection_value, selection_value_raw, None, FieldTypes.VARIABLE, False))
    

    # 11:parameter | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: FIELD_INDEX, Match: , PartOfPrimaryKey: ,
    raise Exception("FieldType (FIELD_INDEX) not supported")
    nmea2000Message.fields.append(NMEA2000Field('parameter', 'Parameter', "Parameter index", None, parameter, parameter_raw, None, FieldTypes.FIELD_INDEX, False))
    running_bit_offset += 8

    # 12:value | Offset: , Length: , Signed: False Resolution: , Field Type: VARIABLE, Match: , PartOfPrimaryKey: ,
    raise Exception("FieldType (VARIABLE) not supported")
    nmea2000Message.fields.append(NMEA2000Field('value', 'Value', None, None, value, value_raw, None, FieldTypes.VARIABLE, False))
    

    return nmea2000Message

def encode_pgn_126208_nmeaWriteFieldsReplyGroupFunction(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126208."""
    data_raw = 0
    # function_code | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'function_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Function Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GROUP_FUNCTION(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # pgn | Offset: 8, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pgn')
    if field is None:
        raise Exception("Cant encode this message, missing 'PGN'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 8
    # manufacturer_code | Offset: 32, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 32
    raise Exception ("PGN 126208 not supporting encoding for now as Reserved is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Industry Code is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Unique ID is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Number of Selection Pairs is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Number of Parameters is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Selection Parameter is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Selection Value is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Parameter is missing BitLength or BitOffset")
    raise Exception ("PGN 126208 not supporting encoding for now as Value is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_126464() -> bool:
    """Return True if PGN 126464 is a fast PGN."""
    return True
def decode_pgn_126464(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126464."""
    nmea2000Message = NMEA2000Message(126464, 'pgnListTransmitAndReceive', 'PGN List (Transmit and Receive)')
    running_bit_offset = 0
    # 1:function_code | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    function_code_raw = decode_int(_data_raw_, running_bit_offset, 8)
    function_code = master_dict['PGN_LIST_FUNCTION'].get(function_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('function_code', 'Function Code', None, None, function_code, function_code_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:pgn | Offset: 8, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    pgn = pgn_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('pgn', 'PGN', None, None, pgn, pgn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    return nmea2000Message

def encode_pgn_126464(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126464."""
    data_raw = 0
    # function_code | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'function_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Function Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_PGN_LIST_FUNCTION(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # pgn | Offset: 8, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pgn')
    if field is None:
        raise Exception("Cant encode this message, missing 'PGN'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 8
    return data_raw


def is_fast_pgn_126720() -> bool:
    """Return True if PGN 126720 is a fast PGN."""
    return True
# Complex PGN. number of matches: 30
def decode_pgn_126720(data_raw: int) -> NMEA2000Message:
    # seatalk1PilotMode | Description: Seatalk1: Pilot Mode
    if (
        (((data_raw >> 0) & 0x7FF) == 1851) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFFFF) == 33264) and
        (((data_raw >> 32) & 0xFF) == 132)
        ):
        return decode_pgn_126720_seatalk1PilotMode(data_raw)
    
    # fusionMediaControl | Description: Fusion: Media Control
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 3)
        ):
        return decode_pgn_126720_fusionMediaControl(data_raw)
    
    # fusionSiriusControl | Description: Fusion: Sirius Control
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 30)
        ):
        return decode_pgn_126720_fusionSiriusControl(data_raw)
    
    # fusionRequestStatus | Description: Fusion: Request Status
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 1)
        ):
        return decode_pgn_126720_fusionRequestStatus(data_raw)
    
    # fusionSetSource | Description: Fusion: Set Source
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 2)
        ):
        return decode_pgn_126720_fusionSetSource(data_raw)
    
    # fusionSetMute | Description: Fusion: Set Mute
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 23)
        ):
        return decode_pgn_126720_fusionSetMute(data_raw)
    
    # fusionSetZoneVolume | Description: Fusion: Set Zone Volume
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 24)
        ):
        return decode_pgn_126720_fusionSetZoneVolume(data_raw)
    
    # fusionSetAllVolumes | Description: Fusion: Set All Volumes
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 25)
        ):
        return decode_pgn_126720_fusionSetAllVolumes(data_raw)
    
    # seatalk1Keystroke | Description: Seatalk1: Keystroke
    if (
        (((data_raw >> 0) & 0x7FF) == 1851) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFFFF) == 33264) and
        (((data_raw >> 32) & 0xFF) == 134)
        ):
        return decode_pgn_126720_seatalk1Keystroke(data_raw)
    
    # seatalk1DeviceIdentification | Description: Seatalk1: Device Identification
    if (
        (((data_raw >> 0) & 0x7FF) == 1851) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFFFF) == 33264) and
        (((data_raw >> 32) & 0xFF) == 144)
        ):
        return decode_pgn_126720_seatalk1DeviceIdentification(data_raw)
    
    # seatalk1DisplayBrightness | Description: Seatalk1: Display Brightness
    if (
        (((data_raw >> 0) & 0x7FF) == 1851) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFFFF) == 3212) and
        (((data_raw >> 48) & 0xFF) == 0)
        ):
        return decode_pgn_126720_seatalk1DisplayBrightness(data_raw)
    
    # seatalk1DisplayColor | Description: Seatalk1: Display Color
    if (
        (((data_raw >> 0) & 0x7FF) == 1851) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFFFF) == 3212) and
        (((data_raw >> 48) & 0xFF) == 1)
        ):
        return decode_pgn_126720_seatalk1DisplayColor(data_raw)
    
    # airmarAttitudeOffset | Description: Airmar: Attitude Offset
    if (
        (((data_raw >> 0) & 0x7FF) == 135) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 32)
        ):
        return decode_pgn_126720_airmarAttitudeOffset(data_raw)
    
    # airmarCalibrateCompass | Description: Airmar: Calibrate Compass
    if (
        (((data_raw >> 0) & 0x7FF) == 135) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 33)
        ):
        return decode_pgn_126720_airmarCalibrateCompass(data_raw)
    
    # airmarTrueWindOptions | Description: Airmar: True Wind Options
    if (
        (((data_raw >> 0) & 0x7FF) == 135) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 34)
        ):
        return decode_pgn_126720_airmarTrueWindOptions(data_raw)
    
    # airmarSimulateMode | Description: Airmar: Simulate Mode
    if (
        (((data_raw >> 0) & 0x7FF) == 135) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 35)
        ):
        return decode_pgn_126720_airmarSimulateMode(data_raw)
    
    # airmarCalibrateDepth | Description: Airmar: Calibrate Depth
    if (
        (((data_raw >> 0) & 0x7FF) == 135) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 40)
        ):
        return decode_pgn_126720_airmarCalibrateDepth(data_raw)
    
    # airmarCalibrateSpeed | Description: Airmar: Calibrate Speed
    if (
        (((data_raw >> 0) & 0x7FF) == 135) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 41)
        ):
        return decode_pgn_126720_airmarCalibrateSpeed(data_raw)
    
    # airmarCalibrateTemperature | Description: Airmar: Calibrate Temperature
    if (
        (((data_raw >> 0) & 0x7FF) == 135) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 42)
        ):
        return decode_pgn_126720_airmarCalibrateTemperature(data_raw)
    
    # airmarSpeedFilterNone | Description: Airmar: Speed Filter None
    if (
        (((data_raw >> 0) & 0x7FF) == 135) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 43) and
        (((data_raw >> 24) & 0xF) == 0)
        ):
        return decode_pgn_126720_airmarSpeedFilterNone(data_raw)
    
    # airmarSpeedFilterIir | Description: Airmar: Speed Filter IIR
    if (
        (((data_raw >> 0) & 0x7FF) == 135) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 43) and
        (((data_raw >> 24) & 0xF) == 1)
        ):
        return decode_pgn_126720_airmarSpeedFilterIir(data_raw)
    
    # airmarTemperatureFilterNone | Description: Airmar: Temperature Filter None
    if (
        (((data_raw >> 0) & 0x7FF) == 135) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 44) and
        (((data_raw >> 24) & 0xF) == 0)
        ):
        return decode_pgn_126720_airmarTemperatureFilterNone(data_raw)
    
    # airmarTemperatureFilterIir | Description: Airmar: Temperature Filter IIR
    if (
        (((data_raw >> 0) & 0x7FF) == 135) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 44) and
        (((data_raw >> 24) & 0xF) == 1)
        ):
        return decode_pgn_126720_airmarTemperatureFilterIir(data_raw)
    
    # airmarNmea2000Options | Description: Airmar: NMEA 2000 options
    if (
        (((data_raw >> 0) & 0x7FF) == 135) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 46)
        ):
        return decode_pgn_126720_airmarNmea2000Options(data_raw)
    
    # airmarAddressableMultiFrame | Description: Airmar: Addressable Multi-Frame
    if (
        (((data_raw >> 0) & 0x7FF) == 135) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_126720_airmarAddressableMultiFrame(data_raw)
    
    # maretronSlaveResponse | Description: Maretron: Slave Response
    if (
        (((data_raw >> 0) & 0x7FF) == 137) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_126720_maretronSlaveResponse(data_raw)
    
    # garminDayMode | Description: Garmin: Day Mode
    if (
        (((data_raw >> 0) & 0x7FF) == 229) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 222) and
        (((data_raw >> 24) & 0xFF) == 5) and
        (((data_raw >> 32) & 0xFF) == 5) and
        (((data_raw >> 40) & 0xFF) == 5) and
        (((data_raw >> 64) & 0xFF) == 0)
        ):
        return decode_pgn_126720_garminDayMode(data_raw)
    
    # garminNightMode | Description: Garmin: Night Mode
    if (
        (((data_raw >> 0) & 0x7FF) == 229) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 222) and
        (((data_raw >> 24) & 0xFF) == 5) and
        (((data_raw >> 32) & 0xFF) == 5) and
        (((data_raw >> 40) & 0xFF) == 5) and
        (((data_raw >> 64) & 0xFF) == 1)
        ):
        return decode_pgn_126720_garminNightMode(data_raw)
    
    # garminColorMode | Description: Garmin: Color mode
    if (
        (((data_raw >> 0) & 0x7FF) == 229) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 222) and
        (((data_raw >> 24) & 0xFF) == 5) and
        (((data_raw >> 32) & 0xFF) == 5) and
        (((data_raw >> 40) & 0xFF) == 5) and
        (((data_raw >> 64) & 0xFF) == 13)
        ):
        return decode_pgn_126720_garminColorMode(data_raw)
    
    return decode_pgn_126720_0x1ef000x1efffManufacturerProprietaryFastPacketAddressed(data_raw)
    
def decode_pgn_126720_0x1ef000x1efffManufacturerProprietaryFastPacketAddressed(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, '0x1ef000x1efffManufacturerProprietaryFastPacketAddressed', '0x1EF00-0x1EFFF: Manufacturer Proprietary fast-packet addressed')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', None, None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', None, None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:data | Offset: 16, Length: 1768, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    data = data_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 1768))
    nmea2000Message.fields.append(NMEA2000Field('data', 'Data', None, None, data, data_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 1768

    return nmea2000Message

def encode_pgn_126720_0x1ef000x1efffManufacturerProprietaryFastPacketAddressed(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # data | Offset: 16, Length: 1768, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'data')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data'")
    # Skipping fields longer than 256
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 16
    return data_raw

def decode_pgn_126720_seatalk1PilotMode(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'seatalk1PilotMode', 'Seatalk1: Pilot Mode')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1851, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Raymarine", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: 33264, PartOfPrimaryKey: True,
    running_bit_offset = 16
    proprietary_id = proprietary_id_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "0x81f0", None, proprietary_id, proprietary_id_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 16

    # 5:command | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 132, PartOfPrimaryKey: ,
    running_bit_offset = 32
    command = command_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('command', 'command', "0x84", None, command, command_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:unknown_1 | Offset: 40, Length: 24, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    unknown_1 = unknown_1_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 24))
    nmea2000Message.fields.append(NMEA2000Field('unknown_1', 'Unknown 1', None, None, unknown_1, unknown_1_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 24

    # 7:pilot_mode | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    pilot_mode_raw = decode_int(_data_raw_, running_bit_offset, 8)
    pilot_mode = master_dict['SEATALK_PILOT_MODE'].get(pilot_mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('pilot_mode', 'Pilot Mode', None, None, pilot_mode, pilot_mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 8:sub_mode | Offset: 72, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    sub_mode = sub_mode_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sub_mode', 'Sub Mode', None, None, sub_mode, sub_mode_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:pilot_mode_data | Offset: 80, Length: 8, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    pilot_mode_data = pilot_mode_data_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 8))
    nmea2000Message.fields.append(NMEA2000Field('pilot_mode_data', 'Pilot Mode Data', None, None, pilot_mode_data, pilot_mode_data_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 8

    # 10:unknown_2 | Offset: 88, Length: 80, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    unknown_2 = unknown_2_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 80))
    nmea2000Message.fields.append(NMEA2000Field('unknown_2', 'Unknown 2', None, None, unknown_2, unknown_2_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 80

    return nmea2000Message

def encode_pgn_126720_seatalk1PilotMode(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # command | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'command')
    if field is None:
        raise Exception("Cant encode this message, missing 'command'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # unknown_1 | Offset: 40, Length: 24, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown 1'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 40
    # pilot_mode | Offset: 64, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'pilot_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Pilot Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SEATALK_PILOT_MODE(field.value)
    data_raw |= (field_value & 0xFF) << 64
    # sub_mode | Offset: 72, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sub_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Sub Mode'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 72
    # pilot_mode_data | Offset: 80, Length: 8, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'pilot_mode_data')
    if field is None:
        raise Exception("Cant encode this message, missing 'Pilot Mode Data'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 80
    # unknown_2 | Offset: 88, Length: 80, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown_2')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown 2'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFF) << 88
    return data_raw

def decode_pgn_126720_fusionMediaControl(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'fusionMediaControl', 'Fusion: Media Control')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 3, PartOfPrimaryKey: True,
    running_bit_offset = 16
    proprietary_id = proprietary_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Media Control", None, proprietary_id, proprietary_id_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 5:unknown | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    unknown = unknown_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unknown', 'Unknown', None, None, unknown, unknown_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:source_id | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    source_id = source_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('source_id', 'Source ID', None, None, source_id, source_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:command | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    command_raw = decode_int(_data_raw_, running_bit_offset, 8)
    command = master_dict['FUSION_COMMAND'].get(command_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('command', 'Command', None, None, command, command_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_126720_fusionMediaControl(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # unknown | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # source_id | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'source_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # command | Offset: 40, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'command')
    if field is None:
        raise Exception("Cant encode this message, missing 'Command'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 40
    return data_raw

def decode_pgn_126720_fusionSiriusControl(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'fusionSiriusControl', 'Fusion: Sirius Control')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 30, PartOfPrimaryKey: True,
    running_bit_offset = 16
    proprietary_id = proprietary_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Sirius Control", None, proprietary_id, proprietary_id_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 5:unknown | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    unknown = unknown_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unknown', 'Unknown', None, None, unknown, unknown_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:source_id | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    source_id = source_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('source_id', 'Source ID', None, None, source_id, source_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:command | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    command_raw = decode_int(_data_raw_, running_bit_offset, 8)
    command = master_dict['FUSION_SIRIUS_COMMAND'].get(command_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('command', 'Command', None, None, command, command_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_126720_fusionSiriusControl(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # unknown | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # source_id | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'source_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # command | Offset: 40, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'command')
    if field is None:
        raise Exception("Cant encode this message, missing 'Command'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_SIRIUS_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 40
    return data_raw

def decode_pgn_126720_fusionRequestStatus(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'fusionRequestStatus', 'Fusion: Request Status')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1, PartOfPrimaryKey: ,
    running_bit_offset = 16
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['FUSION_MESSAGE_ID'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Request Status", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:unknown | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    unknown = unknown_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unknown', 'Unknown', None, None, unknown, unknown_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_126720_fusionRequestStatus(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # unknown | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    return data_raw

def decode_pgn_126720_fusionSetSource(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'fusionSetSource', 'Fusion: Set Source')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 2, PartOfPrimaryKey: ,
    running_bit_offset = 16
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['FUSION_MESSAGE_ID'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Source", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:unknown | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    unknown = unknown_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unknown', 'Unknown', None, None, unknown, unknown_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:source_id | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    source_id = source_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('source_id', 'Source ID', None, None, source_id, source_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_126720_fusionSetSource(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # unknown | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # source_id | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'source_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    return data_raw

def decode_pgn_126720_fusionSetMute(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'fusionSetMute', 'Fusion: Set Mute')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 23, PartOfPrimaryKey: ,
    running_bit_offset = 16
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['FUSION_MESSAGE_ID'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Mute", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:command | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    command_raw = decode_int(_data_raw_, running_bit_offset, 8)
    command = master_dict['FUSION_MUTE_COMMAND'].get(command_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('command', 'Command', None, None, command, command_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_126720_fusionSetMute(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # command | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'command')
    if field is None:
        raise Exception("Cant encode this message, missing 'Command'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MUTE_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 24
    return data_raw

def decode_pgn_126720_fusionSetZoneVolume(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'fusionSetZoneVolume', 'Fusion: Set Zone Volume')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 24, PartOfPrimaryKey: ,
    running_bit_offset = 16
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['FUSION_MESSAGE_ID'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Set Zone Volume", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:unknown | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    unknown = unknown_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unknown', 'Unknown', None, None, unknown, unknown_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:zone | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    zone = zone_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone', 'Zone', None, None, zone, zone_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:volume | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    volume = volume_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('volume', 'Volume', None, None, volume, volume_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_126720_fusionSetZoneVolume(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # unknown | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # zone | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zone')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # volume | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'volume')
    if field is None:
        raise Exception("Cant encode this message, missing 'Volume'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    return data_raw

def decode_pgn_126720_fusionSetAllVolumes(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'fusionSetAllVolumes', 'Fusion: Set All Volumes')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 25, PartOfPrimaryKey: ,
    running_bit_offset = 16
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['FUSION_MESSAGE_ID'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Set All Volumes", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:unknown | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    unknown = unknown_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unknown', 'Unknown', None, None, unknown, unknown_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:zone1 | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    zone1 = zone1_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone1', 'Zone1', None, None, zone1, zone1_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:zone2 | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    zone2 = zone2_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone2', 'Zone2', None, None, zone2, zone2_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:zone3 | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    zone3 = zone3_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone3', 'Zone3', None, None, zone3, zone3_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:zone4 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    zone4 = zone4_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone4', 'Zone4', None, None, zone4, zone4_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_126720_fusionSetAllVolumes(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # unknown | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # zone1 | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zone1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone1'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # zone2 | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zone2')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone2'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # zone3 | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zone3')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone3'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # zone4 | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zone4')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone4'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw

def decode_pgn_126720_seatalk1Keystroke(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'seatalk1Keystroke', 'Seatalk1: Keystroke')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1851, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Raymarine", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: 33264, PartOfPrimaryKey: True,
    running_bit_offset = 16
    proprietary_id = proprietary_id_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "0x81f0", None, proprietary_id, proprietary_id_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 16

    # 5:command | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 134, PartOfPrimaryKey: ,
    running_bit_offset = 32
    command = command_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('command', 'command', "0x86", None, command, command_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:device | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    device = device_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('device', 'device', None, None, device, device_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:key | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    key_raw = decode_int(_data_raw_, running_bit_offset, 8)
    key = master_dict['SEATALK_KEYSTROKE'].get(key_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('key', 'key', None, None, key, key_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 8:keyinverted | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    keyinverted = keyinverted_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('keyinverted', 'keyInverted', "Bit negated version of key", None, keyinverted, keyinverted_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:unknown_data | Offset: 64, Length: 112, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    unknown_data = unknown_data_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 112))
    nmea2000Message.fields.append(NMEA2000Field('unknown_data', 'Unknown data', None, None, unknown_data, unknown_data_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 112

    return nmea2000Message

def encode_pgn_126720_seatalk1Keystroke(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # command | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'command')
    if field is None:
        raise Exception("Cant encode this message, missing 'command'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # device | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'device')
    if field is None:
        raise Exception("Cant encode this message, missing 'device'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # key | Offset: 48, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'key')
    if field is None:
        raise Exception("Cant encode this message, missing 'key'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SEATALK_KEYSTROKE(field.value)
    data_raw |= (field_value & 0xFF) << 48
    # keyinverted | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'keyinverted')
    if field is None:
        raise Exception("Cant encode this message, missing 'keyInverted'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    # unknown_data | Offset: 64, Length: 112, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown_data')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown data'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 64
    return data_raw

def decode_pgn_126720_seatalk1DeviceIdentification(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'seatalk1DeviceIdentification', 'Seatalk1: Device Identification')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1851, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Raymarine", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: 33264, PartOfPrimaryKey: True,
    running_bit_offset = 16
    proprietary_id = proprietary_id_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "0x81f0", None, proprietary_id, proprietary_id_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 16

    # 5:command | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 144, PartOfPrimaryKey: ,
    running_bit_offset = 32
    command = command_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('command', 'command', "0x90", None, command, command_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:reserved_40 | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    reserved_40 = reserved_40_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_40', 'Reserved', None, None, reserved_40, reserved_40_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 7:device | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    device_raw = decode_int(_data_raw_, running_bit_offset, 8)
    device = master_dict['SEATALK_DEVICE_ID'].get(device_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('device', 'device', None, None, device, device_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_126720_seatalk1DeviceIdentification(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # command | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'command')
    if field is None:
        raise Exception("Cant encode this message, missing 'command'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # reserved_40 | Offset: 40, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_40')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # device | Offset: 48, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'device')
    if field is None:
        raise Exception("Cant encode this message, missing 'device'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SEATALK_DEVICE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 48
    return data_raw

def decode_pgn_126720_seatalk1DisplayBrightness(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'seatalk1DisplayBrightness', 'Seatalk1: Display Brightness')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1851, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Raymarine", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: 3212, PartOfPrimaryKey: True,
    running_bit_offset = 16
    proprietary_id = proprietary_id_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "0x0c8c", None, proprietary_id, proprietary_id_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 16

    # 5:group | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    group_raw = decode_int(_data_raw_, running_bit_offset, 8)
    group = master_dict['SEATALK_NETWORK_GROUP'].get(group_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('group', 'Group', None, None, group, group_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 6:unknown_1 | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    unknown_1 = unknown_1_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 8))
    nmea2000Message.fields.append(NMEA2000Field('unknown_1', 'Unknown 1', None, None, unknown_1, unknown_1_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 8

    # 7:command | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 0, PartOfPrimaryKey: ,
    running_bit_offset = 48
    command = command_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('command', 'Command', "Brightness", None, command, command_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:brightness | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    brightness = brightness_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('brightness', 'Brightness', None, '%', brightness, brightness_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:unknown_2 | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    unknown_2 = unknown_2_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 8))
    nmea2000Message.fields.append(NMEA2000Field('unknown_2', 'Unknown 2', None, None, unknown_2, unknown_2_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_126720_seatalk1DisplayBrightness(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # group | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'group')
    if field is None:
        raise Exception("Cant encode this message, missing 'Group'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SEATALK_NETWORK_GROUP(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # unknown_1 | Offset: 40, Length: 8, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown 1'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # command | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'command')
    if field is None:
        raise Exception("Cant encode this message, missing 'Command'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # brightness | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'brightness')
    if field is None:
        raise Exception("Cant encode this message, missing 'Brightness'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    # unknown_2 | Offset: 64, Length: 8, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown_2')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown 2'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 64
    return data_raw

def decode_pgn_126720_seatalk1DisplayColor(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'seatalk1DisplayColor', 'Seatalk1: Display Color')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1851, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Raymarine", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: 3212, PartOfPrimaryKey: True,
    running_bit_offset = 16
    proprietary_id = proprietary_id_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "0x0c8c", None, proprietary_id, proprietary_id_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 16

    # 5:group | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    group_raw = decode_int(_data_raw_, running_bit_offset, 8)
    group = master_dict['SEATALK_NETWORK_GROUP'].get(group_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('group', 'Group', None, None, group, group_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 6:unknown_1 | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    unknown_1 = unknown_1_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 8))
    nmea2000Message.fields.append(NMEA2000Field('unknown_1', 'Unknown 1', None, None, unknown_1, unknown_1_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 8

    # 7:command | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 1, PartOfPrimaryKey: ,
    running_bit_offset = 48
    command = command_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('command', 'Command', "Color", None, command, command_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:color | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    color_raw = decode_int(_data_raw_, running_bit_offset, 8)
    color = master_dict['SEATALK_DISPLAY_COLOR'].get(color_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('color', 'Color', None, None, color, color_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 9:unknown_2 | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    unknown_2 = unknown_2_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 8))
    nmea2000Message.fields.append(NMEA2000Field('unknown_2', 'Unknown 2', None, None, unknown_2, unknown_2_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_126720_seatalk1DisplayColor(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # group | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'group')
    if field is None:
        raise Exception("Cant encode this message, missing 'Group'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SEATALK_NETWORK_GROUP(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # unknown_1 | Offset: 40, Length: 8, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown 1'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # command | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'command')
    if field is None:
        raise Exception("Cant encode this message, missing 'Command'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # color | Offset: 56, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'color')
    if field is None:
        raise Exception("Cant encode this message, missing 'Color'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SEATALK_DISPLAY_COLOR(field.value)
    data_raw |= (field_value & 0xFF) << 56
    # unknown_2 | Offset: 64, Length: 8, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown_2')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown 2'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 64
    return data_raw

def decode_pgn_126720_airmarAttitudeOffset(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'airmarAttitudeOffset', 'Airmar: Attitude Offset')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 32, PartOfPrimaryKey: ,
    running_bit_offset = 16
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['AIRMAR_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Attitude Offsets", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:azimuth_offset | Offset: 24, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    azimuth_offset = azimuth_offset_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('azimuth_offset', 'Azimuth offset', "Positive: sensor rotated to port, negative: sensor rotated to starboard", 'rad', azimuth_offset, azimuth_offset_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:pitch_offset | Offset: 40, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    pitch_offset = pitch_offset_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('pitch_offset', 'Pitch offset', "Positive: sensor tilted to bow, negative: sensor tilted to stern", 'rad', pitch_offset, pitch_offset_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:roll_offset | Offset: 56, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    roll_offset = roll_offset_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('roll_offset', 'Roll offset', "Positive: sensor tilted to port, negative: sensor tilted to starboard", 'rad', roll_offset, roll_offset_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_126720_airmarAttitudeOffset(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIRMAR_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # azimuth_offset | Offset: 24, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'azimuth_offset')
    if field is None:
        raise Exception("Cant encode this message, missing 'Azimuth offset'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 24
    
    # pitch_offset | Offset: 40, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pitch_offset')
    if field is None:
        raise Exception("Cant encode this message, missing 'Pitch offset'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 40
    
    # roll_offset | Offset: 56, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'roll_offset')
    if field is None:
        raise Exception("Cant encode this message, missing 'Roll offset'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 56
    
    return data_raw

def decode_pgn_126720_airmarCalibrateCompass(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'airmarCalibrateCompass', 'Airmar: Calibrate Compass')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 33, PartOfPrimaryKey: ,
    running_bit_offset = 16
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['AIRMAR_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Calibrate Compass", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:calibrate_function | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    calibrate_function_raw = decode_int(_data_raw_, running_bit_offset, 8)
    calibrate_function = master_dict['AIRMAR_CALIBRATE_FUNCTION'].get(calibrate_function_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('calibrate_function', 'Calibrate Function', None, None, calibrate_function, calibrate_function_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 6:calibration_status | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    calibration_status_raw = decode_int(_data_raw_, running_bit_offset, 8)
    calibration_status = master_dict['AIRMAR_CALIBRATE_STATUS'].get(calibration_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('calibration_status', 'Calibration Status', None, None, calibration_status, calibration_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:verify_score | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    verify_score = verify_score_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('verify_score', 'Verify Score', "TBD", None, verify_score, verify_score_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:x_axis_gain_value | Offset: 48, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    x_axis_gain_value = x_axis_gain_value_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('x_axis_gain_value', 'X-axis gain value', "default 100, range 50 to 500", None, x_axis_gain_value, x_axis_gain_value_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:y_axis_gain_value | Offset: 64, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    y_axis_gain_value = y_axis_gain_value_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('y_axis_gain_value', 'Y-axis gain value', "default 100, range 50 to 500", None, y_axis_gain_value, y_axis_gain_value_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 10:z_axis_gain_value | Offset: 80, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    z_axis_gain_value = z_axis_gain_value_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('z_axis_gain_value', 'Z-axis gain value', "default 100, range 50 to 500", None, z_axis_gain_value, z_axis_gain_value_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:x_axis_linear_offset | Offset: 96, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 96
    x_axis_linear_offset = x_axis_linear_offset_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('x_axis_linear_offset', 'X-axis linear offset', None, 'T', x_axis_linear_offset, x_axis_linear_offset_raw, PhysicalQuantities.MAGNETIC_FIELD, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 12:y_axis_linear_offset | Offset: 112, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    y_axis_linear_offset = y_axis_linear_offset_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('y_axis_linear_offset', 'Y-axis linear offset', None, 'T', y_axis_linear_offset, y_axis_linear_offset_raw, PhysicalQuantities.MAGNETIC_FIELD, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 13:z_axis_linear_offset | Offset: 128, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    z_axis_linear_offset = z_axis_linear_offset_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('z_axis_linear_offset', 'Z-axis linear offset', None, 'T', z_axis_linear_offset, z_axis_linear_offset_raw, PhysicalQuantities.MAGNETIC_FIELD, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 14:x_axis_angular_offset | Offset: 144, Length: 16, Signed: True Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    x_axis_angular_offset = x_axis_angular_offset_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('x_axis_angular_offset', 'X-axis angular offset', None, 'deg', x_axis_angular_offset, x_axis_angular_offset_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 15:pitch_and_roll_damping | Offset: 160, Length: 16, Signed: True Resolution: 0.05, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 160
    pitch_and_roll_damping_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.05)
    pitch_and_roll_damping = decode_time(pitch_and_roll_damping_raw)
    nmea2000Message.fields.append(NMEA2000Field('pitch_and_roll_damping', 'Pitch and Roll damping', "default 30, range 0 to 200", 's', pitch_and_roll_damping, pitch_and_roll_damping_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    # 16:compass_rate_gyro_damping | Offset: 176, Length: 16, Signed: True Resolution: 0.05, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 176
    compass_rate_gyro_damping_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.05)
    compass_rate_gyro_damping = decode_time(compass_rate_gyro_damping_raw)
    nmea2000Message.fields.append(NMEA2000Field('compass_rate_gyro_damping', 'Compass/Rate gyro damping', "default -30, range -2400 to 2400, negative indicates rate gyro is to be used in compass calculations", 's', compass_rate_gyro_damping, compass_rate_gyro_damping_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_126720_airmarCalibrateCompass(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIRMAR_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # calibrate_function | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'calibrate_function')
    if field is None:
        raise Exception("Cant encode this message, missing 'Calibrate Function'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIRMAR_CALIBRATE_FUNCTION(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # calibration_status | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'calibration_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Calibration Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIRMAR_CALIBRATE_STATUS(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # verify_score | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'verify_score')
    if field is None:
        raise Exception("Cant encode this message, missing 'Verify Score'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # x_axis_gain_value | Offset: 48, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'x_axis_gain_value')
    if field is None:
        raise Exception("Cant encode this message, missing 'X-axis gain value'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 48
    
    # y_axis_gain_value | Offset: 64, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'y_axis_gain_value')
    if field is None:
        raise Exception("Cant encode this message, missing 'Y-axis gain value'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 64
    
    # z_axis_gain_value | Offset: 80, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'z_axis_gain_value')
    if field is None:
        raise Exception("Cant encode this message, missing 'Z-axis gain value'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 80
    
    # x_axis_linear_offset | Offset: 96, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'x_axis_linear_offset')
    if field is None:
        raise Exception("Cant encode this message, missing 'X-axis linear offset'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 96
    
    # y_axis_linear_offset | Offset: 112, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'y_axis_linear_offset')
    if field is None:
        raise Exception("Cant encode this message, missing 'Y-axis linear offset'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 112
    
    # z_axis_linear_offset | Offset: 128, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'z_axis_linear_offset')
    if field is None:
        raise Exception("Cant encode this message, missing 'Z-axis linear offset'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 128
    
    # x_axis_angular_offset | Offset: 144, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'x_axis_angular_offset')
    if field is None:
        raise Exception("Cant encode this message, missing 'X-axis angular offset'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 144
    
    # pitch_and_roll_damping | Offset: 160, Length: 16, Resolution: 0.05, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'pitch_and_roll_damping')
    if field is None:
        raise Exception("Cant encode this message, missing 'Pitch and Roll damping'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.05) & 0xFFFF) << 160
    
    # compass_rate_gyro_damping | Offset: 176, Length: 16, Resolution: 0.05, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'compass_rate_gyro_damping')
    if field is None:
        raise Exception("Cant encode this message, missing 'Compass/Rate gyro damping'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.05) & 0xFFFF) << 176
    
    return data_raw

def decode_pgn_126720_airmarTrueWindOptions(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'airmarTrueWindOptions', 'Airmar: True Wind Options')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 34, PartOfPrimaryKey: ,
    running_bit_offset = 16
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['AIRMAR_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "True Wind Options", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:cog_substitution_for_hdg | Offset: 24, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    cog_substitution_for_hdg_raw = decode_int(_data_raw_, running_bit_offset, 2)
    cog_substitution_for_hdg = master_dict['YES_NO'].get(cog_substitution_for_hdg_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('cog_substitution_for_hdg', 'COG substitution for HDG', "Allow use of COG when HDG not available?", None, cog_substitution_for_hdg, cog_substitution_for_hdg_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 6:reserved_26 | Offset: 26, Length: 22, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 26
    reserved_26 = reserved_26_raw = decode_int(_data_raw_, running_bit_offset, 22)
    nmea2000Message.fields.append(NMEA2000Field('reserved_26', 'Reserved', None, None, reserved_26, reserved_26_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 22

    return nmea2000Message

def encode_pgn_126720_airmarTrueWindOptions(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIRMAR_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # cog_substitution_for_hdg | Offset: 24, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'cog_substitution_for_hdg')
    if field is None:
        raise Exception("Cant encode this message, missing 'COG substitution for HDG'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 24
    # reserved_26 | Offset: 26, Length: 22, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_26')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3FFFFF) << 26
    return data_raw

def decode_pgn_126720_airmarSimulateMode(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'airmarSimulateMode', 'Airmar: Simulate Mode')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 35, PartOfPrimaryKey: ,
    running_bit_offset = 16
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['AIRMAR_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Simulate Mode", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:simulate_mode | Offset: 24, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    simulate_mode_raw = decode_int(_data_raw_, running_bit_offset, 2)
    simulate_mode = master_dict['OFF_ON'].get(simulate_mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('simulate_mode', 'Simulate Mode', None, None, simulate_mode, simulate_mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 6:reserved_26 | Offset: 26, Length: 22, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 26
    reserved_26 = reserved_26_raw = decode_int(_data_raw_, running_bit_offset, 22)
    nmea2000Message.fields.append(NMEA2000Field('reserved_26', 'Reserved', None, None, reserved_26, reserved_26_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 22

    return nmea2000Message

def encode_pgn_126720_airmarSimulateMode(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIRMAR_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # simulate_mode | Offset: 24, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'simulate_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Simulate Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 24
    # reserved_26 | Offset: 26, Length: 22, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_26')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3FFFFF) << 26
    return data_raw

def decode_pgn_126720_airmarCalibrateDepth(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'airmarCalibrateDepth', 'Airmar: Calibrate Depth')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 40, PartOfPrimaryKey: ,
    running_bit_offset = 16
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['AIRMAR_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Calibrate Depth", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:speed_of_sound_mode | Offset: 24, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    speed_of_sound_mode = speed_of_sound_mode_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('speed_of_sound_mode', 'Speed of Sound Mode', "actual allowed range is 1350.0 to 1650.0 m/s", 'm/s', speed_of_sound_mode, speed_of_sound_mode_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:reserved_40 | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    reserved_40 = reserved_40_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_40', 'Reserved', None, None, reserved_40, reserved_40_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_126720_airmarCalibrateDepth(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIRMAR_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # speed_of_sound_mode | Offset: 24, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'speed_of_sound_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Speed of Sound Mode'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 24
    
    # reserved_40 | Offset: 40, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_40')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    return data_raw

def decode_pgn_126720_airmarCalibrateSpeed(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'airmarCalibrateSpeed', 'Airmar: Calibrate Speed')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 41, PartOfPrimaryKey: ,
    running_bit_offset = 16
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['AIRMAR_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Calibrate Speed", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:number_of_pairs_of_data_points | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    number_of_pairs_of_data_points = number_of_pairs_of_data_points_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_pairs_of_data_points', 'Number of pairs of data points', "actual range is 0 to 25. 254=restore default speed curve", None, number_of_pairs_of_data_points, number_of_pairs_of_data_points_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:input_frequency | Offset: 32, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    input_frequency = input_frequency_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('input_frequency', 'Input frequency', None, 'Hz', input_frequency, input_frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:output_speed | Offset: 48, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    output_speed = output_speed_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('output_speed', 'Output speed', None, 'm/s', output_speed, output_speed_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_126720_airmarCalibrateSpeed(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIRMAR_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # number_of_pairs_of_data_points | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_pairs_of_data_points')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of pairs of data points'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # input_frequency | Offset: 32, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'input_frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'Input frequency'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 32
    
    # output_speed | Offset: 48, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'output_speed')
    if field is None:
        raise Exception("Cant encode this message, missing 'Output speed'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 48
    
    return data_raw

def decode_pgn_126720_airmarCalibrateTemperature(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'airmarCalibrateTemperature', 'Airmar: Calibrate Temperature')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 42, PartOfPrimaryKey: ,
    running_bit_offset = 16
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['AIRMAR_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Calibrate Temperature", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:temperature_instance | Offset: 24, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 24
    temperature_instance_raw = decode_int(_data_raw_, running_bit_offset, 2)
    temperature_instance = master_dict['AIRMAR_TEMPERATURE_INSTANCE'].get(temperature_instance_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('temperature_instance', 'Temperature instance', None, None, temperature_instance, temperature_instance_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 2

    # 6:reserved_26 | Offset: 26, Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 26
    reserved_26 = reserved_26_raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_26', 'Reserved', None, None, reserved_26, reserved_26_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    # 7:temperature_offset | Offset: 32, Length: 16, Signed: True Resolution: 0.001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    temperature_offset = temperature_offset_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.001)
    nmea2000Message.fields.append(NMEA2000Field('temperature_offset', 'Temperature offset', "actual range is -9.999 to +9.999 K", 'K', temperature_offset, temperature_offset_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_126720_airmarCalibrateTemperature(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIRMAR_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # temperature_instance | Offset: 24, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'temperature_instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Temperature instance'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIRMAR_TEMPERATURE_INSTANCE(field.value)
    data_raw |= (field_value & 0x3) << 24
    # reserved_26 | Offset: 26, Length: 6, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_26')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 26
    # temperature_offset | Offset: 32, Length: 16, Resolution: 0.001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'temperature_offset')
    if field is None:
        raise Exception("Cant encode this message, missing 'Temperature offset'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFF) << 32
    
    return data_raw

def decode_pgn_126720_airmarSpeedFilterNone(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'airmarSpeedFilterNone', 'Airmar: Speed Filter None')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 43, PartOfPrimaryKey: ,
    running_bit_offset = 16
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['AIRMAR_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Speed Filter", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:filter_type | Offset: 24, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: 0, PartOfPrimaryKey: ,
    running_bit_offset = 24
    filter_type = filter_type_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('filter_type', 'Filter type', "No filter", None, filter_type, filter_type_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 6:reserved_28 | Offset: 28, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 28
    reserved_28 = reserved_28_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_28', 'Reserved', None, None, reserved_28, reserved_28_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 7:sample_interval | Offset: 32, Length: 16, Signed: False Resolution: 0.01, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    sample_interval_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    sample_interval = decode_time(sample_interval_raw)
    nmea2000Message.fields.append(NMEA2000Field('sample_interval', 'Sample interval', "Interval of time between successive samples of the paddlewheel pulse accumulator", 's', sample_interval, sample_interval_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_126720_airmarSpeedFilterNone(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIRMAR_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # filter_type | Offset: 24, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'filter_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Filter type'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 24
    # reserved_28 | Offset: 28, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_28')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 28
    # sample_interval | Offset: 32, Length: 16, Resolution: 0.01, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'sample_interval')
    if field is None:
        raise Exception("Cant encode this message, missing 'Sample interval'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 32
    
    return data_raw

def decode_pgn_126720_airmarSpeedFilterIir(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'airmarSpeedFilterIir', 'Airmar: Speed Filter IIR')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 43, PartOfPrimaryKey: ,
    running_bit_offset = 16
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['AIRMAR_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Speed Filter", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:filter_type | Offset: 24, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: 1, PartOfPrimaryKey: ,
    running_bit_offset = 24
    filter_type = filter_type_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('filter_type', 'Filter type', "IIR filter", None, filter_type, filter_type_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 6:reserved_28 | Offset: 28, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 28
    reserved_28 = reserved_28_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_28', 'Reserved', None, None, reserved_28, reserved_28_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 7:sample_interval | Offset: 32, Length: 16, Signed: False Resolution: 0.01, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    sample_interval_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    sample_interval = decode_time(sample_interval_raw)
    nmea2000Message.fields.append(NMEA2000Field('sample_interval', 'Sample interval', "Interval of time between successive samples of the paddlewheel pulse accumulator", 's', sample_interval, sample_interval_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    # 8:filter_duration | Offset: 48, Length: 16, Signed: False Resolution: 0.01, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    filter_duration_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    filter_duration = decode_time(filter_duration_raw)
    nmea2000Message.fields.append(NMEA2000Field('filter_duration', 'Filter duration', "Duration of filter, must be bigger than the sample interval", 's', filter_duration, filter_duration_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_126720_airmarSpeedFilterIir(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIRMAR_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # filter_type | Offset: 24, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'filter_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Filter type'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 24
    # reserved_28 | Offset: 28, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_28')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 28
    # sample_interval | Offset: 32, Length: 16, Resolution: 0.01, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'sample_interval')
    if field is None:
        raise Exception("Cant encode this message, missing 'Sample interval'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 32
    
    # filter_duration | Offset: 48, Length: 16, Resolution: 0.01, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'filter_duration')
    if field is None:
        raise Exception("Cant encode this message, missing 'Filter duration'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 48
    
    return data_raw

def decode_pgn_126720_airmarTemperatureFilterNone(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'airmarTemperatureFilterNone', 'Airmar: Temperature Filter None')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 44, PartOfPrimaryKey: ,
    running_bit_offset = 16
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['AIRMAR_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Temperature Filter", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:filter_type | Offset: 24, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: 0, PartOfPrimaryKey: ,
    running_bit_offset = 24
    filter_type = filter_type_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('filter_type', 'Filter type', "No filter", None, filter_type, filter_type_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 6:reserved_28 | Offset: 28, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 28
    reserved_28 = reserved_28_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_28', 'Reserved', None, None, reserved_28, reserved_28_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 7:sample_interval | Offset: 32, Length: 16, Signed: False Resolution: 0.01, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    sample_interval_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    sample_interval = decode_time(sample_interval_raw)
    nmea2000Message.fields.append(NMEA2000Field('sample_interval', 'Sample interval', "Interval of time between successive samples of the water temperature thermistor", 's', sample_interval, sample_interval_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_126720_airmarTemperatureFilterNone(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIRMAR_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # filter_type | Offset: 24, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'filter_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Filter type'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 24
    # reserved_28 | Offset: 28, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_28')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 28
    # sample_interval | Offset: 32, Length: 16, Resolution: 0.01, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'sample_interval')
    if field is None:
        raise Exception("Cant encode this message, missing 'Sample interval'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 32
    
    return data_raw

def decode_pgn_126720_airmarTemperatureFilterIir(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'airmarTemperatureFilterIir', 'Airmar: Temperature Filter IIR')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 44, PartOfPrimaryKey: ,
    running_bit_offset = 16
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['AIRMAR_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Temperature Filter", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:filter_type | Offset: 24, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: 1, PartOfPrimaryKey: ,
    running_bit_offset = 24
    filter_type = filter_type_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('filter_type', 'Filter type', "IIR filter", None, filter_type, filter_type_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 6:reserved_28 | Offset: 28, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 28
    reserved_28 = reserved_28_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_28', 'Reserved', None, None, reserved_28, reserved_28_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 7:sample_interval | Offset: 32, Length: 16, Signed: False Resolution: 0.01, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    sample_interval_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    sample_interval = decode_time(sample_interval_raw)
    nmea2000Message.fields.append(NMEA2000Field('sample_interval', 'Sample interval', "Interval of time between successive samples of the water temperature thermistor", 's', sample_interval, sample_interval_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    # 8:filter_duration | Offset: 48, Length: 16, Signed: False Resolution: 0.01, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    filter_duration_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    filter_duration = decode_time(filter_duration_raw)
    nmea2000Message.fields.append(NMEA2000Field('filter_duration', 'Filter duration', "Duration of filter, must be bigger than the sample interval", 's', filter_duration, filter_duration_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_126720_airmarTemperatureFilterIir(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIRMAR_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # filter_type | Offset: 24, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'filter_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Filter type'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 24
    # reserved_28 | Offset: 28, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_28')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 28
    # sample_interval | Offset: 32, Length: 16, Resolution: 0.01, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'sample_interval')
    if field is None:
        raise Exception("Cant encode this message, missing 'Sample interval'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 32
    
    # filter_duration | Offset: 48, Length: 16, Resolution: 0.01, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'filter_duration')
    if field is None:
        raise Exception("Cant encode this message, missing 'Filter duration'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 48
    
    return data_raw

def decode_pgn_126720_airmarNmea2000Options(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'airmarNmea2000Options', 'Airmar: NMEA 2000 options')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 46, PartOfPrimaryKey: ,
    running_bit_offset = 16
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['AIRMAR_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "NMEA 2000 options", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:transmission_interval | Offset: 24, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    transmission_interval_raw = decode_int(_data_raw_, running_bit_offset, 2)
    transmission_interval = master_dict['AIRMAR_TRANSMISSION_INTERVAL'].get(transmission_interval_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('transmission_interval', 'Transmission Interval', None, None, transmission_interval, transmission_interval_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 6:reserved_26 | Offset: 26, Length: 22, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 26
    reserved_26 = reserved_26_raw = decode_int(_data_raw_, running_bit_offset, 22)
    nmea2000Message.fields.append(NMEA2000Field('reserved_26', 'Reserved', None, None, reserved_26, reserved_26_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 22

    return nmea2000Message

def encode_pgn_126720_airmarNmea2000Options(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIRMAR_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # transmission_interval | Offset: 24, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'transmission_interval')
    if field is None:
        raise Exception("Cant encode this message, missing 'Transmission Interval'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIRMAR_TRANSMISSION_INTERVAL(field.value)
    data_raw |= (field_value & 0x3) << 24
    # reserved_26 | Offset: 26, Length: 22, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_26')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3FFFFF) << 26
    return data_raw

def decode_pgn_126720_airmarAddressableMultiFrame(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'airmarAddressableMultiFrame', 'Airmar: Addressable Multi-Frame')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 16
    proprietary_id = proprietary_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', None, None, proprietary_id, proprietary_id_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_126720_airmarAddressableMultiFrame(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    return data_raw

def decode_pgn_126720_maretronSlaveResponse(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'maretronSlaveResponse', 'Maretron: Slave Response')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 137, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Maretron", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:product_code | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    product_code = product_code_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('product_code', 'Product code', "0x1b2=SSC200", None, product_code, product_code_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:software_code | Offset: 32, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    software_code = software_code_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('software_code', 'Software code', None, None, software_code, software_code_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:command | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    command = command_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('command', 'Command', "0x50=Deviation calibration result", None, command, command_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:status | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    status = status_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('status', 'Status', None, None, status, status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_126720_maretronSlaveResponse(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # product_code | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'product_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Product code'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # software_code | Offset: 32, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'software_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Software code'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 32
    # command | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'command')
    if field is None:
        raise Exception("Cant encode this message, missing 'Command'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # status | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Status'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw

def decode_pgn_126720_garminDayMode(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'garminDayMode', 'Garmin: Day Mode')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 229, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Garmin", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:unknown_id_1 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 222, PartOfPrimaryKey: ,
    running_bit_offset = 16
    unknown_id_1 = unknown_id_1_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unknown_id_1', 'Unknown ID 1', "Always 222", None, unknown_id_1, unknown_id_1_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:unknown_id_2 | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 5, PartOfPrimaryKey: ,
    running_bit_offset = 24
    unknown_id_2 = unknown_id_2_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unknown_id_2', 'Unknown ID 2', "Always 5", None, unknown_id_2, unknown_id_2_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:unknown_id_3 | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 5, PartOfPrimaryKey: ,
    running_bit_offset = 32
    unknown_id_3 = unknown_id_3_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unknown_id_3', 'Unknown ID 3', "Always 5", None, unknown_id_3, unknown_id_3_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:unknown_id_4 | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 5, PartOfPrimaryKey: ,
    running_bit_offset = 40
    unknown_id_4 = unknown_id_4_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unknown_id_4', 'Unknown ID 4', "Always 5", None, unknown_id_4, unknown_id_4_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:spare | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 16

    # 9:mode | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 0, PartOfPrimaryKey: ,
    running_bit_offset = 64
    mode_raw = decode_int(_data_raw_, running_bit_offset, 8)
    mode = master_dict['GARMIN_COLOR_MODE'].get(mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('mode', 'Mode', "Day", None, mode, mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 10:spare | Offset: 72, Length: 8, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 8

    # 11:backlight | Offset: 80, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    backlight_raw = decode_int(_data_raw_, running_bit_offset, 8)
    backlight = master_dict['GARMIN_BACKLIGHT_LEVEL'].get(backlight_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('backlight', 'Backlight', None, None, backlight, backlight_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_126720_garminDayMode(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # unknown_id_1 | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown_id_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown ID 1'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # unknown_id_2 | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown_id_2')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown ID 2'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # unknown_id_3 | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown_id_3')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown ID 3'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # unknown_id_4 | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown_id_4')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown ID 4'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # spare | Offset: 48, Length: 16, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    # mode | Offset: 64, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GARMIN_COLOR_MODE(field.value)
    data_raw |= (field_value & 0xFF) << 64
    # spare | Offset: 72, Length: 8, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 72
    # backlight | Offset: 80, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'backlight')
    if field is None:
        raise Exception("Cant encode this message, missing 'Backlight'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GARMIN_BACKLIGHT_LEVEL(field.value)
    data_raw |= (field_value & 0xFF) << 80
    return data_raw

def decode_pgn_126720_garminNightMode(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'garminNightMode', 'Garmin: Night Mode')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 229, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Garmin", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:unknown_id_1 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 222, PartOfPrimaryKey: ,
    running_bit_offset = 16
    unknown_id_1 = unknown_id_1_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unknown_id_1', 'Unknown ID 1', "Always 222", None, unknown_id_1, unknown_id_1_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:unknown_id_2 | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 5, PartOfPrimaryKey: ,
    running_bit_offset = 24
    unknown_id_2 = unknown_id_2_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unknown_id_2', 'Unknown ID 2', "Always 5", None, unknown_id_2, unknown_id_2_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:unknown_id_3 | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 5, PartOfPrimaryKey: ,
    running_bit_offset = 32
    unknown_id_3 = unknown_id_3_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unknown_id_3', 'Unknown ID 3', "Always 5", None, unknown_id_3, unknown_id_3_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:unknown_id_4 | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 5, PartOfPrimaryKey: ,
    running_bit_offset = 40
    unknown_id_4 = unknown_id_4_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unknown_id_4', 'Unknown ID 4', "Always 5", None, unknown_id_4, unknown_id_4_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:spare | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 16

    # 9:mode | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1, PartOfPrimaryKey: ,
    running_bit_offset = 64
    mode_raw = decode_int(_data_raw_, running_bit_offset, 8)
    mode = master_dict['GARMIN_COLOR_MODE'].get(mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('mode', 'Mode', "Night", None, mode, mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 10:spare | Offset: 72, Length: 8, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 8

    # 11:backlight | Offset: 80, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    backlight_raw = decode_int(_data_raw_, running_bit_offset, 8)
    backlight = master_dict['GARMIN_BACKLIGHT_LEVEL'].get(backlight_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('backlight', 'Backlight', None, None, backlight, backlight_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_126720_garminNightMode(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # unknown_id_1 | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown_id_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown ID 1'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # unknown_id_2 | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown_id_2')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown ID 2'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # unknown_id_3 | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown_id_3')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown ID 3'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # unknown_id_4 | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown_id_4')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown ID 4'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # spare | Offset: 48, Length: 16, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    # mode | Offset: 64, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GARMIN_COLOR_MODE(field.value)
    data_raw |= (field_value & 0xFF) << 64
    # spare | Offset: 72, Length: 8, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 72
    # backlight | Offset: 80, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'backlight')
    if field is None:
        raise Exception("Cant encode this message, missing 'Backlight'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GARMIN_BACKLIGHT_LEVEL(field.value)
    data_raw |= (field_value & 0xFF) << 80
    return data_raw

def decode_pgn_126720_garminColorMode(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126720."""
    nmea2000Message = NMEA2000Message(126720, 'garminColorMode', 'Garmin: Color mode')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 229, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Garmin", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:unknown_id_1 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 222, PartOfPrimaryKey: ,
    running_bit_offset = 16
    unknown_id_1 = unknown_id_1_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unknown_id_1', 'Unknown ID 1', "Always 222", None, unknown_id_1, unknown_id_1_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:unknown_id_2 | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 5, PartOfPrimaryKey: ,
    running_bit_offset = 24
    unknown_id_2 = unknown_id_2_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unknown_id_2', 'Unknown ID 2', "Always 5", None, unknown_id_2, unknown_id_2_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:unknown_id_3 | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 5, PartOfPrimaryKey: ,
    running_bit_offset = 32
    unknown_id_3 = unknown_id_3_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unknown_id_3', 'Unknown ID 3', "Always 5", None, unknown_id_3, unknown_id_3_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:unknown_id_4 | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 5, PartOfPrimaryKey: ,
    running_bit_offset = 40
    unknown_id_4 = unknown_id_4_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unknown_id_4', 'Unknown ID 4', "Always 5", None, unknown_id_4, unknown_id_4_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:spare | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 16

    # 9:mode | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 13, PartOfPrimaryKey: ,
    running_bit_offset = 64
    mode_raw = decode_int(_data_raw_, running_bit_offset, 8)
    mode = master_dict['GARMIN_COLOR_MODE'].get(mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('mode', 'Mode', "Color", None, mode, mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 10:spare | Offset: 72, Length: 8, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 8

    # 11:color | Offset: 80, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    color_raw = decode_int(_data_raw_, running_bit_offset, 8)
    color = master_dict['GARMIN_COLOR'].get(color_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('color', 'Color', None, None, color, color_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_126720_garminColorMode(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126720."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # unknown_id_1 | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown_id_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown ID 1'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # unknown_id_2 | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown_id_2')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown ID 2'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # unknown_id_3 | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown_id_3')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown ID 3'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # unknown_id_4 | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown_id_4')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown ID 4'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # spare | Offset: 48, Length: 16, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    # mode | Offset: 64, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GARMIN_COLOR_MODE(field.value)
    data_raw |= (field_value & 0xFF) << 64
    # spare | Offset: 72, Length: 8, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 72
    # color | Offset: 80, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'color')
    if field is None:
        raise Exception("Cant encode this message, missing 'Color'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GARMIN_COLOR(field.value)
    data_raw |= (field_value & 0xFF) << 80
    return data_raw


def is_fast_pgn_126976() -> bool:
    """Return True if PGN 126976 is a fast PGN."""
    raise Exception('PGEN type Mixed not supported')

def decode_pgn_126976(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126976."""
    nmea2000Message = NMEA2000Message(126976, '0x1f0000x1feffStandardizedMixedSingleFastPacketNonAddressed', '0x1F000-0x1FEFF: Standardized mixed single/fast packet non-addressed')
    running_bit_offset = 0
    # 1:data | Offset: 0, Length: 1784, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    data = data_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 1784))
    nmea2000Message.fields.append(NMEA2000Field('data', 'Data', None, None, data, data_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 1784

    return nmea2000Message

def encode_pgn_126976(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126976."""
    data_raw = 0
    # data | Offset: 0, Length: 1784, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'data')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data'")
    # Skipping fields longer than 256
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 0
    return data_raw


def is_fast_pgn_126983() -> bool:
    """Return True if PGN 126983 is a fast PGN."""
    return True
def decode_pgn_126983(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126983."""
    nmea2000Message = NMEA2000Message(126983, 'alert', 'Alert')
    running_bit_offset = 0
    # 1:alert_type | Offset: 0, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    alert_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    alert_type = master_dict['ALERT_TYPE'].get(alert_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('alert_type', 'Alert Type', None, None, alert_type, alert_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 2:alert_category | Offset: 4, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 4
    alert_category_raw = decode_int(_data_raw_, running_bit_offset, 4)
    alert_category = master_dict['ALERT_CATEGORY'].get(alert_category_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('alert_category', 'Alert Category', None, None, alert_category, alert_category_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 3:alert_system | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    alert_system = alert_system_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_system', 'Alert System', None, None, alert_system, alert_system_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:alert_sub_system | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    alert_sub_system = alert_sub_system_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_sub_system', 'Alert Sub-System', None, None, alert_sub_system, alert_sub_system_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:alert_id | Offset: 24, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    alert_id = alert_id_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_id', 'Alert ID', None, None, alert_id, alert_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:data_source_network_id_name | Offset: 40, Length: 64, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    data_source_network_id_name = data_source_network_id_name_raw = decode_number(_data_raw_, running_bit_offset, 64, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_network_id_name', 'Data Source Network ID NAME', None, None, data_source_network_id_name, data_source_network_id_name_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 64

    # 7:data_source_instance | Offset: 104, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 104
    data_source_instance = data_source_instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_instance', 'Data Source Instance', None, None, data_source_instance, data_source_instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 8:data_source_index_source | Offset: 112, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    data_source_index_source = data_source_index_source_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_index_source', 'Data Source Index-Source', None, None, data_source_index_source, data_source_index_source_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:alert_occurrence_number | Offset: 120, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    alert_occurrence_number = alert_occurrence_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_occurrence_number', 'Alert Occurrence Number', None, None, alert_occurrence_number, alert_occurrence_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:temporary_silence_status | Offset: 128, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    temporary_silence_status_raw = decode_int(_data_raw_, running_bit_offset, 1)
    temporary_silence_status = master_dict['YES_NO'].get(temporary_silence_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('temporary_silence_status', 'Temporary Silence Status', None, None, temporary_silence_status, temporary_silence_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 11:acknowledge_status | Offset: 129, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 129
    acknowledge_status_raw = decode_int(_data_raw_, running_bit_offset, 1)
    acknowledge_status = master_dict['YES_NO'].get(acknowledge_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('acknowledge_status', 'Acknowledge Status', None, None, acknowledge_status, acknowledge_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 12:escalation_status | Offset: 130, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 130
    escalation_status_raw = decode_int(_data_raw_, running_bit_offset, 1)
    escalation_status = master_dict['YES_NO'].get(escalation_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('escalation_status', 'Escalation Status', None, None, escalation_status, escalation_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 13:temporary_silence_support | Offset: 131, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 131
    temporary_silence_support_raw = decode_int(_data_raw_, running_bit_offset, 1)
    temporary_silence_support = master_dict['YES_NO'].get(temporary_silence_support_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('temporary_silence_support', 'Temporary Silence Support', None, None, temporary_silence_support, temporary_silence_support_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 14:acknowledge_support | Offset: 132, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 132
    acknowledge_support_raw = decode_int(_data_raw_, running_bit_offset, 1)
    acknowledge_support = master_dict['YES_NO'].get(acknowledge_support_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('acknowledge_support', 'Acknowledge Support', None, None, acknowledge_support, acknowledge_support_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 15:escalation_support | Offset: 133, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 133
    escalation_support_raw = decode_int(_data_raw_, running_bit_offset, 1)
    escalation_support = master_dict['YES_NO'].get(escalation_support_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('escalation_support', 'Escalation Support', None, None, escalation_support, escalation_support_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 16:reserved_134 | Offset: 134, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 134
    reserved_134 = reserved_134_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_134', 'Reserved', None, None, reserved_134, reserved_134_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 17:acknowledge_source_network_id_name | Offset: 136, Length: 64, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 136
    acknowledge_source_network_id_name = acknowledge_source_network_id_name_raw = decode_number(_data_raw_, running_bit_offset, 64, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('acknowledge_source_network_id_name', 'Acknowledge Source Network ID NAME', None, None, acknowledge_source_network_id_name, acknowledge_source_network_id_name_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 64

    # 18:trigger_condition | Offset: 200, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 200
    trigger_condition_raw = decode_int(_data_raw_, running_bit_offset, 4)
    trigger_condition = master_dict['ALERT_TRIGGER_CONDITION'].get(trigger_condition_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('trigger_condition', 'Trigger Condition', None, None, trigger_condition, trigger_condition_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 19:threshold_status | Offset: 204, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 204
    threshold_status_raw = decode_int(_data_raw_, running_bit_offset, 4)
    threshold_status = master_dict['ALERT_THRESHOLD_STATUS'].get(threshold_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('threshold_status', 'Threshold Status', None, None, threshold_status, threshold_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 20:alert_priority | Offset: 208, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 208
    alert_priority = alert_priority_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_priority', 'Alert Priority', None, None, alert_priority, alert_priority_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 21:alert_state | Offset: 216, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 216
    alert_state_raw = decode_int(_data_raw_, running_bit_offset, 8)
    alert_state = master_dict['ALERT_STATE'].get(alert_state_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('alert_state', 'Alert State', None, None, alert_state, alert_state_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_126983(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126983."""
    data_raw = 0
    # alert_type | Offset: 0, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ALERT_TYPE(field.value)
    data_raw |= (field_value & 0xF) << 0
    # alert_category | Offset: 4, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_category')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Category'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ALERT_CATEGORY(field.value)
    data_raw |= (field_value & 0xF) << 4
    # alert_system | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_system')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert System'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # alert_sub_system | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_sub_system')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Sub-System'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # alert_id | Offset: 24, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 24
    # data_source_network_id_name | Offset: 40, Length: 64, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_network_id_name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Network ID NAME'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFF) << 40
    # data_source_instance | Offset: 104, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 104
    # data_source_index_source | Offset: 112, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_index_source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Index-Source'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 112
    # alert_occurrence_number | Offset: 120, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_occurrence_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Occurrence Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 120
    # temporary_silence_status | Offset: 128, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'temporary_silence_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Temporary Silence Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x1) << 128
    # acknowledge_status | Offset: 129, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'acknowledge_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Acknowledge Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x1) << 129
    # escalation_status | Offset: 130, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'escalation_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Escalation Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x1) << 130
    # temporary_silence_support | Offset: 131, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'temporary_silence_support')
    if field is None:
        raise Exception("Cant encode this message, missing 'Temporary Silence Support'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x1) << 131
    # acknowledge_support | Offset: 132, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'acknowledge_support')
    if field is None:
        raise Exception("Cant encode this message, missing 'Acknowledge Support'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x1) << 132
    # escalation_support | Offset: 133, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'escalation_support')
    if field is None:
        raise Exception("Cant encode this message, missing 'Escalation Support'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x1) << 133
    # reserved_134 | Offset: 134, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_134')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 134
    # acknowledge_source_network_id_name | Offset: 136, Length: 64, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'acknowledge_source_network_id_name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Acknowledge Source Network ID NAME'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFF) << 136
    # trigger_condition | Offset: 200, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'trigger_condition')
    if field is None:
        raise Exception("Cant encode this message, missing 'Trigger Condition'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ALERT_TRIGGER_CONDITION(field.value)
    data_raw |= (field_value & 0xF) << 200
    # threshold_status | Offset: 204, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'threshold_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Threshold Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ALERT_THRESHOLD_STATUS(field.value)
    data_raw |= (field_value & 0xF) << 204
    # alert_priority | Offset: 208, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_priority')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Priority'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 208
    # alert_state | Offset: 216, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert State'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ALERT_STATE(field.value)
    data_raw |= (field_value & 0xFF) << 216
    return data_raw


def is_fast_pgn_126984() -> bool:
    """Return True if PGN 126984 is a fast PGN."""
    return True
def decode_pgn_126984(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126984."""
    nmea2000Message = NMEA2000Message(126984, 'alertResponse', 'Alert Response')
    running_bit_offset = 0
    # 1:alert_type | Offset: 0, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    alert_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    alert_type = master_dict['ALERT_TYPE'].get(alert_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('alert_type', 'Alert Type', None, None, alert_type, alert_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 2:alert_category | Offset: 4, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 4
    alert_category_raw = decode_int(_data_raw_, running_bit_offset, 4)
    alert_category = master_dict['ALERT_CATEGORY'].get(alert_category_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('alert_category', 'Alert Category', None, None, alert_category, alert_category_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 3:alert_system | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    alert_system = alert_system_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_system', 'Alert System', None, None, alert_system, alert_system_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:alert_sub_system | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    alert_sub_system = alert_sub_system_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_sub_system', 'Alert Sub-System', None, None, alert_sub_system, alert_sub_system_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:alert_id | Offset: 24, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    alert_id = alert_id_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_id', 'Alert ID', None, None, alert_id, alert_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:data_source_network_id_name | Offset: 40, Length: 64, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    data_source_network_id_name = data_source_network_id_name_raw = decode_number(_data_raw_, running_bit_offset, 64, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_network_id_name', 'Data Source Network ID NAME', None, None, data_source_network_id_name, data_source_network_id_name_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 64

    # 7:data_source_instance | Offset: 104, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 104
    data_source_instance = data_source_instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_instance', 'Data Source Instance', None, None, data_source_instance, data_source_instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 8:data_source_index_source | Offset: 112, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    data_source_index_source = data_source_index_source_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_index_source', 'Data Source Index-Source', None, None, data_source_index_source, data_source_index_source_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:alert_occurrence_number | Offset: 120, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    alert_occurrence_number = alert_occurrence_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_occurrence_number', 'Alert Occurrence Number', None, None, alert_occurrence_number, alert_occurrence_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:acknowledge_source_network_id_name | Offset: 128, Length: 64, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    acknowledge_source_network_id_name = acknowledge_source_network_id_name_raw = decode_number(_data_raw_, running_bit_offset, 64, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('acknowledge_source_network_id_name', 'Acknowledge Source Network ID NAME', None, None, acknowledge_source_network_id_name, acknowledge_source_network_id_name_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 64

    # 11:response_command | Offset: 192, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 192
    response_command_raw = decode_int(_data_raw_, running_bit_offset, 2)
    response_command = master_dict['ALERT_RESPONSE_COMMAND'].get(response_command_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('response_command', 'Response Command', None, None, response_command, response_command_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 12:reserved_194 | Offset: 194, Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 194
    reserved_194 = reserved_194_raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_194', 'Reserved', None, None, reserved_194, reserved_194_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    return nmea2000Message

def encode_pgn_126984(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126984."""
    data_raw = 0
    # alert_type | Offset: 0, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ALERT_TYPE(field.value)
    data_raw |= (field_value & 0xF) << 0
    # alert_category | Offset: 4, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_category')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Category'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ALERT_CATEGORY(field.value)
    data_raw |= (field_value & 0xF) << 4
    # alert_system | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_system')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert System'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # alert_sub_system | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_sub_system')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Sub-System'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # alert_id | Offset: 24, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 24
    # data_source_network_id_name | Offset: 40, Length: 64, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_network_id_name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Network ID NAME'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFF) << 40
    # data_source_instance | Offset: 104, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 104
    # data_source_index_source | Offset: 112, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_index_source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Index-Source'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 112
    # alert_occurrence_number | Offset: 120, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_occurrence_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Occurrence Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 120
    # acknowledge_source_network_id_name | Offset: 128, Length: 64, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'acknowledge_source_network_id_name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Acknowledge Source Network ID NAME'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFF) << 128
    # response_command | Offset: 192, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'response_command')
    if field is None:
        raise Exception("Cant encode this message, missing 'Response Command'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ALERT_RESPONSE_COMMAND(field.value)
    data_raw |= (field_value & 0x3) << 192
    # reserved_194 | Offset: 194, Length: 6, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_194')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 194
    return data_raw


def is_fast_pgn_126985() -> bool:
    """Return True if PGN 126985 is a fast PGN."""
    return True
def decode_pgn_126985(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126985."""
    nmea2000Message = NMEA2000Message(126985, 'alertText', 'Alert Text')
    running_bit_offset = 0
    # 1:alert_type | Offset: 0, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    alert_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    alert_type = master_dict['ALERT_TYPE'].get(alert_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('alert_type', 'Alert Type', None, None, alert_type, alert_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 2:alert_category | Offset: 4, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 4
    alert_category_raw = decode_int(_data_raw_, running_bit_offset, 4)
    alert_category = master_dict['ALERT_CATEGORY'].get(alert_category_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('alert_category', 'Alert Category', None, None, alert_category, alert_category_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 3:alert_system | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    alert_system = alert_system_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_system', 'Alert System', None, None, alert_system, alert_system_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:alert_sub_system | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    alert_sub_system = alert_sub_system_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_sub_system', 'Alert Sub-System', None, None, alert_sub_system, alert_sub_system_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:alert_id | Offset: 24, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    alert_id = alert_id_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_id', 'Alert ID', None, None, alert_id, alert_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:data_source_network_id_name | Offset: 40, Length: 64, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    data_source_network_id_name = data_source_network_id_name_raw = decode_number(_data_raw_, running_bit_offset, 64, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_network_id_name', 'Data Source Network ID NAME', None, None, data_source_network_id_name, data_source_network_id_name_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 64

    # 7:data_source_instance | Offset: 104, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 104
    data_source_instance = data_source_instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_instance', 'Data Source Instance', None, None, data_source_instance, data_source_instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 8:data_source_index_source | Offset: 112, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    data_source_index_source = data_source_index_source_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_index_source', 'Data Source Index-Source', None, None, data_source_index_source, data_source_index_source_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:alert_occurrence_number | Offset: 120, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    alert_occurrence_number = alert_occurrence_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_occurrence_number', 'Alert Occurrence Number', None, None, alert_occurrence_number, alert_occurrence_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:language_id | Offset: 128, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    language_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    language_id = master_dict['ALERT_LANGUAGE_ID'].get(language_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('language_id', 'Language ID', None, None, language_id, language_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 11:alert_text_description | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    alert_text_description_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    alert_text_description = alert_text_description_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('alert_text_description', 'Alert Text Description', None, None, alert_text_description, alert_text_description_raw, None, FieldTypes.STRING_LAU, False))
    

    # 12:alert_location_text_description | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    alert_location_text_description_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    alert_location_text_description = alert_location_text_description_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('alert_location_text_description', 'Alert Location Text Description', None, None, alert_location_text_description, alert_location_text_description_raw, None, FieldTypes.STRING_LAU, False))
    

    return nmea2000Message

def encode_pgn_126985(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126985."""
    data_raw = 0
    # alert_type | Offset: 0, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ALERT_TYPE(field.value)
    data_raw |= (field_value & 0xF) << 0
    # alert_category | Offset: 4, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_category')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Category'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ALERT_CATEGORY(field.value)
    data_raw |= (field_value & 0xF) << 4
    # alert_system | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_system')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert System'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # alert_sub_system | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_sub_system')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Sub-System'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # alert_id | Offset: 24, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 24
    # data_source_network_id_name | Offset: 40, Length: 64, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_network_id_name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Network ID NAME'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFF) << 40
    # data_source_instance | Offset: 104, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 104
    # data_source_index_source | Offset: 112, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_index_source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Index-Source'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 112
    # alert_occurrence_number | Offset: 120, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_occurrence_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Occurrence Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 120
    # language_id | Offset: 128, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'language_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Language ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ALERT_LANGUAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 128
    raise Exception ("PGN 126985 not supporting encoding for now as Alert Text Description is missing BitLength or BitOffset")
    raise Exception ("PGN 126985 not supporting encoding for now as Alert Location Text Description is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_126986() -> bool:
    """Return True if PGN 126986 is a fast PGN."""
    return True
def decode_pgn_126986(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126986."""
    nmea2000Message = NMEA2000Message(126986, 'alertConfiguration', 'Alert Configuration')
    running_bit_offset = 0
    # 1:alert_type | Offset: 0, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    alert_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    alert_type = master_dict['ALERT_TYPE'].get(alert_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('alert_type', 'Alert Type', None, None, alert_type, alert_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 2:alert_category | Offset: 4, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 4
    alert_category_raw = decode_int(_data_raw_, running_bit_offset, 4)
    alert_category = master_dict['ALERT_CATEGORY'].get(alert_category_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('alert_category', 'Alert Category', None, None, alert_category, alert_category_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 3:alert_system | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    alert_system = alert_system_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_system', 'Alert System', None, None, alert_system, alert_system_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:alert_sub_system | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    alert_sub_system = alert_sub_system_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_sub_system', 'Alert Sub-System', None, None, alert_sub_system, alert_sub_system_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:alert_id | Offset: 24, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    alert_id = alert_id_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_id', 'Alert ID', None, None, alert_id, alert_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:data_source_network_id_name | Offset: 40, Length: 64, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    data_source_network_id_name = data_source_network_id_name_raw = decode_number(_data_raw_, running_bit_offset, 64, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_network_id_name', 'Data Source Network ID NAME', None, None, data_source_network_id_name, data_source_network_id_name_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 64

    # 7:data_source_instance | Offset: 104, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 104
    data_source_instance = data_source_instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_instance', 'Data Source Instance', None, None, data_source_instance, data_source_instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 8:data_source_index_source | Offset: 112, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    data_source_index_source = data_source_index_source_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_index_source', 'Data Source Index-Source', None, None, data_source_index_source, data_source_index_source_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:alert_occurrence_number | Offset: 120, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    alert_occurrence_number = alert_occurrence_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_occurrence_number', 'Alert Occurrence Number', None, None, alert_occurrence_number, alert_occurrence_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:alert_control | Offset: 128, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    alert_control = alert_control_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_control', 'Alert Control', None, None, alert_control, alert_control_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 11:user_defined_alert_assignment | Offset: 130, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 130
    user_defined_alert_assignment = user_defined_alert_assignment_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('user_defined_alert_assignment', 'User Defined Alert Assignment', None, None, user_defined_alert_assignment, user_defined_alert_assignment_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 12:reserved_132 | Offset: 132, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 132
    reserved_132 = reserved_132_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_132', 'Reserved', None, None, reserved_132, reserved_132_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 13:reactivation_period | Offset: 136, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 136
    reactivation_period = reactivation_period_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('reactivation_period', 'Reactivation Period', None, None, reactivation_period, reactivation_period_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 14:temporary_silence_period | Offset: 144, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    temporary_silence_period = temporary_silence_period_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('temporary_silence_period', 'Temporary Silence Period', None, None, temporary_silence_period, temporary_silence_period_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 15:escalation_period | Offset: 152, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 152
    escalation_period = escalation_period_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('escalation_period', 'Escalation Period', None, None, escalation_period, escalation_period_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_126986(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126986."""
    data_raw = 0
    # alert_type | Offset: 0, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ALERT_TYPE(field.value)
    data_raw |= (field_value & 0xF) << 0
    # alert_category | Offset: 4, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_category')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Category'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ALERT_CATEGORY(field.value)
    data_raw |= (field_value & 0xF) << 4
    # alert_system | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_system')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert System'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # alert_sub_system | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_sub_system')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Sub-System'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # alert_id | Offset: 24, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 24
    # data_source_network_id_name | Offset: 40, Length: 64, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_network_id_name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Network ID NAME'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFF) << 40
    # data_source_instance | Offset: 104, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 104
    # data_source_index_source | Offset: 112, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_index_source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Index-Source'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 112
    # alert_occurrence_number | Offset: 120, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_occurrence_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Occurrence Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 120
    # alert_control | Offset: 128, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Control'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 128
    # user_defined_alert_assignment | Offset: 130, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'user_defined_alert_assignment')
    if field is None:
        raise Exception("Cant encode this message, missing 'User Defined Alert Assignment'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 130
    # reserved_132 | Offset: 132, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_132')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 132
    # reactivation_period | Offset: 136, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'reactivation_period')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reactivation Period'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 136
    # temporary_silence_period | Offset: 144, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'temporary_silence_period')
    if field is None:
        raise Exception("Cant encode this message, missing 'Temporary Silence Period'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 144
    # escalation_period | Offset: 152, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'escalation_period')
    if field is None:
        raise Exception("Cant encode this message, missing 'Escalation Period'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 152
    return data_raw


def is_fast_pgn_126987() -> bool:
    """Return True if PGN 126987 is a fast PGN."""
    return True
def decode_pgn_126987(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126987."""
    nmea2000Message = NMEA2000Message(126987, 'alertThreshold', 'Alert Threshold')
    running_bit_offset = 0
    # 1:alert_type | Offset: 0, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    alert_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    alert_type = master_dict['ALERT_TYPE'].get(alert_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('alert_type', 'Alert Type', None, None, alert_type, alert_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 2:alert_category | Offset: 4, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 4
    alert_category_raw = decode_int(_data_raw_, running_bit_offset, 4)
    alert_category = master_dict['ALERT_CATEGORY'].get(alert_category_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('alert_category', 'Alert Category', None, None, alert_category, alert_category_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 3:alert_system | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    alert_system = alert_system_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_system', 'Alert System', None, None, alert_system, alert_system_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:alert_sub_system | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    alert_sub_system = alert_sub_system_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_sub_system', 'Alert Sub-System', None, None, alert_sub_system, alert_sub_system_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:alert_id | Offset: 24, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    alert_id = alert_id_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_id', 'Alert ID', None, None, alert_id, alert_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:data_source_network_id_name | Offset: 40, Length: 64, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    data_source_network_id_name = data_source_network_id_name_raw = decode_number(_data_raw_, running_bit_offset, 64, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_network_id_name', 'Data Source Network ID NAME', None, None, data_source_network_id_name, data_source_network_id_name_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 64

    # 7:data_source_instance | Offset: 104, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 104
    data_source_instance = data_source_instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_instance', 'Data Source Instance', None, None, data_source_instance, data_source_instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 8:data_source_index_source | Offset: 112, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    data_source_index_source = data_source_index_source_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_index_source', 'Data Source Index-Source', None, None, data_source_index_source, data_source_index_source_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:alert_occurrence_number | Offset: 120, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    alert_occurrence_number = alert_occurrence_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_occurrence_number', 'Alert Occurrence Number', None, None, alert_occurrence_number, alert_occurrence_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:number_of_parameters | Offset: 128, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    number_of_parameters = number_of_parameters_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_parameters', 'Number of Parameters', "Total Number of Threshold Parameters", None, number_of_parameters, number_of_parameters_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 11:parameter_number | Offset: 136, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 136
    parameter_number = parameter_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('parameter_number', 'Parameter Number', None, None, parameter_number, parameter_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 12:trigger_method | Offset: 144, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    trigger_method = trigger_method_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('trigger_method', 'Trigger Method', None, None, trigger_method, trigger_method_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 13:threshold_data_format | Offset: 152, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 152
    threshold_data_format = threshold_data_format_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('threshold_data_format', 'Threshold Data Format', None, None, threshold_data_format, threshold_data_format_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 14:threshold_level | Offset: 160, Length: 64, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 160
    threshold_level = threshold_level_raw = decode_number(_data_raw_, running_bit_offset, 64, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('threshold_level', 'Threshold Level', None, None, threshold_level, threshold_level_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 64

    return nmea2000Message

def encode_pgn_126987(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126987."""
    data_raw = 0
    # alert_type | Offset: 0, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ALERT_TYPE(field.value)
    data_raw |= (field_value & 0xF) << 0
    # alert_category | Offset: 4, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_category')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Category'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ALERT_CATEGORY(field.value)
    data_raw |= (field_value & 0xF) << 4
    # alert_system | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_system')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert System'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # alert_sub_system | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_sub_system')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Sub-System'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # alert_id | Offset: 24, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 24
    # data_source_network_id_name | Offset: 40, Length: 64, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_network_id_name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Network ID NAME'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFF) << 40
    # data_source_instance | Offset: 104, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 104
    # data_source_index_source | Offset: 112, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_index_source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Index-Source'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 112
    # alert_occurrence_number | Offset: 120, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_occurrence_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Occurrence Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 120
    # number_of_parameters | Offset: 128, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_parameters')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of Parameters'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 128
    # parameter_number | Offset: 136, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'parameter_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Parameter Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 136
    # trigger_method | Offset: 144, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'trigger_method')
    if field is None:
        raise Exception("Cant encode this message, missing 'Trigger Method'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 144
    # threshold_data_format | Offset: 152, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'threshold_data_format')
    if field is None:
        raise Exception("Cant encode this message, missing 'Threshold Data Format'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 152
    # threshold_level | Offset: 160, Length: 64, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'threshold_level')
    if field is None:
        raise Exception("Cant encode this message, missing 'Threshold Level'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFF) << 160
    return data_raw


def is_fast_pgn_126988() -> bool:
    """Return True if PGN 126988 is a fast PGN."""
    return True
def decode_pgn_126988(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126988."""
    nmea2000Message = NMEA2000Message(126988, 'alertValue', 'Alert Value')
    running_bit_offset = 0
    # 1:alert_type | Offset: 0, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    alert_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    alert_type = master_dict['ALERT_TYPE'].get(alert_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('alert_type', 'Alert Type', None, None, alert_type, alert_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 2:alert_category | Offset: 4, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 4
    alert_category_raw = decode_int(_data_raw_, running_bit_offset, 4)
    alert_category = master_dict['ALERT_CATEGORY'].get(alert_category_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('alert_category', 'Alert Category', None, None, alert_category, alert_category_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 3:alert_system | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    alert_system = alert_system_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_system', 'Alert System', None, None, alert_system, alert_system_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:alert_sub_system | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    alert_sub_system = alert_sub_system_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_sub_system', 'Alert Sub-System', None, None, alert_sub_system, alert_sub_system_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:alert_id | Offset: 24, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    alert_id = alert_id_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_id', 'Alert ID', None, None, alert_id, alert_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:data_source_network_id_name | Offset: 40, Length: 64, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    data_source_network_id_name = data_source_network_id_name_raw = decode_number(_data_raw_, running_bit_offset, 64, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_network_id_name', 'Data Source Network ID NAME', None, None, data_source_network_id_name, data_source_network_id_name_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 64

    # 7:data_source_instance | Offset: 104, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 104
    data_source_instance = data_source_instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_instance', 'Data Source Instance', None, None, data_source_instance, data_source_instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 8:data_source_index_source | Offset: 112, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    data_source_index_source = data_source_index_source_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_index_source', 'Data Source Index-Source', None, None, data_source_index_source, data_source_index_source_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:alert_occurrence_number | Offset: 120, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    alert_occurrence_number = alert_occurrence_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('alert_occurrence_number', 'Alert Occurrence Number', None, None, alert_occurrence_number, alert_occurrence_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:number_of_parameters | Offset: 128, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    number_of_parameters = number_of_parameters_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_parameters', 'Number of Parameters', "Total Number of Value Parameters", None, number_of_parameters, number_of_parameters_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 11:value_parameter_number | Offset: 136, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 136
    value_parameter_number = value_parameter_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('value_parameter_number', 'Value Parameter Number', None, None, value_parameter_number, value_parameter_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 12:value_data_format | Offset: 144, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    value_data_format = value_data_format_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('value_data_format', 'Value Data Format', None, None, value_data_format, value_data_format_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 13:value_data | Offset: 152, Length: 64, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 152
    value_data = value_data_raw = decode_number(_data_raw_, running_bit_offset, 64, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('value_data', 'Value Data', None, None, value_data, value_data_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 64

    return nmea2000Message

def encode_pgn_126988(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126988."""
    data_raw = 0
    # alert_type | Offset: 0, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ALERT_TYPE(field.value)
    data_raw |= (field_value & 0xF) << 0
    # alert_category | Offset: 4, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_category')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Category'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ALERT_CATEGORY(field.value)
    data_raw |= (field_value & 0xF) << 4
    # alert_system | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_system')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert System'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # alert_sub_system | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_sub_system')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Sub-System'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # alert_id | Offset: 24, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 24
    # data_source_network_id_name | Offset: 40, Length: 64, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_network_id_name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Network ID NAME'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFF) << 40
    # data_source_instance | Offset: 104, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 104
    # data_source_index_source | Offset: 112, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_index_source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Index-Source'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 112
    # alert_occurrence_number | Offset: 120, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alert_occurrence_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alert Occurrence Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 120
    # number_of_parameters | Offset: 128, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_parameters')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of Parameters'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 128
    # value_parameter_number | Offset: 136, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'value_parameter_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Value Parameter Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 136
    # value_data_format | Offset: 144, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'value_data_format')
    if field is None:
        raise Exception("Cant encode this message, missing 'Value Data Format'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 144
    # value_data | Offset: 152, Length: 64, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'value_data')
    if field is None:
        raise Exception("Cant encode this message, missing 'Value Data'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFF) << 152
    return data_raw


def is_fast_pgn_126992() -> bool:
    """Return True if PGN 126992 is a fast PGN."""
    return False
def decode_pgn_126992(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126992."""
    nmea2000Message = NMEA2000Message(126992, 'systemTime', 'System Time')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:source | Offset: 8, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    source_raw = decode_int(_data_raw_, running_bit_offset, 4)
    source = master_dict['SYSTEM_TIME'].get(source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('source', 'Source', None, None, source, source_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 4

    # 3:reserved_12 | Offset: 12, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 12
    reserved_12 = reserved_12_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_12', 'Reserved', None, None, reserved_12, reserved_12_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 4:date | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: DATE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    date_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    date = decode_date(date_raw)
    nmea2000Message.fields.append(NMEA2000Field('date', 'Date', None, 'd', date, date_raw, PhysicalQuantities.DATE, FieldTypes.DATE, False))
    running_bit_offset += 16

    # 5:time | Offset: 32, Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    time_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    time = decode_time(time_raw)
    nmea2000Message.fields.append(NMEA2000Field('time', 'Time', "Seconds since midnight", 's', time, time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_126992(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126992."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # source | Offset: 8, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SYSTEM_TIME(field.value)
    data_raw |= (field_value & 0xF) << 8
    # reserved_12 | Offset: 12, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_12')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 12
    # date | Offset: 16, Length: 16, Resolution: 1, Field Type: DATE
    field = next(f for f in nmea2000Message.fields if f.id == 'date')
    if field is None:
        raise Exception("Cant encode this message, missing 'Date'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # time | Offset: 32, Length: 32, Resolution: 0.0001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFFFFFF) << 32
    
    return data_raw


def is_fast_pgn_126993() -> bool:
    """Return True if PGN 126993 is a fast PGN."""
    return False
def decode_pgn_126993(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126993."""
    nmea2000Message = NMEA2000Message(126993, 'heartbeat', 'Heartbeat')
    running_bit_offset = 0
    # 1:data_transmit_offset | Offset: 0, Length: 16, Signed: False Resolution: 0.001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    data_transmit_offset_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.001)
    data_transmit_offset = decode_time(data_transmit_offset_raw)
    nmea2000Message.fields.append(NMEA2000Field('data_transmit_offset', 'Data transmit offset', "Offset in transmit time from time of request command: 0x0 = transmit immediately, 0xFFFF = Do not change offset.", 's', data_transmit_offset, data_transmit_offset_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    # 2:sequence_counter | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    sequence_counter = sequence_counter_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sequence_counter', 'Sequence Counter', None, None, sequence_counter, sequence_counter_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:controller_1_state | Offset: 24, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    controller_1_state_raw = decode_int(_data_raw_, running_bit_offset, 2)
    controller_1_state = master_dict['CONTROLLER_STATE'].get(controller_1_state_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('controller_1_state', 'Controller 1 State', None, None, controller_1_state, controller_1_state_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:controller_2_state | Offset: 26, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 26
    controller_2_state_raw = decode_int(_data_raw_, running_bit_offset, 2)
    controller_2_state = master_dict['CONTROLLER_STATE'].get(controller_2_state_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('controller_2_state', 'Controller 2 State', None, None, controller_2_state, controller_2_state_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 5:equipment_status | Offset: 28, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 28
    equipment_status_raw = decode_int(_data_raw_, running_bit_offset, 2)
    equipment_status = master_dict['EQUIPMENT_STATUS'].get(equipment_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('equipment_status', 'Equipment Status', None, None, equipment_status, equipment_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 6:reserved_30 | Offset: 30, Length: 34, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 30
    reserved_30 = reserved_30_raw = decode_int(_data_raw_, running_bit_offset, 34)
    nmea2000Message.fields.append(NMEA2000Field('reserved_30', 'Reserved', None, None, reserved_30, reserved_30_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 34

    return nmea2000Message

def encode_pgn_126993(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126993."""
    data_raw = 0
    # data_transmit_offset | Offset: 0, Length: 16, Resolution: 0.001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'data_transmit_offset')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data transmit offset'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFF) << 0
    
    # sequence_counter | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sequence_counter')
    if field is None:
        raise Exception("Cant encode this message, missing 'Sequence Counter'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # controller_1_state | Offset: 24, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'controller_1_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'Controller 1 State'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_CONTROLLER_STATE(field.value)
    data_raw |= (field_value & 0x3) << 24
    # controller_2_state | Offset: 26, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'controller_2_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'Controller 2 State'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_CONTROLLER_STATE(field.value)
    data_raw |= (field_value & 0x3) << 26
    # equipment_status | Offset: 28, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'equipment_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Equipment Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_EQUIPMENT_STATUS(field.value)
    data_raw |= (field_value & 0x3) << 28
    # reserved_30 | Offset: 30, Length: 34, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_30')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3FFFFFFFF) << 30
    return data_raw


def is_fast_pgn_126996() -> bool:
    """Return True if PGN 126996 is a fast PGN."""
    return True
def decode_pgn_126996(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126996."""
    nmea2000Message = NMEA2000Message(126996, 'productInformation', 'Product Information')
    running_bit_offset = 0
    # 1:nmea_2000_version | Offset: 0, Length: 16, Signed: False Resolution: 0.001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    nmea_2000_version = nmea_2000_version_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.001)
    nmea2000Message.fields.append(NMEA2000Field('nmea_2000_version', 'NMEA 2000 Version', None, None, nmea_2000_version, nmea_2000_version_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:product_code | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 16
    product_code = product_code_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('product_code', 'Product Code', None, None, product_code, product_code_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 16

    # 3:model_id | Offset: 32, Length: 256, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 32
    model_id = model_id_raw = decode_string_fix(_data_raw_, running_bit_offset, 256)
    nmea2000Message.fields.append(NMEA2000Field('model_id', 'Model ID', None, None, model_id, model_id_raw, None, FieldTypes.STRING_FIX, True))
    running_bit_offset += 256

    # 4:software_version_code | Offset: 288, Length: 256, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 288
    software_version_code = software_version_code_raw = decode_string_fix(_data_raw_, running_bit_offset, 256)
    nmea2000Message.fields.append(NMEA2000Field('software_version_code', 'Software Version Code', None, None, software_version_code, software_version_code_raw, None, FieldTypes.STRING_FIX, True))
    running_bit_offset += 256

    # 5:model_version | Offset: 544, Length: 256, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 544
    model_version = model_version_raw = decode_string_fix(_data_raw_, running_bit_offset, 256)
    nmea2000Message.fields.append(NMEA2000Field('model_version', 'Model Version', None, None, model_version, model_version_raw, None, FieldTypes.STRING_FIX, True))
    running_bit_offset += 256

    # 6:model_serial_code | Offset: 800, Length: 256, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 800
    model_serial_code = model_serial_code_raw = decode_string_fix(_data_raw_, running_bit_offset, 256)
    nmea2000Message.fields.append(NMEA2000Field('model_serial_code', 'Model Serial Code', None, None, model_serial_code, model_serial_code_raw, None, FieldTypes.STRING_FIX, True))
    running_bit_offset += 256

    # 7:certification_level | Offset: 1056, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 1056
    certification_level = certification_level_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('certification_level', 'Certification Level', None, None, certification_level, certification_level_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:load_equivalency | Offset: 1064, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 1064
    load_equivalency = load_equivalency_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('load_equivalency', 'Load Equivalency', None, None, load_equivalency, load_equivalency_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_126996(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126996."""
    data_raw = 0
    # nmea_2000_version | Offset: 0, Length: 16, Resolution: 0.001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'nmea_2000_version')
    if field is None:
        raise Exception("Cant encode this message, missing 'NMEA 2000 Version'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFF) << 0
    
    # product_code | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'product_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Product Code'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # model_id | Offset: 32, Length: 256, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'model_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Model ID'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 32
    # software_version_code | Offset: 288, Length: 256, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'software_version_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Software Version Code'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 288
    # model_version | Offset: 544, Length: 256, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'model_version')
    if field is None:
        raise Exception("Cant encode this message, missing 'Model Version'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 544
    # model_serial_code | Offset: 800, Length: 256, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'model_serial_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Model Serial Code'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 800
    # certification_level | Offset: 1056, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'certification_level')
    if field is None:
        raise Exception("Cant encode this message, missing 'Certification Level'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 1056
    # load_equivalency | Offset: 1064, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'load_equivalency')
    if field is None:
        raise Exception("Cant encode this message, missing 'Load Equivalency'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 1064
    return data_raw


def is_fast_pgn_126998() -> bool:
    """Return True if PGN 126998 is a fast PGN."""
    return True
def decode_pgn_126998(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 126998."""
    nmea2000Message = NMEA2000Message(126998, 'configurationInformation', 'Configuration Information')
    running_bit_offset = 0
    # 1:installation_description__1 | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    installation_description__1_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    installation_description__1 = installation_description__1_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('installation_description__1', 'Installation Description #1', None, None, installation_description__1, installation_description__1_raw, None, FieldTypes.STRING_LAU, False))
    

    # 2:installation_description__2 | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    installation_description__2_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    installation_description__2 = installation_description__2_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('installation_description__2', 'Installation Description #2', None, None, installation_description__2, installation_description__2_raw, None, FieldTypes.STRING_LAU, False))
    

    # 3:manufacturer_information | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    manufacturer_information_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    manufacturer_information = manufacturer_information_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_information', 'Manufacturer Information', None, None, manufacturer_information, manufacturer_information_raw, None, FieldTypes.STRING_LAU, False))
    

    return nmea2000Message

def encode_pgn_126998(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 126998."""
    data_raw = 0
    raise Exception ("PGN 126998 not supporting encoding for now as Installation Description #1 is missing BitLength or BitOffset")
    raise Exception ("PGN 126998 not supporting encoding for now as Installation Description #2 is missing BitLength or BitOffset")
    raise Exception ("PGN 126998 not supporting encoding for now as Manufacturer Information is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_127233() -> bool:
    """Return True if PGN 127233 is a fast PGN."""
    return True
def decode_pgn_127233(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127233."""
    nmea2000Message = NMEA2000Message(127233, 'manOverboardNotification', 'Man Overboard Notification')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:mob_emitter_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    mob_emitter_id = mob_emitter_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('mob_emitter_id', 'MOB Emitter ID', "Identifier for each MOB emitter, unique to the vessel", None, mob_emitter_id, mob_emitter_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 3:man_overboard_status | Offset: 40, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    man_overboard_status_raw = decode_int(_data_raw_, running_bit_offset, 3)
    man_overboard_status = master_dict['MOB_STATUS'].get(man_overboard_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('man_overboard_status', 'Man Overboard Status', None, None, man_overboard_status, man_overboard_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 4:reserved_43 | Offset: 43, Length: 5, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 43
    reserved_43 = reserved_43_raw = decode_int(_data_raw_, running_bit_offset, 5)
    nmea2000Message.fields.append(NMEA2000Field('reserved_43', 'Reserved', None, None, reserved_43, reserved_43_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 5

    # 5:activation_time | Offset: 48, Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    activation_time_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    activation_time = decode_time(activation_time_raw)
    nmea2000Message.fields.append(NMEA2000Field('activation_time', 'Activation Time', "Seconds since midnight", 's', activation_time, activation_time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 6:position_source | Offset: 80, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    position_source_raw = decode_int(_data_raw_, running_bit_offset, 3)
    position_source = master_dict['MOB_POSITION_SOURCE'].get(position_source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('position_source', 'Position Source', None, None, position_source, position_source_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 7:reserved_83 | Offset: 83, Length: 5, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 83
    reserved_83 = reserved_83_raw = decode_int(_data_raw_, running_bit_offset, 5)
    nmea2000Message.fields.append(NMEA2000Field('reserved_83', 'Reserved', None, None, reserved_83, reserved_83_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 5

    # 8:position_date | Offset: 88, Length: 16, Signed: False Resolution: 1, Field Type: DATE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    position_date_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    position_date = decode_date(position_date_raw)
    nmea2000Message.fields.append(NMEA2000Field('position_date', 'Position Date', None, 'd', position_date, position_date_raw, PhysicalQuantities.DATE, FieldTypes.DATE, False))
    running_bit_offset += 16

    # 9:position_time | Offset: 104, Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 104
    position_time_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    position_time = decode_time(position_time_raw)
    nmea2000Message.fields.append(NMEA2000Field('position_time', 'Position Time', "Seconds since midnight", 's', position_time, position_time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 10:latitude | Offset: 136, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 136
    latitude = latitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('latitude', 'Latitude', None, 'deg', latitude, latitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 11:longitude | Offset: 168, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 168
    longitude = longitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('longitude', 'Longitude', None, 'deg', longitude, longitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 12:cog_reference | Offset: 200, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 200
    cog_reference_raw = decode_int(_data_raw_, running_bit_offset, 2)
    cog_reference = master_dict['DIRECTION_REFERENCE'].get(cog_reference_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('cog_reference', 'COG Reference', None, None, cog_reference, cog_reference_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 13:reserved_202 | Offset: 202, Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 202
    reserved_202 = reserved_202_raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_202', 'Reserved', None, None, reserved_202, reserved_202_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    # 14:cog | Offset: 208, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 208
    cog = cog_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('cog', 'COG', None, 'rad', cog, cog_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 15:sog | Offset: 224, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 224
    sog = sog_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('sog', 'SOG', None, 'm/s', sog, sog_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 16:mmsi_of_vessel_of_origin | Offset: 240, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 240
    mmsi_of_vessel_of_origin = mmsi_of_vessel_of_origin_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('mmsi_of_vessel_of_origin', 'MMSI of vessel of origin', None, None, mmsi_of_vessel_of_origin, mmsi_of_vessel_of_origin_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 17:mob_emitter_battery_low_status | Offset: 272, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 272
    mob_emitter_battery_low_status_raw = decode_int(_data_raw_, running_bit_offset, 3)
    mob_emitter_battery_low_status = master_dict['LOW_BATTERY'].get(mob_emitter_battery_low_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('mob_emitter_battery_low_status', 'MOB Emitter Battery Low Status', None, None, mob_emitter_battery_low_status, mob_emitter_battery_low_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 18:reserved_275 | Offset: 275, Length: 5, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 275
    reserved_275 = reserved_275_raw = decode_int(_data_raw_, running_bit_offset, 5)
    nmea2000Message.fields.append(NMEA2000Field('reserved_275', 'Reserved', None, None, reserved_275, reserved_275_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 5

    return nmea2000Message

def encode_pgn_127233(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127233."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # mob_emitter_id | Offset: 8, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'mob_emitter_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'MOB Emitter ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # man_overboard_status | Offset: 40, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'man_overboard_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Man Overboard Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MOB_STATUS(field.value)
    data_raw |= (field_value & 0x7) << 40
    # reserved_43 | Offset: 43, Length: 5, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_43')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1F) << 43
    # activation_time | Offset: 48, Length: 32, Resolution: 0.0001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'activation_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Activation Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFFFFFF) << 48
    
    # position_source | Offset: 80, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'position_source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MOB_POSITION_SOURCE(field.value)
    data_raw |= (field_value & 0x7) << 80
    # reserved_83 | Offset: 83, Length: 5, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_83')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1F) << 83
    # position_date | Offset: 88, Length: 16, Resolution: 1, Field Type: DATE
    field = next(f for f in nmea2000Message.fields if f.id == 'position_date')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position Date'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 88
    # position_time | Offset: 104, Length: 32, Resolution: 0.0001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'position_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFFFFFF) << 104
    
    # latitude | Offset: 136, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'latitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Latitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 136
    
    # longitude | Offset: 168, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'longitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Longitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 168
    
    # cog_reference | Offset: 200, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'cog_reference')
    if field is None:
        raise Exception("Cant encode this message, missing 'COG Reference'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DIRECTION_REFERENCE(field.value)
    data_raw |= (field_value & 0x3) << 200
    # reserved_202 | Offset: 202, Length: 6, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_202')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 202
    # cog | Offset: 208, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'cog')
    if field is None:
        raise Exception("Cant encode this message, missing 'COG'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 208
    
    # sog | Offset: 224, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sog')
    if field is None:
        raise Exception("Cant encode this message, missing 'SOG'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 224
    
    # mmsi_of_vessel_of_origin | Offset: 240, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'mmsi_of_vessel_of_origin')
    if field is None:
        raise Exception("Cant encode this message, missing 'MMSI of vessel of origin'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 240
    # mob_emitter_battery_low_status | Offset: 272, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'mob_emitter_battery_low_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'MOB Emitter Battery Low Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_LOW_BATTERY(field.value)
    data_raw |= (field_value & 0x7) << 272
    # reserved_275 | Offset: 275, Length: 5, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_275')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1F) << 275
    return data_raw


def is_fast_pgn_127237() -> bool:
    """Return True if PGN 127237 is a fast PGN."""
    return True
def decode_pgn_127237(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127237."""
    nmea2000Message = NMEA2000Message(127237, 'headingTrackControl', 'Heading/Track control')
    running_bit_offset = 0
    # 1:rudder_limit_exceeded | Offset: 0, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    rudder_limit_exceeded_raw = decode_int(_data_raw_, running_bit_offset, 2)
    rudder_limit_exceeded = master_dict['YES_NO'].get(rudder_limit_exceeded_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('rudder_limit_exceeded', 'Rudder Limit Exceeded', None, None, rudder_limit_exceeded, rudder_limit_exceeded_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 2:off_heading_limit_exceeded | Offset: 2, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 2
    off_heading_limit_exceeded_raw = decode_int(_data_raw_, running_bit_offset, 2)
    off_heading_limit_exceeded = master_dict['YES_NO'].get(off_heading_limit_exceeded_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('off_heading_limit_exceeded', 'Off-Heading Limit Exceeded', None, None, off_heading_limit_exceeded, off_heading_limit_exceeded_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:off_track_limit_exceeded | Offset: 4, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 4
    off_track_limit_exceeded_raw = decode_int(_data_raw_, running_bit_offset, 2)
    off_track_limit_exceeded = master_dict['YES_NO'].get(off_track_limit_exceeded_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('off_track_limit_exceeded', 'Off-Track Limit Exceeded', None, None, off_track_limit_exceeded, off_track_limit_exceeded_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:override | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    override_raw = decode_int(_data_raw_, running_bit_offset, 2)
    override = master_dict['YES_NO'].get(override_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('override', 'Override', None, None, override, override_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 5:steering_mode | Offset: 8, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    steering_mode_raw = decode_int(_data_raw_, running_bit_offset, 3)
    steering_mode = master_dict['STEERING_MODE'].get(steering_mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('steering_mode', 'Steering Mode', None, None, steering_mode, steering_mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 6:turn_mode | Offset: 11, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    turn_mode_raw = decode_int(_data_raw_, running_bit_offset, 3)
    turn_mode = master_dict['TURN_MODE'].get(turn_mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('turn_mode', 'Turn Mode', None, None, turn_mode, turn_mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 7:heading_reference | Offset: 14, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 14
    heading_reference_raw = decode_int(_data_raw_, running_bit_offset, 2)
    heading_reference = master_dict['DIRECTION_REFERENCE'].get(heading_reference_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('heading_reference', 'Heading Reference', None, None, heading_reference, heading_reference_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 8:reserved_16 | Offset: 16, Length: 5, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 5)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 5

    # 9:commanded_rudder_direction | Offset: 21, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 21
    commanded_rudder_direction_raw = decode_int(_data_raw_, running_bit_offset, 3)
    commanded_rudder_direction = master_dict['DIRECTION_RUDDER'].get(commanded_rudder_direction_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('commanded_rudder_direction', 'Commanded Rudder Direction', None, None, commanded_rudder_direction, commanded_rudder_direction_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 10:commanded_rudder_angle | Offset: 24, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    commanded_rudder_angle = commanded_rudder_angle_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('commanded_rudder_angle', 'Commanded Rudder Angle', None, 'rad', commanded_rudder_angle, commanded_rudder_angle_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:heading_to_steer__course_ | Offset: 40, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    heading_to_steer__course_ = heading_to_steer__course__raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('heading_to_steer__course_', 'Heading-To-Steer (Course)', None, 'rad', heading_to_steer__course_, heading_to_steer__course__raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 12:track | Offset: 56, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    track = track_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('track', 'Track', None, 'rad', track, track_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 13:rudder_limit | Offset: 72, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    rudder_limit = rudder_limit_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('rudder_limit', 'Rudder Limit', None, 'rad', rudder_limit, rudder_limit_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 14:off_heading_limit | Offset: 88, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    off_heading_limit = off_heading_limit_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('off_heading_limit', 'Off-Heading Limit', None, 'rad', off_heading_limit, off_heading_limit_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 15:radius_of_turn_order | Offset: 104, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 104
    radius_of_turn_order = radius_of_turn_order_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('radius_of_turn_order', 'Radius of Turn Order', None, 'rad', radius_of_turn_order, radius_of_turn_order_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 16:rate_of_turn_order | Offset: 120, Length: 16, Signed: True Resolution: 3.125e-05, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    rate_of_turn_order = rate_of_turn_order_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 3.125e-05)
    nmea2000Message.fields.append(NMEA2000Field('rate_of_turn_order', 'Rate of Turn Order', None, 'rad/s', rate_of_turn_order, rate_of_turn_order_raw, PhysicalQuantities.ANGULAR_VELOCITY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 17:off_track_limit | Offset: 136, Length: 16, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 136
    off_track_limit = off_track_limit_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('off_track_limit', 'Off-Track Limit', None, 'm', off_track_limit, off_track_limit_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 18:vessel_heading | Offset: 152, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 152
    vessel_heading = vessel_heading_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('vessel_heading', 'Vessel Heading', None, 'rad', vessel_heading, vessel_heading_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_127237(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127237."""
    data_raw = 0
    # rudder_limit_exceeded | Offset: 0, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'rudder_limit_exceeded')
    if field is None:
        raise Exception("Cant encode this message, missing 'Rudder Limit Exceeded'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 0
    # off_heading_limit_exceeded | Offset: 2, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'off_heading_limit_exceeded')
    if field is None:
        raise Exception("Cant encode this message, missing 'Off-Heading Limit Exceeded'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 2
    # off_track_limit_exceeded | Offset: 4, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'off_track_limit_exceeded')
    if field is None:
        raise Exception("Cant encode this message, missing 'Off-Track Limit Exceeded'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 4
    # override | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'override')
    if field is None:
        raise Exception("Cant encode this message, missing 'Override'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 6
    # steering_mode | Offset: 8, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'steering_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Steering Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_STEERING_MODE(field.value)
    data_raw |= (field_value & 0x7) << 8
    # turn_mode | Offset: 11, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'turn_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Turn Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_TURN_MODE(field.value)
    data_raw |= (field_value & 0x7) << 11
    # heading_reference | Offset: 14, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'heading_reference')
    if field is None:
        raise Exception("Cant encode this message, missing 'Heading Reference'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DIRECTION_REFERENCE(field.value)
    data_raw |= (field_value & 0x3) << 14
    # reserved_16 | Offset: 16, Length: 5, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1F) << 16
    # commanded_rudder_direction | Offset: 21, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'commanded_rudder_direction')
    if field is None:
        raise Exception("Cant encode this message, missing 'Commanded Rudder Direction'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DIRECTION_RUDDER(field.value)
    data_raw |= (field_value & 0x7) << 21
    # commanded_rudder_angle | Offset: 24, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'commanded_rudder_angle')
    if field is None:
        raise Exception("Cant encode this message, missing 'Commanded Rudder Angle'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 24
    
    # heading_to_steer__course_ | Offset: 40, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'heading_to_steer__course_')
    if field is None:
        raise Exception("Cant encode this message, missing 'Heading-To-Steer (Course)'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 40
    
    # track | Offset: 56, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'track')
    if field is None:
        raise Exception("Cant encode this message, missing 'Track'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 56
    
    # rudder_limit | Offset: 72, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'rudder_limit')
    if field is None:
        raise Exception("Cant encode this message, missing 'Rudder Limit'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 72
    
    # off_heading_limit | Offset: 88, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'off_heading_limit')
    if field is None:
        raise Exception("Cant encode this message, missing 'Off-Heading Limit'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 88
    
    # radius_of_turn_order | Offset: 104, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'radius_of_turn_order')
    if field is None:
        raise Exception("Cant encode this message, missing 'Radius of Turn Order'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 104
    
    # rate_of_turn_order | Offset: 120, Length: 16, Resolution: 3.125e-05, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'rate_of_turn_order')
    if field is None:
        raise Exception("Cant encode this message, missing 'Rate of Turn Order'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 3.125e-05) & 0xFFFF) << 120
    
    # off_track_limit | Offset: 136, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'off_track_limit')
    if field is None:
        raise Exception("Cant encode this message, missing 'Off-Track Limit'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 136
    # vessel_heading | Offset: 152, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'vessel_heading')
    if field is None:
        raise Exception("Cant encode this message, missing 'Vessel Heading'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 152
    
    return data_raw


def is_fast_pgn_127245() -> bool:
    """Return True if PGN 127245 is a fast PGN."""
    return False
def decode_pgn_127245(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127245."""
    nmea2000Message = NMEA2000Message(127245, 'rudder', 'Rudder')
    running_bit_offset = 0
    # 1:instance | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 2:direction_order | Offset: 8, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    direction_order_raw = decode_int(_data_raw_, running_bit_offset, 3)
    direction_order = master_dict['DIRECTION_RUDDER'].get(direction_order_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('direction_order', 'Direction Order', None, None, direction_order, direction_order_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 3:reserved_11 | Offset: 11, Length: 5, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 5)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 5

    # 4:angle_order | Offset: 16, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    angle_order = angle_order_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('angle_order', 'Angle Order', None, 'rad', angle_order, angle_order_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:position | Offset: 32, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    position = position_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('position', 'Position', None, 'rad', position, position_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:reserved_48 | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    reserved_48 = reserved_48_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('reserved_48', 'Reserved', None, None, reserved_48, reserved_48_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_127245(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127245."""
    data_raw = 0
    # instance | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # direction_order | Offset: 8, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'direction_order')
    if field is None:
        raise Exception("Cant encode this message, missing 'Direction Order'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DIRECTION_RUDDER(field.value)
    data_raw |= (field_value & 0x7) << 8
    # reserved_11 | Offset: 11, Length: 5, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1F) << 11
    # angle_order | Offset: 16, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'angle_order')
    if field is None:
        raise Exception("Cant encode this message, missing 'Angle Order'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 16
    
    # position | Offset: 32, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'position')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 32
    
    # reserved_48 | Offset: 48, Length: 16, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_48')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_127250() -> bool:
    """Return True if PGN 127250 is a fast PGN."""
    return False
def decode_pgn_127250(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127250."""
    nmea2000Message = NMEA2000Message(127250, 'vesselHeading', 'Vessel Heading')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:heading | Offset: 8, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    heading = heading_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('heading', 'Heading', None, 'rad', heading, heading_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:deviation | Offset: 24, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    deviation = deviation_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('deviation', 'Deviation', None, 'rad', deviation, deviation_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:variation | Offset: 40, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    variation = variation_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('variation', 'Variation', None, 'rad', variation, variation_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:reference | Offset: 56, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reference_raw = decode_int(_data_raw_, running_bit_offset, 2)
    reference = master_dict['DIRECTION_REFERENCE'].get(reference_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('reference', 'Reference', None, None, reference, reference_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 6:reserved_58 | Offset: 58, Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 58
    reserved_58 = reserved_58_raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_58', 'Reserved', None, None, reserved_58, reserved_58_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    return nmea2000Message

def encode_pgn_127250(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127250."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # heading | Offset: 8, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'heading')
    if field is None:
        raise Exception("Cant encode this message, missing 'Heading'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 8
    
    # deviation | Offset: 24, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'deviation')
    if field is None:
        raise Exception("Cant encode this message, missing 'Deviation'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 24
    
    # variation | Offset: 40, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'variation')
    if field is None:
        raise Exception("Cant encode this message, missing 'Variation'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 40
    
    # reference | Offset: 56, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'reference')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reference'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DIRECTION_REFERENCE(field.value)
    data_raw |= (field_value & 0x3) << 56
    # reserved_58 | Offset: 58, Length: 6, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_58')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 58
    return data_raw


def is_fast_pgn_127251() -> bool:
    """Return True if PGN 127251 is a fast PGN."""
    return False
def decode_pgn_127251(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127251."""
    nmea2000Message = NMEA2000Message(127251, 'rateOfTurn', 'Rate of Turn')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:rate | Offset: 8, Length: 32, Signed: True Resolution: 3.125e-08, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    rate = rate_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 3.125e-08)
    nmea2000Message.fields.append(NMEA2000Field('rate', 'Rate', None, 'rad/s', rate, rate_raw, PhysicalQuantities.ANGULAR_VELOCITY, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 3:reserved_40 | Offset: 40, Length: 24, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    reserved_40 = reserved_40_raw = decode_int(_data_raw_, running_bit_offset, 24)
    nmea2000Message.fields.append(NMEA2000Field('reserved_40', 'Reserved', None, None, reserved_40, reserved_40_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 24

    return nmea2000Message

def encode_pgn_127251(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127251."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # rate | Offset: 8, Length: 32, Resolution: 3.125e-08, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'rate')
    if field is None:
        raise Exception("Cant encode this message, missing 'Rate'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 3.125e-08) & 0xFFFFFFFF) << 8
    
    # reserved_40 | Offset: 40, Length: 24, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_40')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 40
    return data_raw


def is_fast_pgn_127252() -> bool:
    """Return True if PGN 127252 is a fast PGN."""
    return False
def decode_pgn_127252(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127252."""
    nmea2000Message = NMEA2000Message(127252, 'heave', 'Heave')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:heave | Offset: 8, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    heave = heave_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('heave', 'Heave', None, 'm', heave, heave_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:reserved_24 | Offset: 24, Length: 40, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    reserved_24 = reserved_24_raw = decode_int(_data_raw_, running_bit_offset, 40)
    nmea2000Message.fields.append(NMEA2000Field('reserved_24', 'Reserved', None, None, reserved_24, reserved_24_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 40

    return nmea2000Message

def encode_pgn_127252(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127252."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # heave | Offset: 8, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'heave')
    if field is None:
        raise Exception("Cant encode this message, missing 'Heave'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 8
    
    # reserved_24 | Offset: 24, Length: 40, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_24')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFF) << 24
    return data_raw


def is_fast_pgn_127257() -> bool:
    """Return True if PGN 127257 is a fast PGN."""
    return False
def decode_pgn_127257(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127257."""
    nmea2000Message = NMEA2000Message(127257, 'attitude', 'Attitude')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:yaw | Offset: 8, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    yaw = yaw_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('yaw', 'Yaw', None, 'rad', yaw, yaw_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:pitch | Offset: 24, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    pitch = pitch_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('pitch', 'Pitch', None, 'rad', pitch, pitch_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:roll | Offset: 40, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    roll = roll_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('roll', 'Roll', None, 'rad', roll, roll_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_127257(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127257."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # yaw | Offset: 8, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'yaw')
    if field is None:
        raise Exception("Cant encode this message, missing 'Yaw'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 8
    
    # pitch | Offset: 24, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pitch')
    if field is None:
        raise Exception("Cant encode this message, missing 'Pitch'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 24
    
    # roll | Offset: 40, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'roll')
    if field is None:
        raise Exception("Cant encode this message, missing 'Roll'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 40
    
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_127258() -> bool:
    """Return True if PGN 127258 is a fast PGN."""
    return False
def decode_pgn_127258(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127258."""
    nmea2000Message = NMEA2000Message(127258, 'magneticVariation', 'Magnetic Variation')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:source | Offset: 8, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    source_raw = decode_int(_data_raw_, running_bit_offset, 4)
    source = master_dict['MAGNETIC_VARIATION'].get(source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('source', 'Source', None, None, source, source_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 3:reserved_12 | Offset: 12, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 12
    reserved_12 = reserved_12_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_12', 'Reserved', None, None, reserved_12, reserved_12_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 4:age_of_service | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: DATE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    age_of_service_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    age_of_service = decode_date(age_of_service_raw)
    nmea2000Message.fields.append(NMEA2000Field('age_of_service', 'Age of service', None, 'd', age_of_service, age_of_service_raw, PhysicalQuantities.DATE, FieldTypes.DATE, False))
    running_bit_offset += 16

    # 5:variation | Offset: 32, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    variation = variation_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('variation', 'Variation', None, 'rad', variation, variation_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:reserved_48 | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    reserved_48 = reserved_48_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('reserved_48', 'Reserved', None, None, reserved_48, reserved_48_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_127258(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127258."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # source | Offset: 8, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MAGNETIC_VARIATION(field.value)
    data_raw |= (field_value & 0xF) << 8
    # reserved_12 | Offset: 12, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_12')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 12
    # age_of_service | Offset: 16, Length: 16, Resolution: 1, Field Type: DATE
    field = next(f for f in nmea2000Message.fields if f.id == 'age_of_service')
    if field is None:
        raise Exception("Cant encode this message, missing 'Age of service'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # variation | Offset: 32, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'variation')
    if field is None:
        raise Exception("Cant encode this message, missing 'Variation'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 32
    
    # reserved_48 | Offset: 48, Length: 16, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_48')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_127488() -> bool:
    """Return True if PGN 127488 is a fast PGN."""
    return False
def decode_pgn_127488(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127488."""
    nmea2000Message = NMEA2000Message(127488, 'engineParametersRapidUpdate', 'Engine Parameters, Rapid Update')
    running_bit_offset = 0
    # 1:instance | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    instance_raw = decode_int(_data_raw_, running_bit_offset, 8)
    instance = master_dict['ENGINE_INSTANCE'].get(instance_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 2:speed | Offset: 8, Length: 16, Signed: False Resolution: 0.25, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    speed = speed_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.25)
    nmea2000Message.fields.append(NMEA2000Field('speed', 'Speed', None, 'rpm', speed, speed_raw, PhysicalQuantities.ANGULAR_VELOCITY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:boost_pressure | Offset: 24, Length: 16, Signed: False Resolution: 100, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    boost_pressure = boost_pressure_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 100)
    nmea2000Message.fields.append(NMEA2000Field('boost_pressure', 'Boost Pressure', None, 'Pa', boost_pressure, boost_pressure_raw, PhysicalQuantities.PRESSURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:tilt_trim | Offset: 40, Length: 8, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    tilt_trim = tilt_trim_raw = decode_number(_data_raw_, running_bit_offset, 8, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('tilt_trim', 'Tilt/Trim', None, '%', tilt_trim, tilt_trim_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:reserved_48 | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    reserved_48 = reserved_48_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('reserved_48', 'Reserved', None, None, reserved_48, reserved_48_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_127488(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127488."""
    data_raw = 0
    # instance | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENGINE_INSTANCE(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # speed | Offset: 8, Length: 16, Resolution: 0.25, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'speed')
    if field is None:
        raise Exception("Cant encode this message, missing 'Speed'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.25) & 0xFFFF) << 8
    
    # boost_pressure | Offset: 24, Length: 16, Resolution: 100, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'boost_pressure')
    if field is None:
        raise Exception("Cant encode this message, missing 'Boost Pressure'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 100) & 0xFFFF) << 24
    
    # tilt_trim | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'tilt_trim')
    if field is None:
        raise Exception("Cant encode this message, missing 'Tilt/Trim'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # reserved_48 | Offset: 48, Length: 16, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_48')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_127489() -> bool:
    """Return True if PGN 127489 is a fast PGN."""
    return True
def decode_pgn_127489(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127489."""
    nmea2000Message = NMEA2000Message(127489, 'engineParametersDynamic', 'Engine Parameters, Dynamic')
    running_bit_offset = 0
    # 1:instance | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    instance_raw = decode_int(_data_raw_, running_bit_offset, 8)
    instance = master_dict['ENGINE_INSTANCE'].get(instance_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 2:oil_pressure | Offset: 8, Length: 16, Signed: False Resolution: 100, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    oil_pressure = oil_pressure_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 100)
    nmea2000Message.fields.append(NMEA2000Field('oil_pressure', 'Oil pressure', None, 'Pa', oil_pressure, oil_pressure_raw, PhysicalQuantities.PRESSURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:oil_temperature | Offset: 24, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    oil_temperature = oil_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('oil_temperature', 'Oil temperature', None, 'K', oil_temperature, oil_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:temperature | Offset: 40, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    temperature = temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('temperature', 'Temperature', None, 'K', temperature, temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:alternator_potential | Offset: 56, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    alternator_potential = alternator_potential_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('alternator_potential', 'Alternator Potential', None, 'V', alternator_potential, alternator_potential_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:fuel_rate | Offset: 72, Length: 16, Signed: True Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    fuel_rate = fuel_rate_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('fuel_rate', 'Fuel Rate', None, 'L/h', fuel_rate, fuel_rate_raw, PhysicalQuantities.VOLUMETRIC_FLOW, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:total_engine_hours | Offset: 88, Length: 32, Signed: False Resolution: 1, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    total_engine_hours_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    total_engine_hours = decode_time(total_engine_hours_raw)
    nmea2000Message.fields.append(NMEA2000Field('total_engine_hours', 'Total Engine hours', None, 's', total_engine_hours, total_engine_hours_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 8:coolant_pressure | Offset: 120, Length: 16, Signed: False Resolution: 100, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    coolant_pressure = coolant_pressure_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 100)
    nmea2000Message.fields.append(NMEA2000Field('coolant_pressure', 'Coolant Pressure', None, 'Pa', coolant_pressure, coolant_pressure_raw, PhysicalQuantities.PRESSURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:fuel_pressure | Offset: 136, Length: 16, Signed: False Resolution: 1000, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 136
    fuel_pressure = fuel_pressure_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1000)
    nmea2000Message.fields.append(NMEA2000Field('fuel_pressure', 'Fuel Pressure', None, 'Pa', fuel_pressure, fuel_pressure_raw, PhysicalQuantities.PRESSURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 10:reserved_152 | Offset: 152, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 152
    reserved_152 = reserved_152_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_152', 'Reserved', None, None, reserved_152, reserved_152_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 11:discrete_status_1 | Offset: 160, Length: 16, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 160
    discrete_status_1_raw = decode_int(_data_raw_, running_bit_offset, 16)
    discrete_status_1 = decode_bit_lookup(discrete_status_1_raw, master_flags_dict['ENGINE_STATUS_1'])
    nmea2000Message.fields.append(NMEA2000Field('discrete_status_1', 'Discrete Status 1', None, None, discrete_status_1, discrete_status_1_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 16

    # 12:discrete_status_2 | Offset: 176, Length: 16, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 176
    discrete_status_2_raw = decode_int(_data_raw_, running_bit_offset, 16)
    discrete_status_2 = decode_bit_lookup(discrete_status_2_raw, master_flags_dict['ENGINE_STATUS_2'])
    nmea2000Message.fields.append(NMEA2000Field('discrete_status_2', 'Discrete Status 2', None, None, discrete_status_2, discrete_status_2_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 16

    # 13:engine_load | Offset: 192, Length: 8, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 192
    engine_load = engine_load_raw = decode_number(_data_raw_, running_bit_offset, 8, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('engine_load', 'Engine Load', None, '%', engine_load, engine_load_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 14:engine_torque | Offset: 200, Length: 8, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 200
    engine_torque = engine_torque_raw = decode_number(_data_raw_, running_bit_offset, 8, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('engine_torque', 'Engine Torque', None, '%', engine_torque, engine_torque_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_127489(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127489."""
    data_raw = 0
    # instance | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENGINE_INSTANCE(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # oil_pressure | Offset: 8, Length: 16, Resolution: 100, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'oil_pressure')
    if field is None:
        raise Exception("Cant encode this message, missing 'Oil pressure'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 100) & 0xFFFF) << 8
    
    # oil_temperature | Offset: 24, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'oil_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Oil temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 24
    
    # temperature | Offset: 40, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 40
    
    # alternator_potential | Offset: 56, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'alternator_potential')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alternator Potential'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 56
    
    # fuel_rate | Offset: 72, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'fuel_rate')
    if field is None:
        raise Exception("Cant encode this message, missing 'Fuel Rate'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 72
    
    # total_engine_hours | Offset: 88, Length: 32, Resolution: 1, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'total_engine_hours')
    if field is None:
        raise Exception("Cant encode this message, missing 'Total Engine hours'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 88
    # coolant_pressure | Offset: 120, Length: 16, Resolution: 100, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'coolant_pressure')
    if field is None:
        raise Exception("Cant encode this message, missing 'Coolant Pressure'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 100) & 0xFFFF) << 120
    
    # fuel_pressure | Offset: 136, Length: 16, Resolution: 1000, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'fuel_pressure')
    if field is None:
        raise Exception("Cant encode this message, missing 'Fuel Pressure'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1000) & 0xFFFF) << 136
    
    # reserved_152 | Offset: 152, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_152')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 152
    # discrete_status_1 | Offset: 160, Length: 16, Resolution: 1, Field Type: BITLOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'discrete_status_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Discrete Status 1'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 160
    # discrete_status_2 | Offset: 176, Length: 16, Resolution: 1, Field Type: BITLOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'discrete_status_2')
    if field is None:
        raise Exception("Cant encode this message, missing 'Discrete Status 2'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 176
    # engine_load | Offset: 192, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'engine_load')
    if field is None:
        raise Exception("Cant encode this message, missing 'Engine Load'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 192
    # engine_torque | Offset: 200, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'engine_torque')
    if field is None:
        raise Exception("Cant encode this message, missing 'Engine Torque'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 200
    return data_raw


def is_fast_pgn_127490() -> bool:
    """Return True if PGN 127490 is a fast PGN."""
    return True
def decode_pgn_127490(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127490."""
    nmea2000Message = NMEA2000Message(127490, 'electricDriveStatusDynamic', 'Electric Drive Status, Dynamic')
    running_bit_offset = 0
    # 1:inverter_motor_identifier | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    inverter_motor_identifier = inverter_motor_identifier_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('inverter_motor_identifier', 'Inverter/Motor Identifier', None, None, inverter_motor_identifier, inverter_motor_identifier_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 2:operating_mode | Offset: 8, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    operating_mode = operating_mode_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('operating_mode', 'Operating Mode', None, None, operating_mode, operating_mode_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 3:reserved_12 | Offset: 12, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 12
    reserved_12 = reserved_12_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_12', 'Reserved', None, None, reserved_12, reserved_12_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 4:motor_temperature | Offset: 16, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    motor_temperature = motor_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('motor_temperature', 'Motor Temperature', None, 'K', motor_temperature, motor_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:inverter_temperature | Offset: 32, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    inverter_temperature = inverter_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('inverter_temperature', 'Inverter Temperature', None, 'K', inverter_temperature, inverter_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:coolant_temperature | Offset: 48, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    coolant_temperature = coolant_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('coolant_temperature', 'Coolant Temperature', None, 'K', coolant_temperature, coolant_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:gear_temperature | Offset: 64, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    gear_temperature = gear_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('gear_temperature', 'Gear Temperature', None, 'K', gear_temperature, gear_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:shaft_torque | Offset: 80, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    shaft_torque = shaft_torque_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('shaft_torque', 'Shaft Torque', None, None, shaft_torque, shaft_torque_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_127490(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127490."""
    data_raw = 0
    # inverter_motor_identifier | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'inverter_motor_identifier')
    if field is None:
        raise Exception("Cant encode this message, missing 'Inverter/Motor Identifier'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # operating_mode | Offset: 8, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'operating_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Operating Mode'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 8
    # reserved_12 | Offset: 12, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_12')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 12
    # motor_temperature | Offset: 16, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'motor_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Motor Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 16
    
    # inverter_temperature | Offset: 32, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'inverter_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Inverter Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 32
    
    # coolant_temperature | Offset: 48, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'coolant_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Coolant Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 48
    
    # gear_temperature | Offset: 64, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'gear_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Gear Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 64
    
    # shaft_torque | Offset: 80, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'shaft_torque')
    if field is None:
        raise Exception("Cant encode this message, missing 'Shaft Torque'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 80
    return data_raw


def is_fast_pgn_127491() -> bool:
    """Return True if PGN 127491 is a fast PGN."""
    return True
def decode_pgn_127491(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127491."""
    nmea2000Message = NMEA2000Message(127491, 'electricEnergyStorageStatusDynamic', 'Electric Energy Storage Status, Dynamic')
    running_bit_offset = 0
    # 1:energy_storage_identifier | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    energy_storage_identifier = energy_storage_identifier_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('energy_storage_identifier', 'Energy Storage Identifier', None, None, energy_storage_identifier, energy_storage_identifier_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 2:state_of_charge | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    state_of_charge = state_of_charge_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('state_of_charge', 'State of Charge', None, None, state_of_charge, state_of_charge_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:time_remaining | Offset: 16, Length: 16, Signed: False Resolution: 60, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    time_remaining_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 60)
    time_remaining = decode_time(time_remaining_raw)
    nmea2000Message.fields.append(NMEA2000Field('time_remaining', 'Time Remaining', "Time remaining at current rate of discharge", 's', time_remaining, time_remaining_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    # 4:highest_cell_temperature | Offset: 32, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    highest_cell_temperature = highest_cell_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('highest_cell_temperature', 'Highest Cell Temperature', None, 'K', highest_cell_temperature, highest_cell_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:lowest_cell_temperature | Offset: 48, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    lowest_cell_temperature = lowest_cell_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('lowest_cell_temperature', 'Lowest Cell Temperature', None, 'K', lowest_cell_temperature, lowest_cell_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:average_cell_temperature | Offset: 64, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    average_cell_temperature = average_cell_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('average_cell_temperature', 'Average Cell Temperature', None, 'K', average_cell_temperature, average_cell_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:max_discharge_current | Offset: 80, Length: 16, Signed: True Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    max_discharge_current = max_discharge_current_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('max_discharge_current', 'Max Discharge Current', None, 'A', max_discharge_current, max_discharge_current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:max_charge_current | Offset: 96, Length: 16, Signed: True Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 96
    max_charge_current = max_charge_current_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('max_charge_current', 'Max Charge Current', None, 'A', max_charge_current, max_charge_current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:cooling_system_status | Offset: 112, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    cooling_system_status = cooling_system_status_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('cooling_system_status', 'Cooling System Status', None, None, cooling_system_status, cooling_system_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 10:heating_system_status | Offset: 116, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 116
    heating_system_status = heating_system_status_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('heating_system_status', 'Heating System Status', None, None, heating_system_status, heating_system_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    return nmea2000Message

def encode_pgn_127491(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127491."""
    data_raw = 0
    # energy_storage_identifier | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'energy_storage_identifier')
    if field is None:
        raise Exception("Cant encode this message, missing 'Energy Storage Identifier'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # state_of_charge | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'state_of_charge')
    if field is None:
        raise Exception("Cant encode this message, missing 'State of Charge'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # time_remaining | Offset: 16, Length: 16, Resolution: 60, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'time_remaining')
    if field is None:
        raise Exception("Cant encode this message, missing 'Time Remaining'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 60) & 0xFFFF) << 16
    
    # highest_cell_temperature | Offset: 32, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'highest_cell_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Highest Cell Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 32
    
    # lowest_cell_temperature | Offset: 48, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'lowest_cell_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Lowest Cell Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 48
    
    # average_cell_temperature | Offset: 64, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'average_cell_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Average Cell Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 64
    
    # max_discharge_current | Offset: 80, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'max_discharge_current')
    if field is None:
        raise Exception("Cant encode this message, missing 'Max Discharge Current'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 80
    
    # max_charge_current | Offset: 96, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'max_charge_current')
    if field is None:
        raise Exception("Cant encode this message, missing 'Max Charge Current'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 96
    
    # cooling_system_status | Offset: 112, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'cooling_system_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Cooling System Status'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 112
    # heating_system_status | Offset: 116, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'heating_system_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Heating System Status'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 116
    return data_raw


def is_fast_pgn_127493() -> bool:
    """Return True if PGN 127493 is a fast PGN."""
    return False
def decode_pgn_127493(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127493."""
    nmea2000Message = NMEA2000Message(127493, 'transmissionParametersDynamic', 'Transmission Parameters, Dynamic')
    running_bit_offset = 0
    # 1:instance | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    instance_raw = decode_int(_data_raw_, running_bit_offset, 8)
    instance = master_dict['ENGINE_INSTANCE'].get(instance_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 2:transmission_gear | Offset: 8, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    transmission_gear_raw = decode_int(_data_raw_, running_bit_offset, 2)
    transmission_gear = master_dict['GEAR_STATUS'].get(transmission_gear_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('transmission_gear', 'Transmission Gear', None, None, transmission_gear, transmission_gear_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:reserved_10 | Offset: 10, Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 10
    reserved_10 = reserved_10_raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_10', 'Reserved', None, None, reserved_10, reserved_10_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    # 4:oil_pressure | Offset: 16, Length: 16, Signed: False Resolution: 100, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    oil_pressure = oil_pressure_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 100)
    nmea2000Message.fields.append(NMEA2000Field('oil_pressure', 'Oil pressure', None, 'Pa', oil_pressure, oil_pressure_raw, PhysicalQuantities.PRESSURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:oil_temperature | Offset: 32, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    oil_temperature = oil_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('oil_temperature', 'Oil temperature', None, 'K', oil_temperature, oil_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:discrete_status_1 | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    discrete_status_1 = discrete_status_1_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('discrete_status_1', 'Discrete Status 1', None, None, discrete_status_1, discrete_status_1_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_127493(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127493."""
    data_raw = 0
    # instance | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENGINE_INSTANCE(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # transmission_gear | Offset: 8, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'transmission_gear')
    if field is None:
        raise Exception("Cant encode this message, missing 'Transmission Gear'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GEAR_STATUS(field.value)
    data_raw |= (field_value & 0x3) << 8
    # reserved_10 | Offset: 10, Length: 6, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_10')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 10
    # oil_pressure | Offset: 16, Length: 16, Resolution: 100, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'oil_pressure')
    if field is None:
        raise Exception("Cant encode this message, missing 'Oil pressure'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 100) & 0xFFFF) << 16
    
    # oil_temperature | Offset: 32, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'oil_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Oil temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 32
    
    # discrete_status_1 | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'discrete_status_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Discrete Status 1'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_127494() -> bool:
    """Return True if PGN 127494 is a fast PGN."""
    return True
def decode_pgn_127494(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127494."""
    nmea2000Message = NMEA2000Message(127494, 'electricDriveInformation', 'Electric Drive Information')
    running_bit_offset = 0
    # 1:inverter_motor_identifier | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    inverter_motor_identifier = inverter_motor_identifier_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('inverter_motor_identifier', 'Inverter/Motor Identifier', None, None, inverter_motor_identifier, inverter_motor_identifier_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 2:motor_type | Offset: 8, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    motor_type = motor_type_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('motor_type', 'Motor Type', None, None, motor_type, motor_type_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 3:reserved_12 | Offset: 12, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 12
    reserved_12 = reserved_12_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_12', 'Reserved', None, None, reserved_12, reserved_12_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 4:motor_voltage_rating | Offset: 16, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    motor_voltage_rating = motor_voltage_rating_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('motor_voltage_rating', 'Motor Voltage Rating', None, 'V', motor_voltage_rating, motor_voltage_rating_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:maximum_continuous_motor_power | Offset: 32, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    maximum_continuous_motor_power = maximum_continuous_motor_power_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('maximum_continuous_motor_power', 'Maximum Continuous Motor Power', None, 'W', maximum_continuous_motor_power, maximum_continuous_motor_power_raw, PhysicalQuantities.ELECTRICAL_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:maximum_boost_motor_power | Offset: 64, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    maximum_boost_motor_power = maximum_boost_motor_power_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('maximum_boost_motor_power', 'Maximum Boost Motor Power', None, 'W', maximum_boost_motor_power, maximum_boost_motor_power_raw, PhysicalQuantities.ELECTRICAL_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 7:maximum_motor_temperature_rating | Offset: 96, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 96
    maximum_motor_temperature_rating = maximum_motor_temperature_rating_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('maximum_motor_temperature_rating', 'Maximum Motor Temperature Rating', None, 'K', maximum_motor_temperature_rating, maximum_motor_temperature_rating_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:rated_motor_speed | Offset: 112, Length: 16, Signed: False Resolution: 0.25, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    rated_motor_speed = rated_motor_speed_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.25)
    nmea2000Message.fields.append(NMEA2000Field('rated_motor_speed', 'Rated Motor Speed', None, 'rpm', rated_motor_speed, rated_motor_speed_raw, PhysicalQuantities.ANGULAR_VELOCITY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:maximum_controller_temperature_rating | Offset: 128, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    maximum_controller_temperature_rating = maximum_controller_temperature_rating_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('maximum_controller_temperature_rating', 'Maximum Controller Temperature Rating', None, 'K', maximum_controller_temperature_rating, maximum_controller_temperature_rating_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 10:motor_shaft_torque_rating | Offset: 144, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    motor_shaft_torque_rating = motor_shaft_torque_rating_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('motor_shaft_torque_rating', 'Motor Shaft Torque Rating', None, None, motor_shaft_torque_rating, motor_shaft_torque_rating_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:motor_dc_voltage_derating_threshold | Offset: 160, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 160
    motor_dc_voltage_derating_threshold = motor_dc_voltage_derating_threshold_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('motor_dc_voltage_derating_threshold', 'Motor DC-Voltage Derating Threshold', None, 'V', motor_dc_voltage_derating_threshold, motor_dc_voltage_derating_threshold_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 12:motor_dc_voltage_cut_off_threshold | Offset: 176, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 176
    motor_dc_voltage_cut_off_threshold = motor_dc_voltage_cut_off_threshold_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('motor_dc_voltage_cut_off_threshold', 'Motor DC-Voltage Cut Off Threshold', None, 'V', motor_dc_voltage_cut_off_threshold, motor_dc_voltage_cut_off_threshold_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 13:drive_motor_hours | Offset: 192, Length: 32, Signed: False Resolution: 1, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 192
    drive_motor_hours_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    drive_motor_hours = decode_time(drive_motor_hours_raw)
    nmea2000Message.fields.append(NMEA2000Field('drive_motor_hours', 'Drive/Motor Hours', None, 's', drive_motor_hours, drive_motor_hours_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_127494(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127494."""
    data_raw = 0
    # inverter_motor_identifier | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'inverter_motor_identifier')
    if field is None:
        raise Exception("Cant encode this message, missing 'Inverter/Motor Identifier'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # motor_type | Offset: 8, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'motor_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Motor Type'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 8
    # reserved_12 | Offset: 12, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_12')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 12
    # motor_voltage_rating | Offset: 16, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'motor_voltage_rating')
    if field is None:
        raise Exception("Cant encode this message, missing 'Motor Voltage Rating'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 16
    
    # maximum_continuous_motor_power | Offset: 32, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'maximum_continuous_motor_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Maximum Continuous Motor Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    # maximum_boost_motor_power | Offset: 64, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'maximum_boost_motor_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Maximum Boost Motor Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 64
    # maximum_motor_temperature_rating | Offset: 96, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'maximum_motor_temperature_rating')
    if field is None:
        raise Exception("Cant encode this message, missing 'Maximum Motor Temperature Rating'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 96
    
    # rated_motor_speed | Offset: 112, Length: 16, Resolution: 0.25, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'rated_motor_speed')
    if field is None:
        raise Exception("Cant encode this message, missing 'Rated Motor Speed'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.25) & 0xFFFF) << 112
    
    # maximum_controller_temperature_rating | Offset: 128, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'maximum_controller_temperature_rating')
    if field is None:
        raise Exception("Cant encode this message, missing 'Maximum Controller Temperature Rating'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 128
    
    # motor_shaft_torque_rating | Offset: 144, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'motor_shaft_torque_rating')
    if field is None:
        raise Exception("Cant encode this message, missing 'Motor Shaft Torque Rating'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 144
    # motor_dc_voltage_derating_threshold | Offset: 160, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'motor_dc_voltage_derating_threshold')
    if field is None:
        raise Exception("Cant encode this message, missing 'Motor DC-Voltage Derating Threshold'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 160
    
    # motor_dc_voltage_cut_off_threshold | Offset: 176, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'motor_dc_voltage_cut_off_threshold')
    if field is None:
        raise Exception("Cant encode this message, missing 'Motor DC-Voltage Cut Off Threshold'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 176
    
    # drive_motor_hours | Offset: 192, Length: 32, Resolution: 1, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'drive_motor_hours')
    if field is None:
        raise Exception("Cant encode this message, missing 'Drive/Motor Hours'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 192
    return data_raw


def is_fast_pgn_127495() -> bool:
    """Return True if PGN 127495 is a fast PGN."""
    return True
def decode_pgn_127495(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127495."""
    nmea2000Message = NMEA2000Message(127495, 'electricEnergyStorageInformation', 'Electric Energy Storage Information')
    running_bit_offset = 0
    # 1:energy_storage_identifier | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    energy_storage_identifier = energy_storage_identifier_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('energy_storage_identifier', 'Energy Storage Identifier', None, None, energy_storage_identifier, energy_storage_identifier_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 2:motor_type | Offset: 8, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    motor_type = motor_type_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('motor_type', 'Motor Type', None, None, motor_type, motor_type_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 3:reserved_12 | Offset: 12, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 12
    reserved_12 = reserved_12_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_12', 'Reserved', None, None, reserved_12, reserved_12_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 4:storage_chemistry_conversion | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    storage_chemistry_conversion = storage_chemistry_conversion_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('storage_chemistry_conversion', 'Storage Chemistry/Conversion', None, None, storage_chemistry_conversion, storage_chemistry_conversion_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:maximum_temperature_derating | Offset: 24, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    maximum_temperature_derating = maximum_temperature_derating_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('maximum_temperature_derating', 'Maximum Temperature Derating', None, 'K', maximum_temperature_derating, maximum_temperature_derating_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:maximum_temperature_shut_off | Offset: 40, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    maximum_temperature_shut_off = maximum_temperature_shut_off_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('maximum_temperature_shut_off', 'Maximum Temperature Shut Off', None, 'K', maximum_temperature_shut_off, maximum_temperature_shut_off_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:minimum_temperature_derating | Offset: 56, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    minimum_temperature_derating = minimum_temperature_derating_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('minimum_temperature_derating', 'Minimum Temperature Derating', None, 'K', minimum_temperature_derating, minimum_temperature_derating_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:minimum_temperature_shut_off | Offset: 72, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    minimum_temperature_shut_off = minimum_temperature_shut_off_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('minimum_temperature_shut_off', 'Minimum Temperature Shut Off', None, 'K', minimum_temperature_shut_off, minimum_temperature_shut_off_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:usable_battery_energy | Offset: 88, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    usable_battery_energy = usable_battery_energy_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('usable_battery_energy', 'Usable Battery Energy', None, 'kWh', usable_battery_energy, usable_battery_energy_raw, PhysicalQuantities.ELECTRICAL_ENERGY, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 10:state_of_health | Offset: 120, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    state_of_health = state_of_health_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('state_of_health', 'State of Health', None, None, state_of_health, state_of_health_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 11:battery_cycle_counter | Offset: 128, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    battery_cycle_counter = battery_cycle_counter_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('battery_cycle_counter', 'Battery Cycle Counter', None, None, battery_cycle_counter, battery_cycle_counter_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 12:battery_full_status | Offset: 144, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    battery_full_status = battery_full_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('battery_full_status', 'Battery Full Status', None, None, battery_full_status, battery_full_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 13:battery_empty_status | Offset: 146, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 146
    battery_empty_status = battery_empty_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('battery_empty_status', 'Battery Empty Status', None, None, battery_empty_status, battery_empty_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 14:reserved_148 | Offset: 148, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 148
    reserved_148 = reserved_148_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_148', 'Reserved', None, None, reserved_148, reserved_148_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 15:maximum_charge__soc_ | Offset: 152, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 152
    maximum_charge__soc_ = maximum_charge__soc__raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('maximum_charge__soc_', 'Maximum Charge (SOC)', None, None, maximum_charge__soc_, maximum_charge__soc__raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 16:minimum_charge__soc_ | Offset: 160, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 160
    minimum_charge__soc_ = minimum_charge__soc__raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('minimum_charge__soc_', 'Minimum Charge (SOC)', None, None, minimum_charge__soc_, minimum_charge__soc__raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_127495(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127495."""
    data_raw = 0
    # energy_storage_identifier | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'energy_storage_identifier')
    if field is None:
        raise Exception("Cant encode this message, missing 'Energy Storage Identifier'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # motor_type | Offset: 8, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'motor_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Motor Type'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 8
    # reserved_12 | Offset: 12, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_12')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 12
    # storage_chemistry_conversion | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'storage_chemistry_conversion')
    if field is None:
        raise Exception("Cant encode this message, missing 'Storage Chemistry/Conversion'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # maximum_temperature_derating | Offset: 24, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'maximum_temperature_derating')
    if field is None:
        raise Exception("Cant encode this message, missing 'Maximum Temperature Derating'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 24
    
    # maximum_temperature_shut_off | Offset: 40, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'maximum_temperature_shut_off')
    if field is None:
        raise Exception("Cant encode this message, missing 'Maximum Temperature Shut Off'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 40
    
    # minimum_temperature_derating | Offset: 56, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'minimum_temperature_derating')
    if field is None:
        raise Exception("Cant encode this message, missing 'Minimum Temperature Derating'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 56
    
    # minimum_temperature_shut_off | Offset: 72, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'minimum_temperature_shut_off')
    if field is None:
        raise Exception("Cant encode this message, missing 'Minimum Temperature Shut Off'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 72
    
    # usable_battery_energy | Offset: 88, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'usable_battery_energy')
    if field is None:
        raise Exception("Cant encode this message, missing 'Usable Battery Energy'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 88
    # state_of_health | Offset: 120, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'state_of_health')
    if field is None:
        raise Exception("Cant encode this message, missing 'State of Health'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 120
    # battery_cycle_counter | Offset: 128, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'battery_cycle_counter')
    if field is None:
        raise Exception("Cant encode this message, missing 'Battery Cycle Counter'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 128
    # battery_full_status | Offset: 144, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'battery_full_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Battery Full Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 144
    # battery_empty_status | Offset: 146, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'battery_empty_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Battery Empty Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 146
    # reserved_148 | Offset: 148, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_148')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 148
    # maximum_charge__soc_ | Offset: 152, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'maximum_charge__soc_')
    if field is None:
        raise Exception("Cant encode this message, missing 'Maximum Charge (SOC)'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 152
    # minimum_charge__soc_ | Offset: 160, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'minimum_charge__soc_')
    if field is None:
        raise Exception("Cant encode this message, missing 'Minimum Charge (SOC)'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 160
    return data_raw


def is_fast_pgn_127496() -> bool:
    """Return True if PGN 127496 is a fast PGN."""
    return True
def decode_pgn_127496(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127496."""
    nmea2000Message = NMEA2000Message(127496, 'tripParametersVessel', 'Trip Parameters, Vessel')
    running_bit_offset = 0
    # 1:time_to_empty | Offset: 0, Length: 32, Signed: False Resolution: 0.001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    time_to_empty_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.001)
    time_to_empty = decode_time(time_to_empty_raw)
    nmea2000Message.fields.append(NMEA2000Field('time_to_empty', 'Time to Empty', None, 's', time_to_empty, time_to_empty_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 2:distance_to_empty | Offset: 32, Length: 32, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    distance_to_empty = distance_to_empty_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('distance_to_empty', 'Distance to Empty', None, 'm', distance_to_empty, distance_to_empty_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 3:estimated_fuel_remaining | Offset: 64, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    estimated_fuel_remaining = estimated_fuel_remaining_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('estimated_fuel_remaining', 'Estimated Fuel Remaining', None, 'L', estimated_fuel_remaining, estimated_fuel_remaining_raw, PhysicalQuantities.VOLUME, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:trip_run_time | Offset: 80, Length: 32, Signed: False Resolution: 0.001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    trip_run_time_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.001)
    trip_run_time = decode_time(trip_run_time_raw)
    nmea2000Message.fields.append(NMEA2000Field('trip_run_time', 'Trip Run Time', None, 's', trip_run_time, trip_run_time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_127496(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127496."""
    data_raw = 0
    # time_to_empty | Offset: 0, Length: 32, Resolution: 0.001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'time_to_empty')
    if field is None:
        raise Exception("Cant encode this message, missing 'Time to Empty'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFFFFFF) << 0
    
    # distance_to_empty | Offset: 32, Length: 32, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'distance_to_empty')
    if field is None:
        raise Exception("Cant encode this message, missing 'Distance to Empty'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFFFFFF) << 32
    
    # estimated_fuel_remaining | Offset: 64, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'estimated_fuel_remaining')
    if field is None:
        raise Exception("Cant encode this message, missing 'Estimated Fuel Remaining'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 64
    # trip_run_time | Offset: 80, Length: 32, Resolution: 0.001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'trip_run_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Trip Run Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFFFFFF) << 80
    
    return data_raw


def is_fast_pgn_127497() -> bool:
    """Return True if PGN 127497 is a fast PGN."""
    return True
def decode_pgn_127497(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127497."""
    nmea2000Message = NMEA2000Message(127497, 'tripParametersEngine', 'Trip Parameters, Engine')
    running_bit_offset = 0
    # 1:instance | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    instance_raw = decode_int(_data_raw_, running_bit_offset, 8)
    instance = master_dict['ENGINE_INSTANCE'].get(instance_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 2:trip_fuel_used | Offset: 8, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    trip_fuel_used = trip_fuel_used_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('trip_fuel_used', 'Trip Fuel Used', None, 'L', trip_fuel_used, trip_fuel_used_raw, PhysicalQuantities.VOLUME, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:fuel_rate__average | Offset: 24, Length: 16, Signed: True Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    fuel_rate__average = fuel_rate__average_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('fuel_rate__average', 'Fuel Rate, Average', None, 'L/h', fuel_rate__average, fuel_rate__average_raw, PhysicalQuantities.VOLUMETRIC_FLOW, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:fuel_rate__economy | Offset: 40, Length: 16, Signed: True Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    fuel_rate__economy = fuel_rate__economy_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('fuel_rate__economy', 'Fuel Rate, Economy', None, 'L/h', fuel_rate__economy, fuel_rate__economy_raw, PhysicalQuantities.VOLUMETRIC_FLOW, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:instantaneous_fuel_economy | Offset: 56, Length: 16, Signed: True Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    instantaneous_fuel_economy = instantaneous_fuel_economy_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('instantaneous_fuel_economy', 'Instantaneous Fuel Economy', None, 'L/h', instantaneous_fuel_economy, instantaneous_fuel_economy_raw, PhysicalQuantities.VOLUMETRIC_FLOW, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_127497(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127497."""
    data_raw = 0
    # instance | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENGINE_INSTANCE(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # trip_fuel_used | Offset: 8, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'trip_fuel_used')
    if field is None:
        raise Exception("Cant encode this message, missing 'Trip Fuel Used'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 8
    # fuel_rate__average | Offset: 24, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'fuel_rate__average')
    if field is None:
        raise Exception("Cant encode this message, missing 'Fuel Rate, Average'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 24
    
    # fuel_rate__economy | Offset: 40, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'fuel_rate__economy')
    if field is None:
        raise Exception("Cant encode this message, missing 'Fuel Rate, Economy'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 40
    
    # instantaneous_fuel_economy | Offset: 56, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instantaneous_fuel_economy')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instantaneous Fuel Economy'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 56
    
    return data_raw


def is_fast_pgn_127498() -> bool:
    """Return True if PGN 127498 is a fast PGN."""
    return True
def decode_pgn_127498(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127498."""
    nmea2000Message = NMEA2000Message(127498, 'engineParametersStatic', 'Engine Parameters, Static')
    running_bit_offset = 0
    # 1:instance | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    instance_raw = decode_int(_data_raw_, running_bit_offset, 8)
    instance = master_dict['ENGINE_INSTANCE'].get(instance_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 2:rated_engine_speed | Offset: 8, Length: 16, Signed: False Resolution: 0.25, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    rated_engine_speed = rated_engine_speed_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.25)
    nmea2000Message.fields.append(NMEA2000Field('rated_engine_speed', 'Rated Engine Speed', None, 'rpm', rated_engine_speed, rated_engine_speed_raw, PhysicalQuantities.ANGULAR_VELOCITY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:vin | Offset: 24, Length: 136, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    vin = vin_raw = decode_string_fix(_data_raw_, running_bit_offset, 136)
    nmea2000Message.fields.append(NMEA2000Field('vin', 'VIN', None, None, vin, vin_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 136

    # 4:software_id | Offset: 160, Length: 256, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 160
    software_id = software_id_raw = decode_string_fix(_data_raw_, running_bit_offset, 256)
    nmea2000Message.fields.append(NMEA2000Field('software_id', 'Software ID', None, None, software_id, software_id_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 256

    return nmea2000Message

def encode_pgn_127498(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127498."""
    data_raw = 0
    # instance | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENGINE_INSTANCE(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # rated_engine_speed | Offset: 8, Length: 16, Resolution: 0.25, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'rated_engine_speed')
    if field is None:
        raise Exception("Cant encode this message, missing 'Rated Engine Speed'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.25) & 0xFFFF) << 8
    
    # vin | Offset: 24, Length: 136, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'vin')
    if field is None:
        raise Exception("Cant encode this message, missing 'VIN'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 24
    # software_id | Offset: 160, Length: 256, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'software_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Software ID'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 160
    return data_raw


def is_fast_pgn_127500() -> bool:
    """Return True if PGN 127500 is a fast PGN."""
    return False
def decode_pgn_127500(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127500."""
    nmea2000Message = NMEA2000Message(127500, 'loadControllerConnectionStateControl', 'Load Controller Connection State/Control')
    running_bit_offset = 0
    # 1:sequence_id | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sequence_id = sequence_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sequence_id', 'Sequence ID', None, None, sequence_id, sequence_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:connection_id | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    connection_id = connection_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('connection_id', 'Connection ID', None, None, connection_id, connection_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:state | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    state = state_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('state', 'State', None, None, state, state_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:status | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    status = status_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('status', 'Status', None, None, status, status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:operational_status___control | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    operational_status___control = operational_status___control_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('operational_status___control', 'Operational Status & Control', None, None, operational_status___control, operational_status___control_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:pwm_duty_cycle | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    pwm_duty_cycle = pwm_duty_cycle_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('pwm_duty_cycle', 'PWM Duty Cycle', None, None, pwm_duty_cycle, pwm_duty_cycle_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:timeon | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    timeon = timeon_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('timeon', 'TimeON', None, None, timeon, timeon_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:timeoff | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    timeoff = timeoff_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('timeoff', 'TimeOFF', None, None, timeoff, timeoff_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_127500(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127500."""
    data_raw = 0
    # sequence_id | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sequence_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Sequence ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # connection_id | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'connection_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Connection ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # state | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'state')
    if field is None:
        raise Exception("Cant encode this message, missing 'State'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # status | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Status'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # operational_status___control | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'operational_status___control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Operational Status & Control'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # pwm_duty_cycle | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pwm_duty_cycle')
    if field is None:
        raise Exception("Cant encode this message, missing 'PWM Duty Cycle'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # timeon | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'timeon')
    if field is None:
        raise Exception("Cant encode this message, missing 'TimeON'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # timeoff | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'timeoff')
    if field is None:
        raise Exception("Cant encode this message, missing 'TimeOFF'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_127501() -> bool:
    """Return True if PGN 127501 is a fast PGN."""
    return False
def decode_pgn_127501(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127501."""
    nmea2000Message = NMEA2000Message(127501, 'binarySwitchBankStatus', 'Binary Switch Bank Status')
    running_bit_offset = 0
    # 1:instance | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 2:indicator1 | Offset: 8, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    indicator1_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator1 = master_dict['OFF_ON'].get(indicator1_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator1', 'Indicator1', None, None, indicator1, indicator1_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:indicator2 | Offset: 10, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 10
    indicator2_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator2 = master_dict['OFF_ON'].get(indicator2_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator2', 'Indicator2', None, None, indicator2, indicator2_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:indicator3 | Offset: 12, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 12
    indicator3_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator3 = master_dict['OFF_ON'].get(indicator3_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator3', 'Indicator3', None, None, indicator3, indicator3_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 5:indicator4 | Offset: 14, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 14
    indicator4_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator4 = master_dict['OFF_ON'].get(indicator4_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator4', 'Indicator4', None, None, indicator4, indicator4_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 6:indicator5 | Offset: 16, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    indicator5_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator5 = master_dict['OFF_ON'].get(indicator5_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator5', 'Indicator5', None, None, indicator5, indicator5_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 7:indicator6 | Offset: 18, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 18
    indicator6_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator6 = master_dict['OFF_ON'].get(indicator6_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator6', 'Indicator6', None, None, indicator6, indicator6_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 8:indicator7 | Offset: 20, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 20
    indicator7_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator7 = master_dict['OFF_ON'].get(indicator7_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator7', 'Indicator7', None, None, indicator7, indicator7_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 9:indicator8 | Offset: 22, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 22
    indicator8_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator8 = master_dict['OFF_ON'].get(indicator8_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator8', 'Indicator8', None, None, indicator8, indicator8_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 10:indicator9 | Offset: 24, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    indicator9_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator9 = master_dict['OFF_ON'].get(indicator9_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator9', 'Indicator9', None, None, indicator9, indicator9_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 11:indicator10 | Offset: 26, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 26
    indicator10_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator10 = master_dict['OFF_ON'].get(indicator10_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator10', 'Indicator10', None, None, indicator10, indicator10_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 12:indicator11 | Offset: 28, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 28
    indicator11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator11 = master_dict['OFF_ON'].get(indicator11_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator11', 'Indicator11', None, None, indicator11, indicator11_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 13:indicator12 | Offset: 30, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 30
    indicator12_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator12 = master_dict['OFF_ON'].get(indicator12_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator12', 'Indicator12', None, None, indicator12, indicator12_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 14:indicator13 | Offset: 32, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    indicator13_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator13 = master_dict['OFF_ON'].get(indicator13_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator13', 'Indicator13', None, None, indicator13, indicator13_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 15:indicator14 | Offset: 34, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 34
    indicator14_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator14 = master_dict['OFF_ON'].get(indicator14_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator14', 'Indicator14', None, None, indicator14, indicator14_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 16:indicator15 | Offset: 36, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 36
    indicator15_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator15 = master_dict['OFF_ON'].get(indicator15_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator15', 'Indicator15', None, None, indicator15, indicator15_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 17:indicator16 | Offset: 38, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 38
    indicator16_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator16 = master_dict['OFF_ON'].get(indicator16_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator16', 'Indicator16', None, None, indicator16, indicator16_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 18:indicator17 | Offset: 40, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    indicator17_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator17 = master_dict['OFF_ON'].get(indicator17_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator17', 'Indicator17', None, None, indicator17, indicator17_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 19:indicator18 | Offset: 42, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 42
    indicator18_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator18 = master_dict['OFF_ON'].get(indicator18_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator18', 'Indicator18', None, None, indicator18, indicator18_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 20:indicator19 | Offset: 44, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 44
    indicator19_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator19 = master_dict['OFF_ON'].get(indicator19_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator19', 'Indicator19', None, None, indicator19, indicator19_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 21:indicator20 | Offset: 46, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 46
    indicator20_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator20 = master_dict['OFF_ON'].get(indicator20_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator20', 'Indicator20', None, None, indicator20, indicator20_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 22:indicator21 | Offset: 48, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    indicator21_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator21 = master_dict['OFF_ON'].get(indicator21_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator21', 'Indicator21', None, None, indicator21, indicator21_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 23:indicator22 | Offset: 50, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 50
    indicator22_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator22 = master_dict['OFF_ON'].get(indicator22_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator22', 'Indicator22', None, None, indicator22, indicator22_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 24:indicator23 | Offset: 52, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 52
    indicator23_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator23 = master_dict['OFF_ON'].get(indicator23_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator23', 'Indicator23', None, None, indicator23, indicator23_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 25:indicator24 | Offset: 54, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 54
    indicator24_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator24 = master_dict['OFF_ON'].get(indicator24_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator24', 'Indicator24', None, None, indicator24, indicator24_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 26:indicator25 | Offset: 56, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    indicator25_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator25 = master_dict['OFF_ON'].get(indicator25_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator25', 'Indicator25', None, None, indicator25, indicator25_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 27:indicator26 | Offset: 58, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 58
    indicator26_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator26 = master_dict['OFF_ON'].get(indicator26_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator26', 'Indicator26', None, None, indicator26, indicator26_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 28:indicator27 | Offset: 60, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 60
    indicator27_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator27 = master_dict['OFF_ON'].get(indicator27_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator27', 'Indicator27', None, None, indicator27, indicator27_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 29:indicator28 | Offset: 62, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 62
    indicator28_raw = decode_int(_data_raw_, running_bit_offset, 2)
    indicator28 = master_dict['OFF_ON'].get(indicator28_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('indicator28', 'Indicator28', None, None, indicator28, indicator28_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    return nmea2000Message

def encode_pgn_127501(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127501."""
    data_raw = 0
    # instance | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # indicator1 | Offset: 8, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator1'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 8
    # indicator2 | Offset: 10, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator2')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator2'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 10
    # indicator3 | Offset: 12, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator3')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator3'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 12
    # indicator4 | Offset: 14, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator4')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator4'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 14
    # indicator5 | Offset: 16, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator5')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator5'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 16
    # indicator6 | Offset: 18, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator6')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator6'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 18
    # indicator7 | Offset: 20, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator7')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator7'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 20
    # indicator8 | Offset: 22, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator8')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator8'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 22
    # indicator9 | Offset: 24, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator9')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator9'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 24
    # indicator10 | Offset: 26, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator10')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator10'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 26
    # indicator11 | Offset: 28, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator11'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 28
    # indicator12 | Offset: 30, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator12')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator12'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 30
    # indicator13 | Offset: 32, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator13')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator13'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 32
    # indicator14 | Offset: 34, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator14')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator14'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 34
    # indicator15 | Offset: 36, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator15')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator15'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 36
    # indicator16 | Offset: 38, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator16'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 38
    # indicator17 | Offset: 40, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator17')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator17'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 40
    # indicator18 | Offset: 42, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator18')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator18'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 42
    # indicator19 | Offset: 44, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator19')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator19'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 44
    # indicator20 | Offset: 46, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator20')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator20'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 46
    # indicator21 | Offset: 48, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator21')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator21'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 48
    # indicator22 | Offset: 50, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator22')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator22'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 50
    # indicator23 | Offset: 52, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator23')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator23'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 52
    # indicator24 | Offset: 54, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator24')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator24'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 54
    # indicator25 | Offset: 56, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator25')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator25'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 56
    # indicator26 | Offset: 58, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator26')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator26'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 58
    # indicator27 | Offset: 60, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator27')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator27'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 60
    # indicator28 | Offset: 62, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator28')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator28'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 62
    return data_raw


def is_fast_pgn_127502() -> bool:
    """Return True if PGN 127502 is a fast PGN."""
    return False
def decode_pgn_127502(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127502."""
    nmea2000Message = NMEA2000Message(127502, 'switchBankControl', 'Switch Bank Control')
    running_bit_offset = 0
    # 1:instance | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 2:switch1 | Offset: 8, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    switch1_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch1 = master_dict['OFF_ON'].get(switch1_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch1', 'Switch1', None, None, switch1, switch1_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:switch2 | Offset: 10, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 10
    switch2_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch2 = master_dict['OFF_ON'].get(switch2_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch2', 'Switch2', None, None, switch2, switch2_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:switch3 | Offset: 12, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 12
    switch3_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch3 = master_dict['OFF_ON'].get(switch3_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch3', 'Switch3', None, None, switch3, switch3_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 5:switch4 | Offset: 14, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 14
    switch4_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch4 = master_dict['OFF_ON'].get(switch4_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch4', 'Switch4', None, None, switch4, switch4_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 6:switch5 | Offset: 16, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    switch5_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch5 = master_dict['OFF_ON'].get(switch5_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch5', 'Switch5', None, None, switch5, switch5_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 7:switch6 | Offset: 18, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 18
    switch6_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch6 = master_dict['OFF_ON'].get(switch6_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch6', 'Switch6', None, None, switch6, switch6_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 8:switch7 | Offset: 20, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 20
    switch7_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch7 = master_dict['OFF_ON'].get(switch7_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch7', 'Switch7', None, None, switch7, switch7_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 9:switch8 | Offset: 22, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 22
    switch8_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch8 = master_dict['OFF_ON'].get(switch8_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch8', 'Switch8', None, None, switch8, switch8_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 10:switch9 | Offset: 24, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    switch9_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch9 = master_dict['OFF_ON'].get(switch9_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch9', 'Switch9', None, None, switch9, switch9_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 11:switch10 | Offset: 26, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 26
    switch10_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch10 = master_dict['OFF_ON'].get(switch10_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch10', 'Switch10', None, None, switch10, switch10_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 12:switch11 | Offset: 28, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 28
    switch11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch11 = master_dict['OFF_ON'].get(switch11_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch11', 'Switch11', None, None, switch11, switch11_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 13:switch12 | Offset: 30, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 30
    switch12_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch12 = master_dict['OFF_ON'].get(switch12_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch12', 'Switch12', None, None, switch12, switch12_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 14:switch13 | Offset: 32, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    switch13_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch13 = master_dict['OFF_ON'].get(switch13_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch13', 'Switch13', None, None, switch13, switch13_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 15:switch14 | Offset: 34, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 34
    switch14_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch14 = master_dict['OFF_ON'].get(switch14_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch14', 'Switch14', None, None, switch14, switch14_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 16:switch15 | Offset: 36, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 36
    switch15_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch15 = master_dict['OFF_ON'].get(switch15_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch15', 'Switch15', None, None, switch15, switch15_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 17:switch16 | Offset: 38, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 38
    switch16_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch16 = master_dict['OFF_ON'].get(switch16_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch16', 'Switch16', None, None, switch16, switch16_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 18:switch17 | Offset: 40, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    switch17_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch17 = master_dict['OFF_ON'].get(switch17_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch17', 'Switch17', None, None, switch17, switch17_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 19:switch18 | Offset: 42, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 42
    switch18_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch18 = master_dict['OFF_ON'].get(switch18_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch18', 'Switch18', None, None, switch18, switch18_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 20:switch19 | Offset: 44, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 44
    switch19_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch19 = master_dict['OFF_ON'].get(switch19_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch19', 'Switch19', None, None, switch19, switch19_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 21:switch20 | Offset: 46, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 46
    switch20_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch20 = master_dict['OFF_ON'].get(switch20_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch20', 'Switch20', None, None, switch20, switch20_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 22:switch21 | Offset: 48, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    switch21_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch21 = master_dict['OFF_ON'].get(switch21_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch21', 'Switch21', None, None, switch21, switch21_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 23:switch22 | Offset: 50, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 50
    switch22_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch22 = master_dict['OFF_ON'].get(switch22_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch22', 'Switch22', None, None, switch22, switch22_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 24:switch23 | Offset: 52, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 52
    switch23_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch23 = master_dict['OFF_ON'].get(switch23_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch23', 'Switch23', None, None, switch23, switch23_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 25:switch24 | Offset: 54, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 54
    switch24_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch24 = master_dict['OFF_ON'].get(switch24_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch24', 'Switch24', None, None, switch24, switch24_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 26:switch25 | Offset: 56, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    switch25_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch25 = master_dict['OFF_ON'].get(switch25_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch25', 'Switch25', None, None, switch25, switch25_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 27:switch26 | Offset: 58, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 58
    switch26_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch26 = master_dict['OFF_ON'].get(switch26_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch26', 'Switch26', None, None, switch26, switch26_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 28:switch27 | Offset: 60, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 60
    switch27_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch27 = master_dict['OFF_ON'].get(switch27_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch27', 'Switch27', None, None, switch27, switch27_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 29:switch28 | Offset: 62, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 62
    switch28_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch28 = master_dict['OFF_ON'].get(switch28_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch28', 'Switch28', None, None, switch28, switch28_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    return nmea2000Message

def encode_pgn_127502(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127502."""
    data_raw = 0
    # instance | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # switch1 | Offset: 8, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch1'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 8
    # switch2 | Offset: 10, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch2')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch2'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 10
    # switch3 | Offset: 12, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch3')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch3'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 12
    # switch4 | Offset: 14, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch4')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch4'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 14
    # switch5 | Offset: 16, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch5')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch5'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 16
    # switch6 | Offset: 18, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch6')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch6'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 18
    # switch7 | Offset: 20, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch7')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch7'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 20
    # switch8 | Offset: 22, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch8')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch8'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 22
    # switch9 | Offset: 24, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch9')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch9'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 24
    # switch10 | Offset: 26, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch10')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch10'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 26
    # switch11 | Offset: 28, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch11'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 28
    # switch12 | Offset: 30, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch12')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch12'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 30
    # switch13 | Offset: 32, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch13')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch13'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 32
    # switch14 | Offset: 34, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch14')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch14'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 34
    # switch15 | Offset: 36, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch15')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch15'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 36
    # switch16 | Offset: 38, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch16'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 38
    # switch17 | Offset: 40, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch17')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch17'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 40
    # switch18 | Offset: 42, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch18')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch18'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 42
    # switch19 | Offset: 44, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch19')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch19'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 44
    # switch20 | Offset: 46, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch20')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch20'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 46
    # switch21 | Offset: 48, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch21')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch21'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 48
    # switch22 | Offset: 50, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch22')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch22'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 50
    # switch23 | Offset: 52, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch23')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch23'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 52
    # switch24 | Offset: 54, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch24')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch24'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 54
    # switch25 | Offset: 56, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch25')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch25'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 56
    # switch26 | Offset: 58, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch26')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch26'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 58
    # switch27 | Offset: 60, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch27')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch27'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 60
    # switch28 | Offset: 62, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch28')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch28'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 62
    return data_raw


def is_fast_pgn_127503() -> bool:
    """Return True if PGN 127503 is a fast PGN."""
    return True
def decode_pgn_127503(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127503."""
    nmea2000Message = NMEA2000Message(127503, 'acInputStatus', 'AC Input Status')
    running_bit_offset = 0
    # 1:instance | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 2:number_of_lines | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    number_of_lines = number_of_lines_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_lines', 'Number of Lines', None, None, number_of_lines, number_of_lines_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:line | Offset: 16, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    line = line_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line', 'Line', None, None, line, line_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 4:acceptability | Offset: 18, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 18
    acceptability_raw = decode_int(_data_raw_, running_bit_offset, 2)
    acceptability = master_dict['ACCEPTABILITY'].get(acceptability_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('acceptability', 'Acceptability', None, None, acceptability, acceptability_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 5:reserved_20 | Offset: 20, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 20
    reserved_20 = reserved_20_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_20', 'Reserved', None, None, reserved_20, reserved_20_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 6:voltage | Offset: 24, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    voltage = voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('voltage', 'Voltage', None, 'V', voltage, voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:current | Offset: 40, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    current = current_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('current', 'Current', None, 'A', current, current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:frequency | Offset: 56, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    frequency = frequency_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('frequency', 'Frequency', None, 'Hz', frequency, frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:breaker_size | Offset: 72, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    breaker_size = breaker_size_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('breaker_size', 'Breaker Size', None, 'A', breaker_size, breaker_size_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 10:real_power | Offset: 88, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    real_power = real_power_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('real_power', 'Real Power', None, 'W', real_power, real_power_raw, PhysicalQuantities.ELECTRICAL_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 11:reactive_power | Offset: 120, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    reactive_power = reactive_power_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('reactive_power', 'Reactive Power', None, 'VAR', reactive_power, reactive_power_raw, PhysicalQuantities.ELECTRICAL_REACTIVE_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 12:power_factor | Offset: 152, Length: 8, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 152
    power_factor = power_factor_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('power_factor', 'Power factor', None, 'Cos Phi', power_factor, power_factor_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_127503(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127503."""
    data_raw = 0
    # instance | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # number_of_lines | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_lines')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of Lines'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # line | Offset: 16, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 16
    # acceptability | Offset: 18, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'acceptability')
    if field is None:
        raise Exception("Cant encode this message, missing 'Acceptability'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ACCEPTABILITY(field.value)
    data_raw |= (field_value & 0x3) << 18
    # reserved_20 | Offset: 20, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_20')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 20
    # voltage | Offset: 24, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Voltage'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 24
    
    # current | Offset: 40, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'current')
    if field is None:
        raise Exception("Cant encode this message, missing 'Current'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 40
    
    # frequency | Offset: 56, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'Frequency'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 56
    
    # breaker_size | Offset: 72, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'breaker_size')
    if field is None:
        raise Exception("Cant encode this message, missing 'Breaker Size'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 72
    
    # real_power | Offset: 88, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'real_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Real Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 88
    # reactive_power | Offset: 120, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'reactive_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reactive Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 120
    # power_factor | Offset: 152, Length: 8, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'power_factor')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power factor'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFF) << 152
    
    return data_raw


def is_fast_pgn_127504() -> bool:
    """Return True if PGN 127504 is a fast PGN."""
    return True
def decode_pgn_127504(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127504."""
    nmea2000Message = NMEA2000Message(127504, 'acOutputStatus', 'AC Output Status')
    running_bit_offset = 0
    # 1:instance | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 2:number_of_lines | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    number_of_lines = number_of_lines_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_lines', 'Number of Lines', None, None, number_of_lines, number_of_lines_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:line | Offset: 16, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    line_raw = decode_int(_data_raw_, running_bit_offset, 2)
    line = master_dict['LINE'].get(line_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('line', 'Line', None, None, line, line_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:waveform | Offset: 18, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 18
    waveform_raw = decode_int(_data_raw_, running_bit_offset, 3)
    waveform = master_dict['WAVEFORM'].get(waveform_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('waveform', 'Waveform', None, None, waveform, waveform_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 5:reserved_21 | Offset: 21, Length: 3, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 21
    reserved_21 = reserved_21_raw = decode_int(_data_raw_, running_bit_offset, 3)
    nmea2000Message.fields.append(NMEA2000Field('reserved_21', 'Reserved', None, None, reserved_21, reserved_21_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 3

    # 6:voltage | Offset: 24, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    voltage = voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('voltage', 'Voltage', None, 'V', voltage, voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:current | Offset: 40, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    current = current_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('current', 'Current', None, 'A', current, current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:frequency | Offset: 56, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    frequency = frequency_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('frequency', 'Frequency', None, 'Hz', frequency, frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:breaker_size | Offset: 72, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    breaker_size = breaker_size_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('breaker_size', 'Breaker Size', None, 'A', breaker_size, breaker_size_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 10:real_power | Offset: 88, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    real_power = real_power_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('real_power', 'Real Power', None, 'W', real_power, real_power_raw, PhysicalQuantities.ELECTRICAL_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 11:reactive_power | Offset: 120, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    reactive_power = reactive_power_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('reactive_power', 'Reactive Power', None, 'VAR', reactive_power, reactive_power_raw, PhysicalQuantities.ELECTRICAL_REACTIVE_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 12:power_factor | Offset: 152, Length: 8, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 152
    power_factor = power_factor_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('power_factor', 'Power factor', None, 'Cos Phi', power_factor, power_factor_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_127504(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127504."""
    data_raw = 0
    # instance | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # number_of_lines | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_lines')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of Lines'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # line | Offset: 16, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'line')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_LINE(field.value)
    data_raw |= (field_value & 0x3) << 16
    # waveform | Offset: 18, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'waveform')
    if field is None:
        raise Exception("Cant encode this message, missing 'Waveform'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_WAVEFORM(field.value)
    data_raw |= (field_value & 0x7) << 18
    # reserved_21 | Offset: 21, Length: 3, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_21')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x7) << 21
    # voltage | Offset: 24, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Voltage'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 24
    
    # current | Offset: 40, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'current')
    if field is None:
        raise Exception("Cant encode this message, missing 'Current'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 40
    
    # frequency | Offset: 56, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'Frequency'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 56
    
    # breaker_size | Offset: 72, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'breaker_size')
    if field is None:
        raise Exception("Cant encode this message, missing 'Breaker Size'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 72
    
    # real_power | Offset: 88, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'real_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Real Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 88
    # reactive_power | Offset: 120, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'reactive_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reactive Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 120
    # power_factor | Offset: 152, Length: 8, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'power_factor')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power factor'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFF) << 152
    
    return data_raw


def is_fast_pgn_127505() -> bool:
    """Return True if PGN 127505 is a fast PGN."""
    return False
def decode_pgn_127505(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127505."""
    nmea2000Message = NMEA2000Message(127505, 'fluidLevel', 'Fluid Level')
    running_bit_offset = 0
    # 1:instance | Offset: 0, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 4

    # 2:type | Offset: 4, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 4
    type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    type = master_dict['TANK_TYPE'].get(type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('type', 'Type', None, None, type, type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 3:level | Offset: 8, Length: 16, Signed: True Resolution: 0.004, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    level = level_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.004)
    nmea2000Message.fields.append(NMEA2000Field('level', 'Level', None, '%', level, level_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:capacity | Offset: 24, Length: 32, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    capacity = capacity_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('capacity', 'Capacity', None, 'L', capacity, capacity_raw, PhysicalQuantities.VOLUME, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 5:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_127505(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127505."""
    data_raw = 0
    # instance | Offset: 0, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 0
    # type | Offset: 4, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_TANK_TYPE(field.value)
    data_raw |= (field_value & 0xF) << 4
    # level | Offset: 8, Length: 16, Resolution: 0.004, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'level')
    if field is None:
        raise Exception("Cant encode this message, missing 'Level'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.004) & 0xFFFF) << 8
    
    # capacity | Offset: 24, Length: 32, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'capacity')
    if field is None:
        raise Exception("Cant encode this message, missing 'Capacity'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFFFFFF) << 24
    
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_127506() -> bool:
    """Return True if PGN 127506 is a fast PGN."""
    return True
def decode_pgn_127506(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127506."""
    nmea2000Message = NMEA2000Message(127506, 'dcDetailedStatus', 'DC Detailed Status')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:instance | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 3:dc_type | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    dc_type_raw = decode_int(_data_raw_, running_bit_offset, 8)
    dc_type = master_dict['DC_SOURCE'].get(dc_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('dc_type', 'DC Type', None, None, dc_type, dc_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 4:state_of_charge | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    state_of_charge = state_of_charge_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('state_of_charge', 'State of Charge', None, None, state_of_charge, state_of_charge_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:state_of_health | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    state_of_health = state_of_health_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('state_of_health', 'State of Health', None, None, state_of_health, state_of_health_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:time_remaining | Offset: 40, Length: 16, Signed: False Resolution: 60, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    time_remaining_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 60)
    time_remaining = decode_time(time_remaining_raw)
    nmea2000Message.fields.append(NMEA2000Field('time_remaining', 'Time Remaining', "Time remaining at current rate of discharge", 's', time_remaining, time_remaining_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    # 7:ripple_voltage | Offset: 56, Length: 16, Signed: False Resolution: 0.001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    ripple_voltage = ripple_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.001)
    nmea2000Message.fields.append(NMEA2000Field('ripple_voltage', 'Ripple Voltage', None, 'V', ripple_voltage, ripple_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:remaining_capacity | Offset: 72, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    remaining_capacity = remaining_capacity_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('remaining_capacity', 'Remaining capacity', None, 'Ah', remaining_capacity, remaining_capacity_raw, PhysicalQuantities.ELECTRICAL_CHARGE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_127506(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127506."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # instance | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # dc_type | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'dc_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'DC Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DC_SOURCE(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # state_of_charge | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'state_of_charge')
    if field is None:
        raise Exception("Cant encode this message, missing 'State of Charge'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # state_of_health | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'state_of_health')
    if field is None:
        raise Exception("Cant encode this message, missing 'State of Health'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # time_remaining | Offset: 40, Length: 16, Resolution: 60, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'time_remaining')
    if field is None:
        raise Exception("Cant encode this message, missing 'Time Remaining'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 60) & 0xFFFF) << 40
    
    # ripple_voltage | Offset: 56, Length: 16, Resolution: 0.001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ripple_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Ripple Voltage'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFF) << 56
    
    # remaining_capacity | Offset: 72, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'remaining_capacity')
    if field is None:
        raise Exception("Cant encode this message, missing 'Remaining capacity'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 72
    return data_raw


def is_fast_pgn_127507() -> bool:
    """Return True if PGN 127507 is a fast PGN."""
    return True
def decode_pgn_127507(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127507."""
    nmea2000Message = NMEA2000Message(127507, 'chargerStatus', 'Charger Status')
    running_bit_offset = 0
    # 1:instance | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 2:battery_instance | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    battery_instance = battery_instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('battery_instance', 'Battery Instance', None, None, battery_instance, battery_instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 3:operating_state | Offset: 16, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    operating_state_raw = decode_int(_data_raw_, running_bit_offset, 4)
    operating_state = master_dict['CHARGER_STATE'].get(operating_state_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('operating_state', 'Operating State', None, None, operating_state, operating_state_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 4:charge_mode | Offset: 20, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 20
    charge_mode_raw = decode_int(_data_raw_, running_bit_offset, 4)
    charge_mode = master_dict['CHARGER_MODE'].get(charge_mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('charge_mode', 'Charge Mode', None, None, charge_mode, charge_mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 5:enabled | Offset: 24, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    enabled_raw = decode_int(_data_raw_, running_bit_offset, 2)
    enabled = master_dict['OFF_ON'].get(enabled_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('enabled', 'Enabled', None, None, enabled, enabled_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 6:equalization_pending | Offset: 26, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 26
    equalization_pending_raw = decode_int(_data_raw_, running_bit_offset, 2)
    equalization_pending = master_dict['OFF_ON'].get(equalization_pending_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('equalization_pending', 'Equalization Pending', None, None, equalization_pending, equalization_pending_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 7:reserved_28 | Offset: 28, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 28
    reserved_28 = reserved_28_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_28', 'Reserved', None, None, reserved_28, reserved_28_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 8:equalization_time_remaining | Offset: 32, Length: 16, Signed: False Resolution: 60, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    equalization_time_remaining_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 60)
    equalization_time_remaining = decode_time(equalization_time_remaining_raw)
    nmea2000Message.fields.append(NMEA2000Field('equalization_time_remaining', 'Equalization Time Remaining', None, 's', equalization_time_remaining, equalization_time_remaining_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_127507(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127507."""
    data_raw = 0
    # instance | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # battery_instance | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'battery_instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Battery Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # operating_state | Offset: 16, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'operating_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'Operating State'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_CHARGER_STATE(field.value)
    data_raw |= (field_value & 0xF) << 16
    # charge_mode | Offset: 20, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'charge_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Charge Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_CHARGER_MODE(field.value)
    data_raw |= (field_value & 0xF) << 20
    # enabled | Offset: 24, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'enabled')
    if field is None:
        raise Exception("Cant encode this message, missing 'Enabled'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 24
    # equalization_pending | Offset: 26, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'equalization_pending')
    if field is None:
        raise Exception("Cant encode this message, missing 'Equalization Pending'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 26
    # reserved_28 | Offset: 28, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_28')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 28
    # equalization_time_remaining | Offset: 32, Length: 16, Resolution: 60, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'equalization_time_remaining')
    if field is None:
        raise Exception("Cant encode this message, missing 'Equalization Time Remaining'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 60) & 0xFFFF) << 32
    
    return data_raw


def is_fast_pgn_127508() -> bool:
    """Return True if PGN 127508 is a fast PGN."""
    return False
def decode_pgn_127508(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127508."""
    nmea2000Message = NMEA2000Message(127508, 'batteryStatus', 'Battery Status')
    running_bit_offset = 0
    # 1:instance | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 2:voltage | Offset: 8, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    voltage = voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('voltage', 'Voltage', None, 'V', voltage, voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:current | Offset: 24, Length: 16, Signed: True Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    current = current_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('current', 'Current', None, 'A', current, current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:temperature | Offset: 40, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    temperature = temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('temperature', 'Temperature', None, 'K', temperature, temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:sid | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_127508(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127508."""
    data_raw = 0
    # instance | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # voltage | Offset: 8, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Voltage'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 8
    
    # current | Offset: 24, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'current')
    if field is None:
        raise Exception("Cant encode this message, missing 'Current'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 24
    
    # temperature | Offset: 40, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 40
    
    # sid | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_127509() -> bool:
    """Return True if PGN 127509 is a fast PGN."""
    return True
def decode_pgn_127509(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127509."""
    nmea2000Message = NMEA2000Message(127509, 'inverterStatus', 'Inverter Status')
    running_bit_offset = 0
    # 1:instance | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 2:ac_instance | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    ac_instance = ac_instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('ac_instance', 'AC Instance', None, None, ac_instance, ac_instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 3:dc_instance | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 16
    dc_instance = dc_instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('dc_instance', 'DC Instance', None, None, dc_instance, dc_instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 4:operating_state | Offset: 24, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    operating_state_raw = decode_int(_data_raw_, running_bit_offset, 4)
    operating_state = master_dict['INVERTER_STATE'].get(operating_state_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('operating_state', 'Operating State', None, None, operating_state, operating_state_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 5:inverter_enable | Offset: 28, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 28
    inverter_enable_raw = decode_int(_data_raw_, running_bit_offset, 2)
    inverter_enable = master_dict['OFF_ON'].get(inverter_enable_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('inverter_enable', 'Inverter Enable', None, None, inverter_enable, inverter_enable_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 6:reserved_30 | Offset: 30, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 30
    reserved_30 = reserved_30_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_30', 'Reserved', None, None, reserved_30, reserved_30_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    return nmea2000Message

def encode_pgn_127509(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127509."""
    data_raw = 0
    # instance | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # ac_instance | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # dc_instance | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'dc_instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'DC Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # operating_state | Offset: 24, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'operating_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'Operating State'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INVERTER_STATE(field.value)
    data_raw |= (field_value & 0xF) << 24
    # inverter_enable | Offset: 28, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'inverter_enable')
    if field is None:
        raise Exception("Cant encode this message, missing 'Inverter Enable'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 28
    # reserved_30 | Offset: 30, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_30')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 30
    return data_raw


def is_fast_pgn_127510() -> bool:
    """Return True if PGN 127510 is a fast PGN."""
    return True
def decode_pgn_127510(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127510."""
    nmea2000Message = NMEA2000Message(127510, 'chargerConfigurationStatus', 'Charger Configuration Status')
    running_bit_offset = 0
    # 1:instance | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 2:battery_instance | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    battery_instance = battery_instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('battery_instance', 'Battery Instance', None, None, battery_instance, battery_instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 3:charger_enable_disable | Offset: 16, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    charger_enable_disable_raw = decode_int(_data_raw_, running_bit_offset, 2)
    charger_enable_disable = master_dict['OFF_ON'].get(charger_enable_disable_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('charger_enable_disable', 'Charger Enable/Disable', None, None, charger_enable_disable, charger_enable_disable_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:reserved_18 | Offset: 18, Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 18
    reserved_18 = reserved_18_raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_18', 'Reserved', None, None, reserved_18, reserved_18_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    # 5:charge_current_limit | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    charge_current_limit = charge_current_limit_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('charge_current_limit', 'Charge Current Limit', None, '%', charge_current_limit, charge_current_limit_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:charging_algorithm | Offset: 32, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    charging_algorithm_raw = decode_int(_data_raw_, running_bit_offset, 4)
    charging_algorithm = master_dict['CHARGING_ALGORITHM'].get(charging_algorithm_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('charging_algorithm', 'Charging Algorithm', None, None, charging_algorithm, charging_algorithm_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 7:charger_mode | Offset: 36, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 36
    charger_mode_raw = decode_int(_data_raw_, running_bit_offset, 4)
    charger_mode = master_dict['CHARGER_MODE'].get(charger_mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('charger_mode', 'Charger Mode', None, None, charger_mode, charger_mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 8:estimated_temperature | Offset: 40, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    estimated_temperature_raw = decode_int(_data_raw_, running_bit_offset, 4)
    estimated_temperature = master_dict['DEVICE_TEMP_STATE'].get(estimated_temperature_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('estimated_temperature', 'Estimated Temperature', "If there is no battery temperature sensor the charger will use this field to steer the charging algorithm", None, estimated_temperature, estimated_temperature_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 9:equalize_one_time_enable_disable | Offset: 44, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 44
    equalize_one_time_enable_disable_raw = decode_int(_data_raw_, running_bit_offset, 2)
    equalize_one_time_enable_disable = master_dict['OFF_ON'].get(equalize_one_time_enable_disable_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('equalize_one_time_enable_disable', 'Equalize One Time Enable/Disable', None, None, equalize_one_time_enable_disable, equalize_one_time_enable_disable_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 10:over_charge_enable_disable | Offset: 46, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 46
    over_charge_enable_disable_raw = decode_int(_data_raw_, running_bit_offset, 2)
    over_charge_enable_disable = master_dict['OFF_ON'].get(over_charge_enable_disable_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('over_charge_enable_disable', 'Over Charge Enable/Disable', None, None, over_charge_enable_disable, over_charge_enable_disable_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 11:equalize_time | Offset: 48, Length: 16, Signed: False Resolution: 60, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    equalize_time_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 60)
    equalize_time = decode_time(equalize_time_raw)
    nmea2000Message.fields.append(NMEA2000Field('equalize_time', 'Equalize Time', None, 's', equalize_time, equalize_time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_127510(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127510."""
    data_raw = 0
    # instance | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # battery_instance | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'battery_instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Battery Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # charger_enable_disable | Offset: 16, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'charger_enable_disable')
    if field is None:
        raise Exception("Cant encode this message, missing 'Charger Enable/Disable'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 16
    # reserved_18 | Offset: 18, Length: 6, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_18')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 18
    # charge_current_limit | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'charge_current_limit')
    if field is None:
        raise Exception("Cant encode this message, missing 'Charge Current Limit'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # charging_algorithm | Offset: 32, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'charging_algorithm')
    if field is None:
        raise Exception("Cant encode this message, missing 'Charging Algorithm'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_CHARGING_ALGORITHM(field.value)
    data_raw |= (field_value & 0xF) << 32
    # charger_mode | Offset: 36, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'charger_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Charger Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_CHARGER_MODE(field.value)
    data_raw |= (field_value & 0xF) << 36
    # estimated_temperature | Offset: 40, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'estimated_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Estimated Temperature'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DEVICE_TEMP_STATE(field.value)
    data_raw |= (field_value & 0xF) << 40
    # equalize_one_time_enable_disable | Offset: 44, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'equalize_one_time_enable_disable')
    if field is None:
        raise Exception("Cant encode this message, missing 'Equalize One Time Enable/Disable'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 44
    # over_charge_enable_disable | Offset: 46, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'over_charge_enable_disable')
    if field is None:
        raise Exception("Cant encode this message, missing 'Over Charge Enable/Disable'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 46
    # equalize_time | Offset: 48, Length: 16, Resolution: 60, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'equalize_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Equalize Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 60) & 0xFFFF) << 48
    
    return data_raw


def is_fast_pgn_127511() -> bool:
    """Return True if PGN 127511 is a fast PGN."""
    return False
def decode_pgn_127511(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127511."""
    nmea2000Message = NMEA2000Message(127511, 'inverterConfigurationStatus', 'Inverter Configuration Status')
    running_bit_offset = 0
    # 1:instance | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 2:ac_instance | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    ac_instance = ac_instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('ac_instance', 'AC Instance', None, None, ac_instance, ac_instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 3:dc_instance | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 16
    dc_instance = dc_instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('dc_instance', 'DC Instance', None, None, dc_instance, dc_instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 4:inverter_enable_disable | Offset: 24, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    inverter_enable_disable = inverter_enable_disable_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('inverter_enable_disable', 'Inverter Enable/Disable', None, None, inverter_enable_disable, inverter_enable_disable_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 5:reserved_26 | Offset: 26, Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 26
    reserved_26 = reserved_26_raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_26', 'Reserved', None, None, reserved_26, reserved_26_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    # 6:inverter_mode | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    inverter_mode = inverter_mode_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('inverter_mode', 'Inverter Mode', None, None, inverter_mode, inverter_mode_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:load_sense_enable_disable | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    load_sense_enable_disable = load_sense_enable_disable_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('load_sense_enable_disable', 'Load Sense Enable/Disable', None, None, load_sense_enable_disable, load_sense_enable_disable_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:load_sense_power_threshold | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    load_sense_power_threshold = load_sense_power_threshold_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('load_sense_power_threshold', 'Load Sense Power Threshold', None, None, load_sense_power_threshold, load_sense_power_threshold_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:load_sense_interval | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    load_sense_interval = load_sense_interval_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('load_sense_interval', 'Load Sense Interval', None, None, load_sense_interval, load_sense_interval_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_127511(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127511."""
    data_raw = 0
    # instance | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # ac_instance | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # dc_instance | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'dc_instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'DC Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # inverter_enable_disable | Offset: 24, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'inverter_enable_disable')
    if field is None:
        raise Exception("Cant encode this message, missing 'Inverter Enable/Disable'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 24
    # reserved_26 | Offset: 26, Length: 6, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_26')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 26
    # inverter_mode | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'inverter_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Inverter Mode'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # load_sense_enable_disable | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'load_sense_enable_disable')
    if field is None:
        raise Exception("Cant encode this message, missing 'Load Sense Enable/Disable'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # load_sense_power_threshold | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'load_sense_power_threshold')
    if field is None:
        raise Exception("Cant encode this message, missing 'Load Sense Power Threshold'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # load_sense_interval | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'load_sense_interval')
    if field is None:
        raise Exception("Cant encode this message, missing 'Load Sense Interval'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_127512() -> bool:
    """Return True if PGN 127512 is a fast PGN."""
    return False
def decode_pgn_127512(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127512."""
    nmea2000Message = NMEA2000Message(127512, 'agsConfigurationStatus', 'AGS Configuration Status')
    running_bit_offset = 0
    # 1:instance | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 2:generator_instance | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    generator_instance = generator_instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('generator_instance', 'Generator Instance', None, None, generator_instance, generator_instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 3:ags_mode | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    ags_mode = ags_mode_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('ags_mode', 'AGS Mode', None, None, ags_mode, ags_mode_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:reserved_24 | Offset: 24, Length: 40, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    reserved_24 = reserved_24_raw = decode_int(_data_raw_, running_bit_offset, 40)
    nmea2000Message.fields.append(NMEA2000Field('reserved_24', 'Reserved', None, None, reserved_24, reserved_24_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 40

    return nmea2000Message

def encode_pgn_127512(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127512."""
    data_raw = 0
    # instance | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # generator_instance | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'generator_instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Generator Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # ags_mode | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ags_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'AGS Mode'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # reserved_24 | Offset: 24, Length: 40, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_24')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFF) << 24
    return data_raw


def is_fast_pgn_127513() -> bool:
    """Return True if PGN 127513 is a fast PGN."""
    return True
def decode_pgn_127513(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127513."""
    nmea2000Message = NMEA2000Message(127513, 'batteryConfigurationStatus', 'Battery Configuration Status')
    running_bit_offset = 0
    # 1:instance | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 2:battery_type | Offset: 8, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    battery_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    battery_type = master_dict['BATTERY_TYPE'].get(battery_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('battery_type', 'Battery Type', None, None, battery_type, battery_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 3:supports_equalization | Offset: 12, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 12
    supports_equalization_raw = decode_int(_data_raw_, running_bit_offset, 2)
    supports_equalization = master_dict['YES_NO'].get(supports_equalization_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('supports_equalization', 'Supports Equalization', None, None, supports_equalization, supports_equalization_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:reserved_14 | Offset: 14, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 14
    reserved_14 = reserved_14_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_14', 'Reserved', None, None, reserved_14, reserved_14_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 5:nominal_voltage | Offset: 16, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    nominal_voltage_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nominal_voltage = master_dict['BATTERY_VOLTAGE'].get(nominal_voltage_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('nominal_voltage', 'Nominal Voltage', None, None, nominal_voltage, nominal_voltage_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 6:chemistry | Offset: 20, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 20
    chemistry_raw = decode_int(_data_raw_, running_bit_offset, 4)
    chemistry = master_dict['BATTERY_CHEMISTRY'].get(chemistry_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('chemistry', 'Chemistry', None, None, chemistry, chemistry_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 7:capacity | Offset: 24, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    capacity = capacity_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('capacity', 'Capacity', None, 'Ah', capacity, capacity_raw, PhysicalQuantities.ELECTRICAL_CHARGE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:temperature_coefficient | Offset: 40, Length: 8, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    temperature_coefficient = temperature_coefficient_raw = decode_number(_data_raw_, running_bit_offset, 8, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('temperature_coefficient', 'Temperature Coefficient', None, '%', temperature_coefficient, temperature_coefficient_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:peukert_exponent | Offset: 48, Length: 8, Signed: False Resolution: 0.002, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    peukert_exponent = peukert_exponent_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 0.002)
    nmea2000Message.fields.append(NMEA2000Field('peukert_exponent', 'Peukert Exponent', None, None, peukert_exponent, peukert_exponent_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:charge_efficiency_factor | Offset: 56, Length: 8, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    charge_efficiency_factor = charge_efficiency_factor_raw = decode_number(_data_raw_, running_bit_offset, 8, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('charge_efficiency_factor', 'Charge Efficiency Factor', None, '%', charge_efficiency_factor, charge_efficiency_factor_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_127513(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127513."""
    data_raw = 0
    # instance | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # battery_type | Offset: 8, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'battery_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Battery Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_BATTERY_TYPE(field.value)
    data_raw |= (field_value & 0xF) << 8
    # supports_equalization | Offset: 12, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'supports_equalization')
    if field is None:
        raise Exception("Cant encode this message, missing 'Supports Equalization'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 12
    # reserved_14 | Offset: 14, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_14')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 14
    # nominal_voltage | Offset: 16, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'nominal_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Nominal Voltage'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_BATTERY_VOLTAGE(field.value)
    data_raw |= (field_value & 0xF) << 16
    # chemistry | Offset: 20, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'chemistry')
    if field is None:
        raise Exception("Cant encode this message, missing 'Chemistry'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_BATTERY_CHEMISTRY(field.value)
    data_raw |= (field_value & 0xF) << 20
    # capacity | Offset: 24, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'capacity')
    if field is None:
        raise Exception("Cant encode this message, missing 'Capacity'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 24
    # temperature_coefficient | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'temperature_coefficient')
    if field is None:
        raise Exception("Cant encode this message, missing 'Temperature Coefficient'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # peukert_exponent | Offset: 48, Length: 8, Resolution: 0.002, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'peukert_exponent')
    if field is None:
        raise Exception("Cant encode this message, missing 'Peukert Exponent'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.002) & 0xFF) << 48
    
    # charge_efficiency_factor | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'charge_efficiency_factor')
    if field is None:
        raise Exception("Cant encode this message, missing 'Charge Efficiency Factor'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_127514() -> bool:
    """Return True if PGN 127514 is a fast PGN."""
    return False
def decode_pgn_127514(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127514."""
    nmea2000Message = NMEA2000Message(127514, 'agsStatus', 'AGS Status')
    running_bit_offset = 0
    # 1:instance | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 0
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 2:generator_instance | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    generator_instance = generator_instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('generator_instance', 'Generator Instance', None, None, generator_instance, generator_instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 3:ags_operating_state | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    ags_operating_state = ags_operating_state_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('ags_operating_state', 'AGS Operating State', None, None, ags_operating_state, ags_operating_state_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:generator_state | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    generator_state = generator_state_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('generator_state', 'Generator State', None, None, generator_state, generator_state_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:generator_on_reason | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    generator_on_reason = generator_on_reason_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('generator_on_reason', 'Generator On Reason', None, None, generator_on_reason, generator_on_reason_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:generator_off_reason | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    generator_off_reason = generator_off_reason_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('generator_off_reason', 'Generator Off Reason', None, None, generator_off_reason, generator_off_reason_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:reserved_48 | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    reserved_48 = reserved_48_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('reserved_48', 'Reserved', None, None, reserved_48, reserved_48_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_127514(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127514."""
    data_raw = 0
    # instance | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # generator_instance | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'generator_instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Generator Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # ags_operating_state | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ags_operating_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'AGS Operating State'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # generator_state | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'generator_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'Generator State'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # generator_on_reason | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'generator_on_reason')
    if field is None:
        raise Exception("Cant encode this message, missing 'Generator On Reason'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # generator_off_reason | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'generator_off_reason')
    if field is None:
        raise Exception("Cant encode this message, missing 'Generator Off Reason'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # reserved_48 | Offset: 48, Length: 16, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_48')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_127744() -> bool:
    """Return True if PGN 127744 is a fast PGN."""
    return False
def decode_pgn_127744(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127744."""
    nmea2000Message = NMEA2000Message(127744, 'acPowerCurrentPhaseA', 'AC Power / Current - Phase A')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:connection_number | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    connection_number = connection_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('connection_number', 'Connection Number', None, None, connection_number, connection_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:ac_rms_current | Offset: 16, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    ac_rms_current = ac_rms_current_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('ac_rms_current', 'AC RMS Current', None, 'A', ac_rms_current, ac_rms_current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:power | Offset: 32, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    power = power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('power', 'Power', None, 'W', power, power_raw, PhysicalQuantities.ELECTRICAL_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_127744(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127744."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # connection_number | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'connection_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Connection Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # ac_rms_current | Offset: 16, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_rms_current')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC RMS Current'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 16
    
    # power | Offset: 32, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw


def is_fast_pgn_127745() -> bool:
    """Return True if PGN 127745 is a fast PGN."""
    return False
def decode_pgn_127745(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127745."""
    nmea2000Message = NMEA2000Message(127745, 'acPowerCurrentPhaseB', 'AC Power / Current - Phase B')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:connection_number | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    connection_number = connection_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('connection_number', 'Connection Number', None, None, connection_number, connection_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:ac_rms_current | Offset: 16, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    ac_rms_current = ac_rms_current_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('ac_rms_current', 'AC RMS Current', None, 'A', ac_rms_current, ac_rms_current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:power | Offset: 32, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    power = power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('power', 'Power', None, 'W', power, power_raw, PhysicalQuantities.ELECTRICAL_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_127745(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127745."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # connection_number | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'connection_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Connection Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # ac_rms_current | Offset: 16, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_rms_current')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC RMS Current'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 16
    
    # power | Offset: 32, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw


def is_fast_pgn_127746() -> bool:
    """Return True if PGN 127746 is a fast PGN."""
    return False
def decode_pgn_127746(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127746."""
    nmea2000Message = NMEA2000Message(127746, 'acPowerCurrentPhaseC', 'AC Power / Current - Phase C')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:connection_number | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    connection_number = connection_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('connection_number', 'Connection Number', None, None, connection_number, connection_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:ac_rms_current | Offset: 16, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    ac_rms_current = ac_rms_current_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('ac_rms_current', 'AC RMS Current', None, 'A', ac_rms_current, ac_rms_current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:power | Offset: 32, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    power = power_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('power', 'Power', None, 'W', power, power_raw, PhysicalQuantities.ELECTRICAL_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_127746(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127746."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # connection_number | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'connection_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Connection Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # ac_rms_current | Offset: 16, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ac_rms_current')
    if field is None:
        raise Exception("Cant encode this message, missing 'AC RMS Current'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 16
    
    # power | Offset: 32, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw


def is_fast_pgn_127750() -> bool:
    """Return True if PGN 127750 is a fast PGN."""
    return False
def decode_pgn_127750(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127750."""
    nmea2000Message = NMEA2000Message(127750, 'converterStatus', 'Converter Status')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 8))
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 8

    # 2:connection_number | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    connection_number = connection_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('connection_number', 'Connection Number', None, None, connection_number, connection_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:operating_state | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    operating_state_raw = decode_int(_data_raw_, running_bit_offset, 8)
    operating_state = master_dict['CONVERTER_STATE'].get(operating_state_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('operating_state', 'Operating State', None, None, operating_state, operating_state_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 4:temperature_state | Offset: 24, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    temperature_state_raw = decode_int(_data_raw_, running_bit_offset, 2)
    temperature_state = master_dict['GOOD_WARNING_ERROR'].get(temperature_state_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('temperature_state', 'Temperature State', None, None, temperature_state, temperature_state_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 5:overload_state | Offset: 26, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 26
    overload_state_raw = decode_int(_data_raw_, running_bit_offset, 2)
    overload_state = master_dict['GOOD_WARNING_ERROR'].get(overload_state_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('overload_state', 'Overload State', None, None, overload_state, overload_state_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 6:low_dc_voltage_state | Offset: 28, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 28
    low_dc_voltage_state_raw = decode_int(_data_raw_, running_bit_offset, 2)
    low_dc_voltage_state = master_dict['GOOD_WARNING_ERROR'].get(low_dc_voltage_state_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('low_dc_voltage_state', 'Low DC Voltage State', None, None, low_dc_voltage_state, low_dc_voltage_state_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 7:ripple_state | Offset: 30, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 30
    ripple_state_raw = decode_int(_data_raw_, running_bit_offset, 2)
    ripple_state = master_dict['GOOD_WARNING_ERROR'].get(ripple_state_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ripple_state', 'Ripple State', None, None, ripple_state, ripple_state_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 8:reserved_32 | Offset: 32, Length: 32, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    reserved_32 = reserved_32_raw = decode_int(_data_raw_, running_bit_offset, 32)
    nmea2000Message.fields.append(NMEA2000Field('reserved_32', 'Reserved', None, None, reserved_32, reserved_32_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_127750(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127750."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # connection_number | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'connection_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Connection Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # operating_state | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'operating_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'Operating State'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_CONVERTER_STATE(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # temperature_state | Offset: 24, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'temperature_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'Temperature State'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GOOD_WARNING_ERROR(field.value)
    data_raw |= (field_value & 0x3) << 24
    # overload_state | Offset: 26, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'overload_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'Overload State'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GOOD_WARNING_ERROR(field.value)
    data_raw |= (field_value & 0x3) << 26
    # low_dc_voltage_state | Offset: 28, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'low_dc_voltage_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'Low DC Voltage State'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GOOD_WARNING_ERROR(field.value)
    data_raw |= (field_value & 0x3) << 28
    # ripple_state | Offset: 30, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ripple_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'Ripple State'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GOOD_WARNING_ERROR(field.value)
    data_raw |= (field_value & 0x3) << 30
    # reserved_32 | Offset: 32, Length: 32, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_32')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw


def is_fast_pgn_127751() -> bool:
    """Return True if PGN 127751 is a fast PGN."""
    return False
def decode_pgn_127751(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 127751."""
    nmea2000Message = NMEA2000Message(127751, 'dcVoltageCurrent', 'DC Voltage/Current')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 8))
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 8

    # 2:connection_number | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    connection_number = connection_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('connection_number', 'Connection Number', None, None, connection_number, connection_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:dc_voltage | Offset: 16, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    dc_voltage = dc_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('dc_voltage', 'DC Voltage', None, 'V', dc_voltage, dc_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:dc_current | Offset: 32, Length: 24, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    dc_current = dc_current_raw = decode_number(_data_raw_, running_bit_offset, 24, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('dc_current', 'DC Current', None, 'A', dc_current, dc_current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    # 5:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_127751(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 127751."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # connection_number | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'connection_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Connection Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # dc_voltage | Offset: 16, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'dc_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'DC Voltage'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 16
    
    # dc_current | Offset: 32, Length: 24, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'dc_current')
    if field is None:
        raise Exception("Cant encode this message, missing 'DC Current'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFFFF) << 32
    
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_128000() -> bool:
    """Return True if PGN 128000 is a fast PGN."""
    return False
def decode_pgn_128000(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 128000."""
    nmea2000Message = NMEA2000Message(128000, 'leewayAngle', 'Leeway Angle')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:leeway_angle | Offset: 8, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    leeway_angle = leeway_angle_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('leeway_angle', 'Leeway Angle', None, 'rad', leeway_angle, leeway_angle_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:reserved_24 | Offset: 24, Length: 40, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    reserved_24 = reserved_24_raw = decode_int(_data_raw_, running_bit_offset, 40)
    nmea2000Message.fields.append(NMEA2000Field('reserved_24', 'Reserved', None, None, reserved_24, reserved_24_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 40

    return nmea2000Message

def encode_pgn_128000(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 128000."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # leeway_angle | Offset: 8, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'leeway_angle')
    if field is None:
        raise Exception("Cant encode this message, missing 'Leeway Angle'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 8
    
    # reserved_24 | Offset: 24, Length: 40, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_24')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFF) << 24
    return data_raw


def is_fast_pgn_128001() -> bool:
    """Return True if PGN 128001 is a fast PGN."""
    return False
def decode_pgn_128001(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 128001."""
    nmea2000Message = NMEA2000Message(128001, 'vesselAcceleration', 'Vessel Acceleration')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:longitudinal_acceleration | Offset: 8, Length: 16, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    longitudinal_acceleration = longitudinal_acceleration_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('longitudinal_acceleration', 'Longitudinal Acceleration', None, None, longitudinal_acceleration, longitudinal_acceleration_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:transverse_acceleration | Offset: 24, Length: 16, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    transverse_acceleration = transverse_acceleration_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('transverse_acceleration', 'Transverse Acceleration', None, None, transverse_acceleration, transverse_acceleration_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:vertical_acceleration | Offset: 40, Length: 16, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    vertical_acceleration = vertical_acceleration_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('vertical_acceleration', 'Vertical Acceleration', None, None, vertical_acceleration, vertical_acceleration_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_128001(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 128001."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # longitudinal_acceleration | Offset: 8, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'longitudinal_acceleration')
    if field is None:
        raise Exception("Cant encode this message, missing 'Longitudinal Acceleration'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 8
    # transverse_acceleration | Offset: 24, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'transverse_acceleration')
    if field is None:
        raise Exception("Cant encode this message, missing 'Transverse Acceleration'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 24
    # vertical_acceleration | Offset: 40, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'vertical_acceleration')
    if field is None:
        raise Exception("Cant encode this message, missing 'Vertical Acceleration'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 40
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_128002() -> bool:
    """Return True if PGN 128002 is a fast PGN."""
    return False
def decode_pgn_128002(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 128002."""
    nmea2000Message = NMEA2000Message(128002, 'electricDriveStatusRapidUpdate', 'Electric Drive Status, Rapid Update')
    running_bit_offset = 0
    # 1:inverter_motor_controller | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    inverter_motor_controller = inverter_motor_controller_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('inverter_motor_controller', 'Inverter/Motor Controller', None, None, inverter_motor_controller, inverter_motor_controller_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:active_motor_mode | Offset: 8, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    active_motor_mode = active_motor_mode_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('active_motor_mode', 'Active Motor Mode', None, None, active_motor_mode, active_motor_mode_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 3:brake_mode | Offset: 10, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 10
    brake_mode = brake_mode_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('brake_mode', 'Brake Mode', None, None, brake_mode, brake_mode_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 4:reserved_12 | Offset: 12, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 12
    reserved_12 = reserved_12_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_12', 'Reserved', None, None, reserved_12, reserved_12_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 5:rotational_shaft_speed | Offset: 16, Length: 16, Signed: False Resolution: 0.25, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    rotational_shaft_speed = rotational_shaft_speed_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.25)
    nmea2000Message.fields.append(NMEA2000Field('rotational_shaft_speed', 'Rotational Shaft Speed', None, 'rpm', rotational_shaft_speed, rotational_shaft_speed_raw, PhysicalQuantities.ANGULAR_VELOCITY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:motor_dc_voltage | Offset: 32, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    motor_dc_voltage = motor_dc_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('motor_dc_voltage', 'Motor DC Voltage', None, 'V', motor_dc_voltage, motor_dc_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:motor_dc_current | Offset: 48, Length: 16, Signed: True Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    motor_dc_current = motor_dc_current_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('motor_dc_current', 'Motor DC Current', None, 'A', motor_dc_current, motor_dc_current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_128002(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 128002."""
    data_raw = 0
    # inverter_motor_controller | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'inverter_motor_controller')
    if field is None:
        raise Exception("Cant encode this message, missing 'Inverter/Motor Controller'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # active_motor_mode | Offset: 8, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'active_motor_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Active Motor Mode'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 8
    # brake_mode | Offset: 10, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'brake_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Brake Mode'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 10
    # reserved_12 | Offset: 12, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_12')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 12
    # rotational_shaft_speed | Offset: 16, Length: 16, Resolution: 0.25, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'rotational_shaft_speed')
    if field is None:
        raise Exception("Cant encode this message, missing 'Rotational Shaft Speed'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.25) & 0xFFFF) << 16
    
    # motor_dc_voltage | Offset: 32, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'motor_dc_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Motor DC Voltage'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 32
    
    # motor_dc_current | Offset: 48, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'motor_dc_current')
    if field is None:
        raise Exception("Cant encode this message, missing 'Motor DC Current'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 48
    
    return data_raw


def is_fast_pgn_128003() -> bool:
    """Return True if PGN 128003 is a fast PGN."""
    return False
def decode_pgn_128003(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 128003."""
    nmea2000Message = NMEA2000Message(128003, 'electricEnergyStorageStatusRapidUpdate', 'Electric Energy Storage Status, Rapid Update')
    running_bit_offset = 0
    # 1:energy_storage_identifier | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    energy_storage_identifier = energy_storage_identifier_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('energy_storage_identifier', 'Energy Storage Identifier', None, None, energy_storage_identifier, energy_storage_identifier_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:battery_status | Offset: 8, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    battery_status = battery_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('battery_status', 'Battery Status', None, None, battery_status, battery_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 3:isolation_status | Offset: 10, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 10
    isolation_status = isolation_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('isolation_status', 'Isolation Status', None, None, isolation_status, isolation_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 4:battery_error | Offset: 12, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 12
    battery_error = battery_error_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('battery_error', 'Battery Error', None, None, battery_error, battery_error_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 5:battery_voltage | Offset: 16, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    battery_voltage = battery_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('battery_voltage', 'Battery Voltage', None, 'V', battery_voltage, battery_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:battery_current | Offset: 32, Length: 16, Signed: True Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    battery_current = battery_current_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('battery_current', 'Battery Current', None, 'A', battery_current, battery_current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:reserved_48 | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    reserved_48 = reserved_48_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('reserved_48', 'Reserved', None, None, reserved_48, reserved_48_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_128003(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 128003."""
    data_raw = 0
    # energy_storage_identifier | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'energy_storage_identifier')
    if field is None:
        raise Exception("Cant encode this message, missing 'Energy Storage Identifier'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # battery_status | Offset: 8, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'battery_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Battery Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 8
    # isolation_status | Offset: 10, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'isolation_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Isolation Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 10
    # battery_error | Offset: 12, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'battery_error')
    if field is None:
        raise Exception("Cant encode this message, missing 'Battery Error'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 12
    # battery_voltage | Offset: 16, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'battery_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Battery Voltage'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 16
    
    # battery_current | Offset: 32, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'battery_current')
    if field is None:
        raise Exception("Cant encode this message, missing 'Battery Current'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 32
    
    # reserved_48 | Offset: 48, Length: 16, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_48')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_128006() -> bool:
    """Return True if PGN 128006 is a fast PGN."""
    return False
def decode_pgn_128006(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 128006."""
    nmea2000Message = NMEA2000Message(128006, 'thrusterControlStatus', 'Thruster Control Status')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:identifier | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    identifier = identifier_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('identifier', 'Identifier', None, None, identifier, identifier_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:direction_control | Offset: 16, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    direction_control_raw = decode_int(_data_raw_, running_bit_offset, 4)
    direction_control = master_dict['THRUSTER_DIRECTION_CONTROL'].get(direction_control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('direction_control', 'Direction Control', None, None, direction_control, direction_control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 4:power_enabled | Offset: 20, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 20
    power_enabled_raw = decode_int(_data_raw_, running_bit_offset, 2)
    power_enabled = master_dict['OFF_ON'].get(power_enabled_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('power_enabled', 'Power Enabled', None, None, power_enabled, power_enabled_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 5:retract_control | Offset: 22, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 22
    retract_control_raw = decode_int(_data_raw_, running_bit_offset, 2)
    retract_control = master_dict['THRUSTER_RETRACT_CONTROL'].get(retract_control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('retract_control', 'Retract Control', None, None, retract_control, retract_control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 6:speed_control | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    speed_control = speed_control_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('speed_control', 'Speed Control', None, '%', speed_control, speed_control_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:control_events | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    control_events_raw = decode_int(_data_raw_, running_bit_offset, 8)
    control_events = decode_bit_lookup(control_events_raw, master_flags_dict['THRUSTER_CONTROL_EVENTS'])
    nmea2000Message.fields.append(NMEA2000Field('control_events', 'Control Events', None, None, control_events, control_events_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 8

    # 8:command_timeout | Offset: 40, Length: 8, Signed: False Resolution: 0.005, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    command_timeout_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 0.005)
    command_timeout = decode_time(command_timeout_raw)
    nmea2000Message.fields.append(NMEA2000Field('command_timeout', 'Command Timeout', None, 's', command_timeout, command_timeout_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 8

    # 9:azimuth_control | Offset: 48, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    azimuth_control = azimuth_control_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('azimuth_control', 'Azimuth Control', None, 'rad', azimuth_control, azimuth_control_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_128006(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 128006."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # identifier | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'identifier')
    if field is None:
        raise Exception("Cant encode this message, missing 'Identifier'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # direction_control | Offset: 16, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'direction_control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Direction Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_THRUSTER_DIRECTION_CONTROL(field.value)
    data_raw |= (field_value & 0xF) << 16
    # power_enabled | Offset: 20, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'power_enabled')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power Enabled'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 20
    # retract_control | Offset: 22, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'retract_control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Retract Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_THRUSTER_RETRACT_CONTROL(field.value)
    data_raw |= (field_value & 0x3) << 22
    # speed_control | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'speed_control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Speed Control'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # control_events | Offset: 32, Length: 8, Resolution: 1, Field Type: BITLOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control_events')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control Events'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # command_timeout | Offset: 40, Length: 8, Resolution: 0.005, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'command_timeout')
    if field is None:
        raise Exception("Cant encode this message, missing 'Command Timeout'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.005) & 0xFF) << 40
    
    # azimuth_control | Offset: 48, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'azimuth_control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Azimuth Control'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 48
    
    return data_raw


def is_fast_pgn_128007() -> bool:
    """Return True if PGN 128007 is a fast PGN."""
    return False
def decode_pgn_128007(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 128007."""
    nmea2000Message = NMEA2000Message(128007, 'thrusterInformation', 'Thruster Information')
    running_bit_offset = 0
    # 1:identifier | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    identifier = identifier_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('identifier', 'Identifier', None, None, identifier, identifier_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:motor_type | Offset: 8, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    motor_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    motor_type = master_dict['THRUSTER_MOTOR_TYPE'].get(motor_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('motor_type', 'Motor Type', None, None, motor_type, motor_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 3:reserved_12 | Offset: 12, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 12
    reserved_12 = reserved_12_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_12', 'Reserved', None, None, reserved_12, reserved_12_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 4:power_rating | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    power_rating = power_rating_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('power_rating', 'Power Rating', None, 'W', power_rating, power_rating_raw, PhysicalQuantities.ELECTRICAL_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:maximum_temperature_rating | Offset: 32, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    maximum_temperature_rating = maximum_temperature_rating_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('maximum_temperature_rating', 'Maximum Temperature Rating', None, 'K', maximum_temperature_rating, maximum_temperature_rating_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:maximum_rotational_speed | Offset: 48, Length: 16, Signed: False Resolution: 0.25, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    maximum_rotational_speed = maximum_rotational_speed_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.25)
    nmea2000Message.fields.append(NMEA2000Field('maximum_rotational_speed', 'Maximum Rotational Speed', None, 'rpm', maximum_rotational_speed, maximum_rotational_speed_raw, PhysicalQuantities.ANGULAR_VELOCITY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_128007(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 128007."""
    data_raw = 0
    # identifier | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'identifier')
    if field is None:
        raise Exception("Cant encode this message, missing 'Identifier'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # motor_type | Offset: 8, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'motor_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Motor Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_THRUSTER_MOTOR_TYPE(field.value)
    data_raw |= (field_value & 0xF) << 8
    # reserved_12 | Offset: 12, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_12')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 12
    # power_rating | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'power_rating')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power Rating'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # maximum_temperature_rating | Offset: 32, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'maximum_temperature_rating')
    if field is None:
        raise Exception("Cant encode this message, missing 'Maximum Temperature Rating'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 32
    
    # maximum_rotational_speed | Offset: 48, Length: 16, Resolution: 0.25, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'maximum_rotational_speed')
    if field is None:
        raise Exception("Cant encode this message, missing 'Maximum Rotational Speed'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.25) & 0xFFFF) << 48
    
    return data_raw


def is_fast_pgn_128008() -> bool:
    """Return True if PGN 128008 is a fast PGN."""
    return False
def decode_pgn_128008(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 128008."""
    nmea2000Message = NMEA2000Message(128008, 'thrusterMotorStatus', 'Thruster Motor Status')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:identifier | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    identifier = identifier_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('identifier', 'Identifier', None, None, identifier, identifier_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:motor_events | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    motor_events_raw = decode_int(_data_raw_, running_bit_offset, 8)
    motor_events = decode_bit_lookup(motor_events_raw, master_flags_dict['THRUSTER_MOTOR_EVENTS'])
    nmea2000Message.fields.append(NMEA2000Field('motor_events', 'Motor Events', None, None, motor_events, motor_events_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 8

    # 4:current | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    current = current_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('current', 'Current', None, 'A', current, current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:temperature | Offset: 32, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    temperature = temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('temperature', 'Temperature', None, 'K', temperature, temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:operating_time | Offset: 48, Length: 16, Signed: False Resolution: 60, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    operating_time_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 60)
    operating_time = decode_time(operating_time_raw)
    nmea2000Message.fields.append(NMEA2000Field('operating_time', 'Operating Time', None, 's', operating_time, operating_time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_128008(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 128008."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # identifier | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'identifier')
    if field is None:
        raise Exception("Cant encode this message, missing 'Identifier'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # motor_events | Offset: 16, Length: 8, Resolution: 1, Field Type: BITLOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'motor_events')
    if field is None:
        raise Exception("Cant encode this message, missing 'Motor Events'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # current | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'current')
    if field is None:
        raise Exception("Cant encode this message, missing 'Current'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # temperature | Offset: 32, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 32
    
    # operating_time | Offset: 48, Length: 16, Resolution: 60, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'operating_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Operating Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 60) & 0xFFFF) << 48
    
    return data_raw


def is_fast_pgn_128259() -> bool:
    """Return True if PGN 128259 is a fast PGN."""
    return False
def decode_pgn_128259(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 128259."""
    nmea2000Message = NMEA2000Message(128259, 'speed', 'Speed')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:speed_water_referenced | Offset: 8, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    speed_water_referenced = speed_water_referenced_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('speed_water_referenced', 'Speed Water Referenced', None, 'm/s', speed_water_referenced, speed_water_referenced_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:speed_ground_referenced | Offset: 24, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    speed_ground_referenced = speed_ground_referenced_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('speed_ground_referenced', 'Speed Ground Referenced', None, 'm/s', speed_ground_referenced, speed_ground_referenced_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:speed_water_referenced_type | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    speed_water_referenced_type_raw = decode_int(_data_raw_, running_bit_offset, 8)
    speed_water_referenced_type = master_dict['WATER_REFERENCE'].get(speed_water_referenced_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('speed_water_referenced_type', 'Speed Water Referenced Type', None, None, speed_water_referenced_type, speed_water_referenced_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:speed_direction | Offset: 48, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    speed_direction = speed_direction_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('speed_direction', 'Speed Direction', None, None, speed_direction, speed_direction_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 6:reserved_52 | Offset: 52, Length: 12, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 52
    reserved_52 = reserved_52_raw = decode_int(_data_raw_, running_bit_offset, 12)
    nmea2000Message.fields.append(NMEA2000Field('reserved_52', 'Reserved', None, None, reserved_52, reserved_52_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 12

    return nmea2000Message

def encode_pgn_128259(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 128259."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # speed_water_referenced | Offset: 8, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'speed_water_referenced')
    if field is None:
        raise Exception("Cant encode this message, missing 'Speed Water Referenced'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 8
    
    # speed_ground_referenced | Offset: 24, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'speed_ground_referenced')
    if field is None:
        raise Exception("Cant encode this message, missing 'Speed Ground Referenced'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 24
    
    # speed_water_referenced_type | Offset: 40, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'speed_water_referenced_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Speed Water Referenced Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_WATER_REFERENCE(field.value)
    data_raw |= (field_value & 0xFF) << 40
    # speed_direction | Offset: 48, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'speed_direction')
    if field is None:
        raise Exception("Cant encode this message, missing 'Speed Direction'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 48
    # reserved_52 | Offset: 52, Length: 12, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_52')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFF) << 52
    return data_raw


def is_fast_pgn_128267() -> bool:
    """Return True if PGN 128267 is a fast PGN."""
    return False
def decode_pgn_128267(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 128267."""
    nmea2000Message = NMEA2000Message(128267, 'waterDepth', 'Water Depth')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:depth | Offset: 8, Length: 32, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    depth = depth_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('depth', 'Depth', "Depth below transducer", 'm', depth, depth_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 3:offset | Offset: 40, Length: 16, Signed: True Resolution: 0.001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    offset = offset_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.001)
    nmea2000Message.fields.append(NMEA2000Field('offset', 'Offset', "Distance between transducer and surface (positive) or keel (negative)", 'm', offset, offset_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:range | Offset: 56, Length: 8, Signed: False Resolution: 10, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    range = range_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 10)
    nmea2000Message.fields.append(NMEA2000Field('range', 'Range', "Max measurement range", 'm', range, range_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_128267(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 128267."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # depth | Offset: 8, Length: 32, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'depth')
    if field is None:
        raise Exception("Cant encode this message, missing 'Depth'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFFFFFF) << 8
    
    # offset | Offset: 40, Length: 16, Resolution: 0.001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'offset')
    if field is None:
        raise Exception("Cant encode this message, missing 'Offset'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFF) << 40
    
    # range | Offset: 56, Length: 8, Resolution: 10, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'range')
    if field is None:
        raise Exception("Cant encode this message, missing 'Range'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 10) & 0xFF) << 56
    
    return data_raw


def is_fast_pgn_128275() -> bool:
    """Return True if PGN 128275 is a fast PGN."""
    return True
def decode_pgn_128275(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 128275."""
    nmea2000Message = NMEA2000Message(128275, 'distanceLog', 'Distance Log')
    running_bit_offset = 0
    # 1:date | Offset: 0, Length: 16, Signed: False Resolution: 1, Field Type: DATE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    date_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    date = decode_date(date_raw)
    nmea2000Message.fields.append(NMEA2000Field('date', 'Date', None, 'd', date, date_raw, PhysicalQuantities.DATE, FieldTypes.DATE, False))
    running_bit_offset += 16

    # 2:time | Offset: 16, Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    time_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    time = decode_time(time_raw)
    nmea2000Message.fields.append(NMEA2000Field('time', 'Time', "Seconds since midnight", 's', time, time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 3:log | Offset: 48, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    log = log_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('log', 'Log', "Total cumulative distance", 'm', log, log_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 4:trip_log | Offset: 80, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    trip_log = trip_log_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('trip_log', 'Trip Log', "Distance since last reset", 'm', trip_log, trip_log_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_128275(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 128275."""
    data_raw = 0
    # date | Offset: 0, Length: 16, Resolution: 1, Field Type: DATE
    field = next(f for f in nmea2000Message.fields if f.id == 'date')
    if field is None:
        raise Exception("Cant encode this message, missing 'Date'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 0
    # time | Offset: 16, Length: 32, Resolution: 0.0001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFFFFFF) << 16
    
    # log | Offset: 48, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'log')
    if field is None:
        raise Exception("Cant encode this message, missing 'Log'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 48
    # trip_log | Offset: 80, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'trip_log')
    if field is None:
        raise Exception("Cant encode this message, missing 'Trip Log'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 80
    return data_raw


def is_fast_pgn_128520() -> bool:
    """Return True if PGN 128520 is a fast PGN."""
    return True
def decode_pgn_128520(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 128520."""
    nmea2000Message = NMEA2000Message(128520, 'trackedTargetData', 'Tracked Target Data')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:target_id__ | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    target_id__ = target_id___raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('target_id__', 'Target ID #', "Number of route, waypoint, event, mark, etc.", None, target_id__, target_id___raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:track_status | Offset: 16, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    track_status_raw = decode_int(_data_raw_, running_bit_offset, 2)
    track_status = master_dict['TRACKING'].get(track_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('track_status', 'Track Status', None, None, track_status, track_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:reported_target | Offset: 18, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 18
    reported_target_raw = decode_int(_data_raw_, running_bit_offset, 1)
    reported_target = master_dict['YES_NO'].get(reported_target_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('reported_target', 'Reported Target', None, None, reported_target, reported_target_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 5:target_acquisition | Offset: 19, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 19
    target_acquisition_raw = decode_int(_data_raw_, running_bit_offset, 1)
    target_acquisition = master_dict['TARGET_ACQUISITION'].get(target_acquisition_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('target_acquisition', 'Target Acquisition', None, None, target_acquisition, target_acquisition_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 6:bearing_reference | Offset: 20, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 20
    bearing_reference_raw = decode_int(_data_raw_, running_bit_offset, 2)
    bearing_reference = master_dict['DIRECTION_REFERENCE'].get(bearing_reference_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('bearing_reference', 'Bearing Reference', None, None, bearing_reference, bearing_reference_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 7:reserved_22 | Offset: 22, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 22
    reserved_22 = reserved_22_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_22', 'Reserved', None, None, reserved_22, reserved_22_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 8:bearing | Offset: 24, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    bearing = bearing_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('bearing', 'Bearing', None, 'rad', bearing, bearing_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:distance | Offset: 40, Length: 32, Signed: False Resolution: 0.001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    distance = distance_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.001)
    nmea2000Message.fields.append(NMEA2000Field('distance', 'Distance', None, 'm', distance, distance_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 10:course | Offset: 72, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    course = course_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('course', 'Course', None, 'rad', course, course_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:speed | Offset: 88, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    speed = speed_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('speed', 'Speed', None, 'm/s', speed, speed_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 12:cpa | Offset: 104, Length: 32, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 104
    cpa = cpa_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('cpa', 'CPA', None, 'm', cpa, cpa_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 13:tcpa | Offset: 136, Length: 32, Signed: True Resolution: 0.001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 136
    tcpa_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 0.001)
    tcpa = decode_time(tcpa_raw)
    nmea2000Message.fields.append(NMEA2000Field('tcpa', 'TCPA', "negative = time elapsed since event, positive = time to go", 's', tcpa, tcpa_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 14:utc_of_fix | Offset: 168, Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 168
    utc_of_fix_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    utc_of_fix = decode_time(utc_of_fix_raw)
    nmea2000Message.fields.append(NMEA2000Field('utc_of_fix', 'UTC of Fix', "Seconds since midnight", 's', utc_of_fix, utc_of_fix_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 15:name | Offset: 200, Length: 1664, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 200
    name = name_raw = decode_string_fix(_data_raw_, running_bit_offset, 1664)
    nmea2000Message.fields.append(NMEA2000Field('name', 'Name', None, None, name, name_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 1664

    return nmea2000Message

def encode_pgn_128520(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 128520."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # target_id__ | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'target_id__')
    if field is None:
        raise Exception("Cant encode this message, missing 'Target ID #'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # track_status | Offset: 16, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'track_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Track Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_TRACKING(field.value)
    data_raw |= (field_value & 0x3) << 16
    # reported_target | Offset: 18, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'reported_target')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reported Target'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x1) << 18
    # target_acquisition | Offset: 19, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'target_acquisition')
    if field is None:
        raise Exception("Cant encode this message, missing 'Target Acquisition'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_TARGET_ACQUISITION(field.value)
    data_raw |= (field_value & 0x1) << 19
    # bearing_reference | Offset: 20, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'bearing_reference')
    if field is None:
        raise Exception("Cant encode this message, missing 'Bearing Reference'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DIRECTION_REFERENCE(field.value)
    data_raw |= (field_value & 0x3) << 20
    # reserved_22 | Offset: 22, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_22')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 22
    # bearing | Offset: 24, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'bearing')
    if field is None:
        raise Exception("Cant encode this message, missing 'Bearing'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 24
    
    # distance | Offset: 40, Length: 32, Resolution: 0.001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'distance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Distance'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFFFFFF) << 40
    
    # course | Offset: 72, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'course')
    if field is None:
        raise Exception("Cant encode this message, missing 'Course'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 72
    
    # speed | Offset: 88, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'speed')
    if field is None:
        raise Exception("Cant encode this message, missing 'Speed'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 88
    
    # cpa | Offset: 104, Length: 32, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'cpa')
    if field is None:
        raise Exception("Cant encode this message, missing 'CPA'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFFFFFF) << 104
    
    # tcpa | Offset: 136, Length: 32, Resolution: 0.001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'tcpa')
    if field is None:
        raise Exception("Cant encode this message, missing 'TCPA'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFFFFFF) << 136
    
    # utc_of_fix | Offset: 168, Length: 32, Resolution: 0.0001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'utc_of_fix')
    if field is None:
        raise Exception("Cant encode this message, missing 'UTC of Fix'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFFFFFF) << 168
    
    # name | Offset: 200, Length: 1664, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Name'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 200
    return data_raw


def is_fast_pgn_128538() -> bool:
    """Return True if PGN 128538 is a fast PGN."""
    return True
def decode_pgn_128538(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 128538."""
    nmea2000Message = NMEA2000Message(128538, 'elevatorCarStatus', 'Elevator Car Status')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:elevator_car_id | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    elevator_car_id = elevator_car_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('elevator_car_id', 'Elevator Car ID', None, None, elevator_car_id, elevator_car_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:elevator_car_usage | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    elevator_car_usage = elevator_car_usage_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('elevator_car_usage', 'Elevator Car Usage', None, None, elevator_car_usage, elevator_car_usage_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:smoke_sensor_status | Offset: 24, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    smoke_sensor_status = smoke_sensor_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('smoke_sensor_status', 'Smoke Sensor Status', None, None, smoke_sensor_status, smoke_sensor_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 5:limit_switch_sensor_status | Offset: 26, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 26
    limit_switch_sensor_status = limit_switch_sensor_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('limit_switch_sensor_status', 'Limit Switch Sensor Status', None, None, limit_switch_sensor_status, limit_switch_sensor_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 6:proximity_switch_sensor_status | Offset: 28, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 28
    proximity_switch_sensor_status = proximity_switch_sensor_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('proximity_switch_sensor_status', 'Proximity Switch Sensor Status', None, None, proximity_switch_sensor_status, proximity_switch_sensor_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 7:inertial_measurement_unit__imu__sensor_status | Offset: 30, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 30
    inertial_measurement_unit__imu__sensor_status = inertial_measurement_unit__imu__sensor_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('inertial_measurement_unit__imu__sensor_status', 'Inertial Measurement Unit (IMU) Sensor Status', None, None, inertial_measurement_unit__imu__sensor_status, inertial_measurement_unit__imu__sensor_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 8:elevator_load_limit_status | Offset: 32, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    elevator_load_limit_status = elevator_load_limit_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('elevator_load_limit_status', 'Elevator Load Limit Status', None, None, elevator_load_limit_status, elevator_load_limit_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 9:elevator_load_balance_status | Offset: 34, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 34
    elevator_load_balance_status = elevator_load_balance_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('elevator_load_balance_status', 'Elevator Load Balance Status', None, None, elevator_load_balance_status, elevator_load_balance_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 10:elevator_load_sensor_1_status | Offset: 36, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 36
    elevator_load_sensor_1_status = elevator_load_sensor_1_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('elevator_load_sensor_1_status', 'Elevator Load Sensor 1 Status', None, None, elevator_load_sensor_1_status, elevator_load_sensor_1_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 11:elevator_load_sensor_2_status | Offset: 38, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 38
    elevator_load_sensor_2_status = elevator_load_sensor_2_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('elevator_load_sensor_2_status', 'Elevator Load Sensor 2 Status', None, None, elevator_load_sensor_2_status, elevator_load_sensor_2_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 12:elevator_load_sensor_3_status | Offset: 40, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    elevator_load_sensor_3_status = elevator_load_sensor_3_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('elevator_load_sensor_3_status', 'Elevator Load Sensor 3 Status', None, None, elevator_load_sensor_3_status, elevator_load_sensor_3_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 13:elevator_load_sensor_4_status | Offset: 42, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 42
    elevator_load_sensor_4_status = elevator_load_sensor_4_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('elevator_load_sensor_4_status', 'Elevator Load Sensor 4 Status', None, None, elevator_load_sensor_4_status, elevator_load_sensor_4_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 14:reserved_44 | Offset: 44, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 44
    reserved_44 = reserved_44_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_44', 'Reserved', None, None, reserved_44, reserved_44_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 15:elevator_car_motion_status | Offset: 48, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    elevator_car_motion_status = elevator_car_motion_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('elevator_car_motion_status', 'Elevator Car Motion Status', None, None, elevator_car_motion_status, elevator_car_motion_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 16:elevator_car_door_status | Offset: 50, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 50
    elevator_car_door_status = elevator_car_door_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('elevator_car_door_status', 'Elevator Car Door Status', None, None, elevator_car_door_status, elevator_car_door_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 17:elevator_car_emergency_button_status | Offset: 52, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 52
    elevator_car_emergency_button_status = elevator_car_emergency_button_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('elevator_car_emergency_button_status', 'Elevator Car Emergency Button Status', None, None, elevator_car_emergency_button_status, elevator_car_emergency_button_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 18:elevator_car_buzzer_status | Offset: 54, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 54
    elevator_car_buzzer_status = elevator_car_buzzer_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('elevator_car_buzzer_status', 'Elevator Car Buzzer Status', None, None, elevator_car_buzzer_status, elevator_car_buzzer_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 19:open_door_button_status | Offset: 56, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    open_door_button_status = open_door_button_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('open_door_button_status', 'Open Door Button Status', None, None, open_door_button_status, open_door_button_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 20:close_door_button_status | Offset: 58, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 58
    close_door_button_status = close_door_button_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('close_door_button_status', 'Close Door Button Status', None, None, close_door_button_status, close_door_button_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 21:reserved_60 | Offset: 60, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 60
    reserved_60 = reserved_60_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_60', 'Reserved', None, None, reserved_60, reserved_60_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 22:current_deck | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    current_deck = current_deck_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('current_deck', 'Current Deck', None, None, current_deck, current_deck_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 23:destination_deck | Offset: 72, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    destination_deck = destination_deck_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('destination_deck', 'Destination Deck', None, None, destination_deck, destination_deck_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 24:total_number_of_decks | Offset: 80, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    total_number_of_decks = total_number_of_decks_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('total_number_of_decks', 'Total Number of Decks', None, None, total_number_of_decks, total_number_of_decks_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 25:weight_of_load_cell_1 | Offset: 88, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    weight_of_load_cell_1 = weight_of_load_cell_1_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('weight_of_load_cell_1', 'Weight of Load Cell 1', None, None, weight_of_load_cell_1, weight_of_load_cell_1_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 26:weight_of_load_cell_2 | Offset: 104, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 104
    weight_of_load_cell_2 = weight_of_load_cell_2_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('weight_of_load_cell_2', 'Weight of Load Cell 2', None, None, weight_of_load_cell_2, weight_of_load_cell_2_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 27:weight_of_load_cell_3 | Offset: 120, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    weight_of_load_cell_3 = weight_of_load_cell_3_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('weight_of_load_cell_3', 'Weight of Load Cell 3', None, None, weight_of_load_cell_3, weight_of_load_cell_3_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 28:weight_of_load_cell_4 | Offset: 136, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 136
    weight_of_load_cell_4 = weight_of_load_cell_4_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('weight_of_load_cell_4', 'Weight of Load Cell 4', None, None, weight_of_load_cell_4, weight_of_load_cell_4_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 29:speed_of_elevator_car | Offset: 152, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 152
    speed_of_elevator_car = speed_of_elevator_car_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('speed_of_elevator_car', 'Speed of Elevator Car', None, 'm/s', speed_of_elevator_car, speed_of_elevator_car_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 30:elevator_brake_status | Offset: 168, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 168
    elevator_brake_status = elevator_brake_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('elevator_brake_status', 'Elevator Brake Status', None, None, elevator_brake_status, elevator_brake_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 31:elevator_motor_rotation_control_status | Offset: 170, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 170
    elevator_motor_rotation_control_status = elevator_motor_rotation_control_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('elevator_motor_rotation_control_status', 'Elevator Motor rotation control Status', None, None, elevator_motor_rotation_control_status, elevator_motor_rotation_control_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 32:reserved_172 | Offset: 172, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 172
    reserved_172 = reserved_172_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_172', 'Reserved', None, None, reserved_172, reserved_172_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    return nmea2000Message

def encode_pgn_128538(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 128538."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # elevator_car_id | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'elevator_car_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elevator Car ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # elevator_car_usage | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'elevator_car_usage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elevator Car Usage'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # smoke_sensor_status | Offset: 24, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'smoke_sensor_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Smoke Sensor Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 24
    # limit_switch_sensor_status | Offset: 26, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'limit_switch_sensor_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Limit Switch Sensor Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 26
    # proximity_switch_sensor_status | Offset: 28, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'proximity_switch_sensor_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proximity Switch Sensor Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 28
    # inertial_measurement_unit__imu__sensor_status | Offset: 30, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'inertial_measurement_unit__imu__sensor_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Inertial Measurement Unit (IMU) Sensor Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 30
    # elevator_load_limit_status | Offset: 32, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'elevator_load_limit_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elevator Load Limit Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 32
    # elevator_load_balance_status | Offset: 34, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'elevator_load_balance_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elevator Load Balance Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 34
    # elevator_load_sensor_1_status | Offset: 36, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'elevator_load_sensor_1_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elevator Load Sensor 1 Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 36
    # elevator_load_sensor_2_status | Offset: 38, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'elevator_load_sensor_2_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elevator Load Sensor 2 Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 38
    # elevator_load_sensor_3_status | Offset: 40, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'elevator_load_sensor_3_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elevator Load Sensor 3 Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 40
    # elevator_load_sensor_4_status | Offset: 42, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'elevator_load_sensor_4_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elevator Load Sensor 4 Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 42
    # reserved_44 | Offset: 44, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_44')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 44
    # elevator_car_motion_status | Offset: 48, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'elevator_car_motion_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elevator Car Motion Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 48
    # elevator_car_door_status | Offset: 50, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'elevator_car_door_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elevator Car Door Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 50
    # elevator_car_emergency_button_status | Offset: 52, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'elevator_car_emergency_button_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elevator Car Emergency Button Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 52
    # elevator_car_buzzer_status | Offset: 54, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'elevator_car_buzzer_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elevator Car Buzzer Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 54
    # open_door_button_status | Offset: 56, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'open_door_button_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Open Door Button Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 56
    # close_door_button_status | Offset: 58, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'close_door_button_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Close Door Button Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 58
    # reserved_60 | Offset: 60, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_60')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 60
    # current_deck | Offset: 64, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'current_deck')
    if field is None:
        raise Exception("Cant encode this message, missing 'Current Deck'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 64
    # destination_deck | Offset: 72, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'destination_deck')
    if field is None:
        raise Exception("Cant encode this message, missing 'Destination Deck'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 72
    # total_number_of_decks | Offset: 80, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'total_number_of_decks')
    if field is None:
        raise Exception("Cant encode this message, missing 'Total Number of Decks'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 80
    # weight_of_load_cell_1 | Offset: 88, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'weight_of_load_cell_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Weight of Load Cell 1'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 88
    # weight_of_load_cell_2 | Offset: 104, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'weight_of_load_cell_2')
    if field is None:
        raise Exception("Cant encode this message, missing 'Weight of Load Cell 2'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 104
    # weight_of_load_cell_3 | Offset: 120, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'weight_of_load_cell_3')
    if field is None:
        raise Exception("Cant encode this message, missing 'Weight of Load Cell 3'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 120
    # weight_of_load_cell_4 | Offset: 136, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'weight_of_load_cell_4')
    if field is None:
        raise Exception("Cant encode this message, missing 'Weight of Load Cell 4'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 136
    # speed_of_elevator_car | Offset: 152, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'speed_of_elevator_car')
    if field is None:
        raise Exception("Cant encode this message, missing 'Speed of Elevator Car'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 152
    
    # elevator_brake_status | Offset: 168, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'elevator_brake_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elevator Brake Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 168
    # elevator_motor_rotation_control_status | Offset: 170, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'elevator_motor_rotation_control_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elevator Motor rotation control Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 170
    # reserved_172 | Offset: 172, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_172')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 172
    return data_raw


def is_fast_pgn_128768() -> bool:
    """Return True if PGN 128768 is a fast PGN."""
    return False
def decode_pgn_128768(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 128768."""
    nmea2000Message = NMEA2000Message(128768, 'elevatorMotorControl', 'Elevator Motor Control')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:elevator_car_id | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    elevator_car_id = elevator_car_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('elevator_car_id', 'Elevator Car ID', None, None, elevator_car_id, elevator_car_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:elevator_car_usage | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    elevator_car_usage = elevator_car_usage_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('elevator_car_usage', 'Elevator Car Usage', None, None, elevator_car_usage, elevator_car_usage_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:motor_acceleration_deceleration_profile_selection | Offset: 24, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    motor_acceleration_deceleration_profile_selection = motor_acceleration_deceleration_profile_selection_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('motor_acceleration_deceleration_profile_selection', 'Motor Acceleration/Deceleration profile selection', None, None, motor_acceleration_deceleration_profile_selection, motor_acceleration_deceleration_profile_selection_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 5:motor_rotational_control_status | Offset: 28, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 28
    motor_rotational_control_status = motor_rotational_control_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('motor_rotational_control_status', 'Motor Rotational Control Status', None, None, motor_rotational_control_status, motor_rotational_control_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 6:reserved_30 | Offset: 30, Length: 34, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 30
    reserved_30 = reserved_30_raw = decode_int(_data_raw_, running_bit_offset, 34)
    nmea2000Message.fields.append(NMEA2000Field('reserved_30', 'Reserved', None, None, reserved_30, reserved_30_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 34

    return nmea2000Message

def encode_pgn_128768(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 128768."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # elevator_car_id | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'elevator_car_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elevator Car ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # elevator_car_usage | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'elevator_car_usage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elevator Car Usage'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # motor_acceleration_deceleration_profile_selection | Offset: 24, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'motor_acceleration_deceleration_profile_selection')
    if field is None:
        raise Exception("Cant encode this message, missing 'Motor Acceleration/Deceleration profile selection'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 24
    # motor_rotational_control_status | Offset: 28, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'motor_rotational_control_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Motor Rotational Control Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 28
    # reserved_30 | Offset: 30, Length: 34, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_30')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3FFFFFFFF) << 30
    return data_raw


def is_fast_pgn_128769() -> bool:
    """Return True if PGN 128769 is a fast PGN."""
    return False
def decode_pgn_128769(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 128769."""
    nmea2000Message = NMEA2000Message(128769, 'elevatorDeckPushButton', 'Elevator Deck Push Button')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:elevator_call_button_id | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    elevator_call_button_id = elevator_call_button_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('elevator_call_button_id', 'Elevator Call Button ID', None, None, elevator_call_button_id, elevator_call_button_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:deck_button_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    deck_button_id = deck_button_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('deck_button_id', 'Deck Button ID', None, None, deck_button_id, deck_button_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:elevator_car_usage | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    elevator_car_usage = elevator_car_usage_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('elevator_car_usage', 'Elevator Car Usage', None, None, elevator_car_usage, elevator_car_usage_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:elevator_car_button_selection | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    elevator_car_button_selection = elevator_car_button_selection_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('elevator_car_button_selection', 'Elevator Car Button Selection', None, None, elevator_car_button_selection, elevator_car_button_selection_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:reserved_40 | Offset: 40, Length: 24, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    reserved_40 = reserved_40_raw = decode_int(_data_raw_, running_bit_offset, 24)
    nmea2000Message.fields.append(NMEA2000Field('reserved_40', 'Reserved', None, None, reserved_40, reserved_40_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 24

    return nmea2000Message

def encode_pgn_128769(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 128769."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # elevator_call_button_id | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'elevator_call_button_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elevator Call Button ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # deck_button_id | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'deck_button_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Deck Button ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # elevator_car_usage | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'elevator_car_usage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elevator Car Usage'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # elevator_car_button_selection | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'elevator_car_button_selection')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elevator Car Button Selection'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # reserved_40 | Offset: 40, Length: 24, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_40')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 40
    return data_raw


def is_fast_pgn_128776() -> bool:
    """Return True if PGN 128776 is a fast PGN."""
    return False
def decode_pgn_128776(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 128776."""
    nmea2000Message = NMEA2000Message(128776, 'windlassControlStatus', 'Windlass Control Status')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:windlass_id | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    windlass_id = windlass_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('windlass_id', 'Windlass ID', None, None, windlass_id, windlass_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:windlass_direction_control | Offset: 16, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    windlass_direction_control_raw = decode_int(_data_raw_, running_bit_offset, 2)
    windlass_direction_control = master_dict['WINDLASS_DIRECTION'].get(windlass_direction_control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('windlass_direction_control', 'Windlass Direction Control', None, None, windlass_direction_control, windlass_direction_control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:anchor_docking_control | Offset: 18, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 18
    anchor_docking_control_raw = decode_int(_data_raw_, running_bit_offset, 2)
    anchor_docking_control = master_dict['OFF_ON'].get(anchor_docking_control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('anchor_docking_control', 'Anchor Docking Control', None, None, anchor_docking_control, anchor_docking_control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 5:speed_control_type | Offset: 20, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 20
    speed_control_type_raw = decode_int(_data_raw_, running_bit_offset, 2)
    speed_control_type = master_dict['SPEED_TYPE'].get(speed_control_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('speed_control_type', 'Speed Control Type', None, None, speed_control_type, speed_control_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 6:reserved_22 | Offset: 22, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 22
    reserved_22 = reserved_22_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_22', 'Reserved', None, None, reserved_22, reserved_22_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 7:speed_control | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    speed_control = speed_control_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 8))
    nmea2000Message.fields.append(NMEA2000Field('speed_control', 'Speed Control', "0=Off,Single speed:1-100=On,Dual Speed:1-49=Slow/50-100=Fast,Proportional:10-100", None, speed_control, speed_control_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 8

    # 8:power_enable | Offset: 32, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    power_enable_raw = decode_int(_data_raw_, running_bit_offset, 2)
    power_enable = master_dict['OFF_ON'].get(power_enable_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('power_enable', 'Power Enable', None, None, power_enable, power_enable_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 9:mechanical_lock | Offset: 34, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 34
    mechanical_lock_raw = decode_int(_data_raw_, running_bit_offset, 2)
    mechanical_lock = master_dict['OFF_ON'].get(mechanical_lock_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('mechanical_lock', 'Mechanical Lock', None, None, mechanical_lock, mechanical_lock_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 10:deck_and_anchor_wash | Offset: 36, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 36
    deck_and_anchor_wash_raw = decode_int(_data_raw_, running_bit_offset, 2)
    deck_and_anchor_wash = master_dict['OFF_ON'].get(deck_and_anchor_wash_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('deck_and_anchor_wash', 'Deck and Anchor Wash', None, None, deck_and_anchor_wash, deck_and_anchor_wash_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 11:anchor_light | Offset: 38, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 38
    anchor_light_raw = decode_int(_data_raw_, running_bit_offset, 2)
    anchor_light = master_dict['OFF_ON'].get(anchor_light_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('anchor_light', 'Anchor Light', None, None, anchor_light, anchor_light_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 12:command_timeout | Offset: 40, Length: 8, Signed: False Resolution: 0.005, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    command_timeout_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 0.005)
    command_timeout = decode_time(command_timeout_raw)
    nmea2000Message.fields.append(NMEA2000Field('command_timeout', 'Command Timeout', "If timeout elapses the thruster stops operating and reverts to static mode", 's', command_timeout, command_timeout_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 8

    # 13:windlass_control_events | Offset: 48, Length: 4, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    windlass_control_events_raw = decode_int(_data_raw_, running_bit_offset, 4)
    windlass_control_events = decode_bit_lookup(windlass_control_events_raw, master_flags_dict['WINDLASS_CONTROL'])
    nmea2000Message.fields.append(NMEA2000Field('windlass_control_events', 'Windlass Control Events', None, None, windlass_control_events, windlass_control_events_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 4

    # 14:reserved_52 | Offset: 52, Length: 12, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 52
    reserved_52 = reserved_52_raw = decode_int(_data_raw_, running_bit_offset, 12)
    nmea2000Message.fields.append(NMEA2000Field('reserved_52', 'Reserved', None, None, reserved_52, reserved_52_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 12

    return nmea2000Message

def encode_pgn_128776(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 128776."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # windlass_id | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'windlass_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Windlass ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # windlass_direction_control | Offset: 16, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'windlass_direction_control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Windlass Direction Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_WINDLASS_DIRECTION(field.value)
    data_raw |= (field_value & 0x3) << 16
    # anchor_docking_control | Offset: 18, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'anchor_docking_control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Anchor Docking Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 18
    # speed_control_type | Offset: 20, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'speed_control_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Speed Control Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SPEED_TYPE(field.value)
    data_raw |= (field_value & 0x3) << 20
    # reserved_22 | Offset: 22, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_22')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 22
    # speed_control | Offset: 24, Length: 8, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'speed_control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Speed Control'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # power_enable | Offset: 32, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'power_enable')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power Enable'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 32
    # mechanical_lock | Offset: 34, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'mechanical_lock')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mechanical Lock'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 34
    # deck_and_anchor_wash | Offset: 36, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'deck_and_anchor_wash')
    if field is None:
        raise Exception("Cant encode this message, missing 'Deck and Anchor Wash'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 36
    # anchor_light | Offset: 38, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'anchor_light')
    if field is None:
        raise Exception("Cant encode this message, missing 'Anchor Light'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 38
    # command_timeout | Offset: 40, Length: 8, Resolution: 0.005, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'command_timeout')
    if field is None:
        raise Exception("Cant encode this message, missing 'Command Timeout'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.005) & 0xFF) << 40
    
    # windlass_control_events | Offset: 48, Length: 4, Resolution: 1, Field Type: BITLOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'windlass_control_events')
    if field is None:
        raise Exception("Cant encode this message, missing 'Windlass Control Events'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 48
    # reserved_52 | Offset: 52, Length: 12, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_52')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFF) << 52
    return data_raw


def is_fast_pgn_128777() -> bool:
    """Return True if PGN 128777 is a fast PGN."""
    return False
def decode_pgn_128777(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 128777."""
    nmea2000Message = NMEA2000Message(128777, 'anchorWindlassOperatingStatus', 'Anchor Windlass Operating Status')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:windlass_id | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    windlass_id = windlass_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('windlass_id', 'Windlass ID', None, None, windlass_id, windlass_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:windlass_direction_control | Offset: 16, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    windlass_direction_control_raw = decode_int(_data_raw_, running_bit_offset, 2)
    windlass_direction_control = master_dict['WINDLASS_DIRECTION'].get(windlass_direction_control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('windlass_direction_control', 'Windlass Direction Control', None, None, windlass_direction_control, windlass_direction_control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:windlass_motion_status | Offset: 18, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 18
    windlass_motion_status_raw = decode_int(_data_raw_, running_bit_offset, 2)
    windlass_motion_status = master_dict['WINDLASS_MOTION'].get(windlass_motion_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('windlass_motion_status', 'Windlass Motion Status', None, None, windlass_motion_status, windlass_motion_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 5:rode_type_status | Offset: 20, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 20
    rode_type_status_raw = decode_int(_data_raw_, running_bit_offset, 2)
    rode_type_status = master_dict['RODE_TYPE'].get(rode_type_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('rode_type_status', 'Rode Type Status', None, None, rode_type_status, rode_type_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 6:reserved_22 | Offset: 22, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 22
    reserved_22 = reserved_22_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_22', 'Reserved', None, None, reserved_22, reserved_22_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 7:rode_counter_value | Offset: 24, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    rode_counter_value = rode_counter_value_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('rode_counter_value', 'Rode Counter Value', None, 'm', rode_counter_value, rode_counter_value_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:windlass_line_speed | Offset: 40, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    windlass_line_speed = windlass_line_speed_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('windlass_line_speed', 'Windlass Line Speed', None, 'm/s', windlass_line_speed, windlass_line_speed_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:anchor_docking_status | Offset: 56, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    anchor_docking_status_raw = decode_int(_data_raw_, running_bit_offset, 2)
    anchor_docking_status = master_dict['DOCKING_STATUS'].get(anchor_docking_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('anchor_docking_status', 'Anchor Docking Status', None, None, anchor_docking_status, anchor_docking_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 10:windlass_operating_events | Offset: 58, Length: 6, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 58
    windlass_operating_events_raw = decode_int(_data_raw_, running_bit_offset, 6)
    windlass_operating_events = decode_bit_lookup(windlass_operating_events_raw, master_flags_dict['WINDLASS_OPERATION'])
    nmea2000Message.fields.append(NMEA2000Field('windlass_operating_events', 'Windlass Operating Events', None, None, windlass_operating_events, windlass_operating_events_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 6

    return nmea2000Message

def encode_pgn_128777(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 128777."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # windlass_id | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'windlass_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Windlass ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # windlass_direction_control | Offset: 16, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'windlass_direction_control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Windlass Direction Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_WINDLASS_DIRECTION(field.value)
    data_raw |= (field_value & 0x3) << 16
    # windlass_motion_status | Offset: 18, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'windlass_motion_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Windlass Motion Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_WINDLASS_MOTION(field.value)
    data_raw |= (field_value & 0x3) << 18
    # rode_type_status | Offset: 20, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'rode_type_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Rode Type Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_RODE_TYPE(field.value)
    data_raw |= (field_value & 0x3) << 20
    # reserved_22 | Offset: 22, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_22')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 22
    # rode_counter_value | Offset: 24, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'rode_counter_value')
    if field is None:
        raise Exception("Cant encode this message, missing 'Rode Counter Value'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 24
    
    # windlass_line_speed | Offset: 40, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'windlass_line_speed')
    if field is None:
        raise Exception("Cant encode this message, missing 'Windlass Line Speed'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 40
    
    # anchor_docking_status | Offset: 56, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'anchor_docking_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Anchor Docking Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DOCKING_STATUS(field.value)
    data_raw |= (field_value & 0x3) << 56
    # windlass_operating_events | Offset: 58, Length: 6, Resolution: 1, Field Type: BITLOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'windlass_operating_events')
    if field is None:
        raise Exception("Cant encode this message, missing 'Windlass Operating Events'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 58
    return data_raw


def is_fast_pgn_128778() -> bool:
    """Return True if PGN 128778 is a fast PGN."""
    return False
def decode_pgn_128778(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 128778."""
    nmea2000Message = NMEA2000Message(128778, 'anchorWindlassMonitoringStatus', 'Anchor Windlass Monitoring Status')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:windlass_id | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    windlass_id = windlass_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('windlass_id', 'Windlass ID', None, None, windlass_id, windlass_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:windlass_monitoring_events | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    windlass_monitoring_events_raw = decode_int(_data_raw_, running_bit_offset, 8)
    windlass_monitoring_events = decode_bit_lookup(windlass_monitoring_events_raw, master_flags_dict['WINDLASS_MONITORING'])
    nmea2000Message.fields.append(NMEA2000Field('windlass_monitoring_events', 'Windlass Monitoring Events', None, None, windlass_monitoring_events, windlass_monitoring_events_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 8

    # 4:controller_voltage | Offset: 24, Length: 8, Signed: False Resolution: 0.2, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    controller_voltage = controller_voltage_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 0.2)
    nmea2000Message.fields.append(NMEA2000Field('controller_voltage', 'Controller voltage', None, 'V', controller_voltage, controller_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:motor_current | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    motor_current = motor_current_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('motor_current', 'Motor current', None, 'A', motor_current, motor_current_raw, PhysicalQuantities.ELECTRICAL_CURRENT, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:total_motor_time | Offset: 40, Length: 16, Signed: False Resolution: 60, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    total_motor_time_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 60)
    total_motor_time = decode_time(total_motor_time_raw)
    nmea2000Message.fields.append(NMEA2000Field('total_motor_time', 'Total Motor Time', None, 's', total_motor_time, total_motor_time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    # 7:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_128778(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 128778."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # windlass_id | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'windlass_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Windlass ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # windlass_monitoring_events | Offset: 16, Length: 8, Resolution: 1, Field Type: BITLOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'windlass_monitoring_events')
    if field is None:
        raise Exception("Cant encode this message, missing 'Windlass Monitoring Events'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # controller_voltage | Offset: 24, Length: 8, Resolution: 0.2, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'controller_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Controller voltage'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.2) & 0xFF) << 24
    
    # motor_current | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'motor_current')
    if field is None:
        raise Exception("Cant encode this message, missing 'Motor current'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # total_motor_time | Offset: 40, Length: 16, Resolution: 60, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'total_motor_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Total Motor Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 60) & 0xFFFF) << 40
    
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_128780() -> bool:
    """Return True if PGN 128780 is a fast PGN."""
    return False
def decode_pgn_128780(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 128780."""
    nmea2000Message = NMEA2000Message(128780, 'linearActuatorControlStatus', 'Linear Actuator Control/Status')
    running_bit_offset = 0
    # 1:actuator_identifier | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    actuator_identifier = actuator_identifier_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('actuator_identifier', 'Actuator Identifier', None, None, actuator_identifier, actuator_identifier_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:commanded_device_position | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    commanded_device_position = commanded_device_position_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('commanded_device_position', 'Commanded Device Position', None, None, commanded_device_position, commanded_device_position_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:device_position | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    device_position = device_position_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('device_position', 'Device Position', None, None, device_position, device_position_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:maximum_device_travel | Offset: 24, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    maximum_device_travel = maximum_device_travel_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('maximum_device_travel', 'Maximum Device Travel', None, None, maximum_device_travel, maximum_device_travel_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:direction_of_travel | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    direction_of_travel = direction_of_travel_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('direction_of_travel', 'Direction of Travel', None, None, direction_of_travel, direction_of_travel_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:reserved_48 | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    reserved_48 = reserved_48_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('reserved_48', 'Reserved', None, None, reserved_48, reserved_48_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_128780(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 128780."""
    data_raw = 0
    # actuator_identifier | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'actuator_identifier')
    if field is None:
        raise Exception("Cant encode this message, missing 'Actuator Identifier'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # commanded_device_position | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'commanded_device_position')
    if field is None:
        raise Exception("Cant encode this message, missing 'Commanded Device Position'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # device_position | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'device_position')
    if field is None:
        raise Exception("Cant encode this message, missing 'Device Position'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # maximum_device_travel | Offset: 24, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'maximum_device_travel')
    if field is None:
        raise Exception("Cant encode this message, missing 'Maximum Device Travel'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 24
    # direction_of_travel | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'direction_of_travel')
    if field is None:
        raise Exception("Cant encode this message, missing 'Direction of Travel'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # reserved_48 | Offset: 48, Length: 16, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_48')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_129025() -> bool:
    """Return True if PGN 129025 is a fast PGN."""
    return False
def decode_pgn_129025(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129025."""
    nmea2000Message = NMEA2000Message(129025, 'positionRapidUpdate', 'Position, Rapid Update')
    running_bit_offset = 0
    # 1:latitude | Offset: 0, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    latitude = latitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('latitude', 'Latitude', None, 'deg', latitude, latitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:longitude | Offset: 32, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    longitude = longitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('longitude', 'Longitude', None, 'deg', longitude, longitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_129025(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129025."""
    data_raw = 0
    # latitude | Offset: 0, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'latitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Latitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 0
    
    # longitude | Offset: 32, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'longitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Longitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 32
    
    return data_raw


def is_fast_pgn_129026() -> bool:
    """Return True if PGN 129026 is a fast PGN."""
    return False
def decode_pgn_129026(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129026."""
    nmea2000Message = NMEA2000Message(129026, 'cogSogRapidUpdate', 'COG & SOG, Rapid Update')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:cog_reference | Offset: 8, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    cog_reference_raw = decode_int(_data_raw_, running_bit_offset, 2)
    cog_reference = master_dict['DIRECTION_REFERENCE'].get(cog_reference_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('cog_reference', 'COG Reference', None, None, cog_reference, cog_reference_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:reserved_10 | Offset: 10, Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 10
    reserved_10 = reserved_10_raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_10', 'Reserved', None, None, reserved_10, reserved_10_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    # 4:cog | Offset: 16, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    cog = cog_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('cog', 'COG', None, 'rad', cog, cog_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:sog | Offset: 32, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    sog = sog_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('sog', 'SOG', None, 'm/s', sog, sog_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:reserved_48 | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    reserved_48 = reserved_48_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('reserved_48', 'Reserved', None, None, reserved_48, reserved_48_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_129026(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129026."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # cog_reference | Offset: 8, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'cog_reference')
    if field is None:
        raise Exception("Cant encode this message, missing 'COG Reference'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DIRECTION_REFERENCE(field.value)
    data_raw |= (field_value & 0x3) << 8
    # reserved_10 | Offset: 10, Length: 6, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_10')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 10
    # cog | Offset: 16, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'cog')
    if field is None:
        raise Exception("Cant encode this message, missing 'COG'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 16
    
    # sog | Offset: 32, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sog')
    if field is None:
        raise Exception("Cant encode this message, missing 'SOG'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 32
    
    # reserved_48 | Offset: 48, Length: 16, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_48')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_129027() -> bool:
    """Return True if PGN 129027 is a fast PGN."""
    return False
def decode_pgn_129027(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129027."""
    nmea2000Message = NMEA2000Message(129027, 'positionDeltaRapidUpdate', 'Position Delta, Rapid Update')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:time_delta | Offset: 8, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    time_delta = time_delta_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('time_delta', 'Time Delta', None, None, time_delta, time_delta_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:latitude_delta | Offset: 24, Length: 16, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    latitude_delta = latitude_delta_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('latitude_delta', 'Latitude Delta', None, None, latitude_delta, latitude_delta_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:longitude_delta | Offset: 40, Length: 16, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    longitude_delta = longitude_delta_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('longitude_delta', 'Longitude Delta', None, None, longitude_delta, longitude_delta_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_129027(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129027."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # time_delta | Offset: 8, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'time_delta')
    if field is None:
        raise Exception("Cant encode this message, missing 'Time Delta'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 8
    # latitude_delta | Offset: 24, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'latitude_delta')
    if field is None:
        raise Exception("Cant encode this message, missing 'Latitude Delta'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 24
    # longitude_delta | Offset: 40, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'longitude_delta')
    if field is None:
        raise Exception("Cant encode this message, missing 'Longitude Delta'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 40
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_129028() -> bool:
    """Return True if PGN 129028 is a fast PGN."""
    return False
def decode_pgn_129028(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129028."""
    nmea2000Message = NMEA2000Message(129028, 'altitudeDeltaRapidUpdate', 'Altitude Delta, Rapid Update')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:time_delta | Offset: 8, Length: 16, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    time_delta = time_delta_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('time_delta', 'Time Delta', None, None, time_delta, time_delta_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:gnss_quality | Offset: 24, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    gnss_quality = gnss_quality_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('gnss_quality', 'GNSS Quality', None, None, gnss_quality, gnss_quality_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 4:direction | Offset: 26, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 26
    direction = direction_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('direction', 'Direction', None, None, direction, direction_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 5:reserved_28 | Offset: 28, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 28
    reserved_28 = reserved_28_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_28', 'Reserved', None, None, reserved_28, reserved_28_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 6:cog | Offset: 32, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    cog = cog_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('cog', 'COG', None, 'rad', cog, cog_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:altitude_delta | Offset: 48, Length: 16, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    altitude_delta = altitude_delta_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('altitude_delta', 'Altitude Delta', None, None, altitude_delta, altitude_delta_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_129028(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129028."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # time_delta | Offset: 8, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'time_delta')
    if field is None:
        raise Exception("Cant encode this message, missing 'Time Delta'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 8
    # gnss_quality | Offset: 24, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'gnss_quality')
    if field is None:
        raise Exception("Cant encode this message, missing 'GNSS Quality'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 24
    # direction | Offset: 26, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'direction')
    if field is None:
        raise Exception("Cant encode this message, missing 'Direction'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 26
    # reserved_28 | Offset: 28, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_28')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 28
    # cog | Offset: 32, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'cog')
    if field is None:
        raise Exception("Cant encode this message, missing 'COG'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 32
    
    # altitude_delta | Offset: 48, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'altitude_delta')
    if field is None:
        raise Exception("Cant encode this message, missing 'Altitude Delta'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_129029() -> bool:
    """Return True if PGN 129029 is a fast PGN."""
    return True
def decode_pgn_129029(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129029."""
    nmea2000Message = NMEA2000Message(129029, 'gnssPositionData', 'GNSS Position Data')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:date | Offset: 8, Length: 16, Signed: False Resolution: 1, Field Type: DATE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    date_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    date = decode_date(date_raw)
    nmea2000Message.fields.append(NMEA2000Field('date', 'Date', None, 'd', date, date_raw, PhysicalQuantities.DATE, FieldTypes.DATE, False))
    running_bit_offset += 16

    # 3:time | Offset: 24, Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    time_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    time = decode_time(time_raw)
    nmea2000Message.fields.append(NMEA2000Field('time', 'Time', "Seconds since midnight", 's', time, time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 4:latitude | Offset: 56, Length: 64, Signed: True Resolution: 1e-16, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    latitude = latitude_raw = decode_number(_data_raw_, running_bit_offset, 64, True, 1e-16)
    nmea2000Message.fields.append(NMEA2000Field('latitude', 'Latitude', None, 'deg', latitude, latitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 64

    # 5:longitude | Offset: 120, Length: 64, Signed: True Resolution: 1e-16, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    longitude = longitude_raw = decode_number(_data_raw_, running_bit_offset, 64, True, 1e-16)
    nmea2000Message.fields.append(NMEA2000Field('longitude', 'Longitude', None, 'deg', longitude, longitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 64

    # 6:altitude | Offset: 184, Length: 64, Signed: True Resolution: 1e-06, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 184
    altitude = altitude_raw = decode_number(_data_raw_, running_bit_offset, 64, True, 1e-06)
    nmea2000Message.fields.append(NMEA2000Field('altitude', 'Altitude', "Altitude referenced to WGS-84", 'm', altitude, altitude_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 64

    # 7:gnss_type | Offset: 248, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 248
    gnss_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    gnss_type = master_dict['GNS'].get(gnss_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('gnss_type', 'GNSS type', None, None, gnss_type, gnss_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 8:method | Offset: 252, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 252
    method_raw = decode_int(_data_raw_, running_bit_offset, 4)
    method = master_dict['GNS_METHOD'].get(method_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('method', 'Method', None, None, method, method_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 9:integrity | Offset: 256, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 256
    integrity_raw = decode_int(_data_raw_, running_bit_offset, 2)
    integrity = master_dict['GNS_INTEGRITY'].get(integrity_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('integrity', 'Integrity', None, None, integrity, integrity_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 10:reserved_258 | Offset: 258, Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 258
    reserved_258 = reserved_258_raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_258', 'Reserved', None, None, reserved_258, reserved_258_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    # 11:number_of_svs | Offset: 264, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 264
    number_of_svs = number_of_svs_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_svs', 'Number of SVs', "Number of satellites used in solution", None, number_of_svs, number_of_svs_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 12:hdop | Offset: 272, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 272
    hdop = hdop_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('hdop', 'HDOP', "Horizontal dilution of precision", None, hdop, hdop_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 13:pdop | Offset: 288, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 288
    pdop = pdop_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('pdop', 'PDOP', "Positional dilution of precision", None, pdop, pdop_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 14:geoidal_separation | Offset: 304, Length: 32, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 304
    geoidal_separation = geoidal_separation_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('geoidal_separation', 'Geoidal Separation', "Geoidal Separation", 'm', geoidal_separation, geoidal_separation_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 15:reference_stations | Offset: 336, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 336
    reference_stations = reference_stations_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('reference_stations', 'Reference Stations', "Number of reference stations", None, reference_stations, reference_stations_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 16:reference_station_type | Offset: 344, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 344
    reference_station_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    reference_station_type = master_dict['GNS'].get(reference_station_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('reference_station_type', 'Reference Station Type', None, None, reference_station_type, reference_station_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 17:reference_station_id | Offset: 348, Length: 12, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 348
    reference_station_id = reference_station_id_raw = decode_number(_data_raw_, running_bit_offset, 12, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('reference_station_id', 'Reference Station ID', None, None, reference_station_id, reference_station_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 12

    # 18:age_of_dgnss_corrections | Offset: 360, Length: 16, Signed: False Resolution: 0.01, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 360
    age_of_dgnss_corrections_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    age_of_dgnss_corrections = decode_time(age_of_dgnss_corrections_raw)
    nmea2000Message.fields.append(NMEA2000Field('age_of_dgnss_corrections', 'Age of DGNSS Corrections', None, 's', age_of_dgnss_corrections, age_of_dgnss_corrections_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_129029(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129029."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # date | Offset: 8, Length: 16, Resolution: 1, Field Type: DATE
    field = next(f for f in nmea2000Message.fields if f.id == 'date')
    if field is None:
        raise Exception("Cant encode this message, missing 'Date'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 8
    # time | Offset: 24, Length: 32, Resolution: 0.0001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFFFFFF) << 24
    
    # latitude | Offset: 56, Length: 64, Resolution: 1e-16, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'latitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Latitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-16) & 0xFFFFFFFFFFFFFFFF) << 56
    
    # longitude | Offset: 120, Length: 64, Resolution: 1e-16, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'longitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Longitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-16) & 0xFFFFFFFFFFFFFFFF) << 120
    
    # altitude | Offset: 184, Length: 64, Resolution: 1e-06, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'altitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Altitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-06) & 0xFFFFFFFFFFFFFFFF) << 184
    
    # gnss_type | Offset: 248, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'gnss_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'GNSS type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GNS(field.value)
    data_raw |= (field_value & 0xF) << 248
    # method | Offset: 252, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'method')
    if field is None:
        raise Exception("Cant encode this message, missing 'Method'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GNS_METHOD(field.value)
    data_raw |= (field_value & 0xF) << 252
    # integrity | Offset: 256, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'integrity')
    if field is None:
        raise Exception("Cant encode this message, missing 'Integrity'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GNS_INTEGRITY(field.value)
    data_raw |= (field_value & 0x3) << 256
    # reserved_258 | Offset: 258, Length: 6, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_258')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 258
    # number_of_svs | Offset: 264, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_svs')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of SVs'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 264
    # hdop | Offset: 272, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'hdop')
    if field is None:
        raise Exception("Cant encode this message, missing 'HDOP'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 272
    
    # pdop | Offset: 288, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pdop')
    if field is None:
        raise Exception("Cant encode this message, missing 'PDOP'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 288
    
    # geoidal_separation | Offset: 304, Length: 32, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'geoidal_separation')
    if field is None:
        raise Exception("Cant encode this message, missing 'Geoidal Separation'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFFFFFF) << 304
    
    # reference_stations | Offset: 336, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'reference_stations')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reference Stations'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 336
    # reference_station_type | Offset: 344, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'reference_station_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reference Station Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GNS(field.value)
    data_raw |= (field_value & 0xF) << 344
    # reference_station_id | Offset: 348, Length: 12, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'reference_station_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reference Station ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFF) << 348
    # age_of_dgnss_corrections | Offset: 360, Length: 16, Resolution: 0.01, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'age_of_dgnss_corrections')
    if field is None:
        raise Exception("Cant encode this message, missing 'Age of DGNSS Corrections'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 360
    
    return data_raw


def is_fast_pgn_129033() -> bool:
    """Return True if PGN 129033 is a fast PGN."""
    return False
def decode_pgn_129033(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129033."""
    nmea2000Message = NMEA2000Message(129033, 'timeDate', 'Time & Date')
    running_bit_offset = 0
    # 1:date | Offset: 0, Length: 16, Signed: False Resolution: 1, Field Type: DATE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    date_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    date = decode_date(date_raw)
    nmea2000Message.fields.append(NMEA2000Field('date', 'Date', None, 'd', date, date_raw, PhysicalQuantities.DATE, FieldTypes.DATE, False))
    running_bit_offset += 16

    # 2:time | Offset: 16, Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    time_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    time = decode_time(time_raw)
    nmea2000Message.fields.append(NMEA2000Field('time', 'Time', "Seconds since midnight", 's', time, time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 3:local_offset | Offset: 48, Length: 16, Signed: True Resolution: 60, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    local_offset_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 60)
    local_offset = decode_time(local_offset_raw)
    nmea2000Message.fields.append(NMEA2000Field('local_offset', 'Local Offset', None, 's', local_offset, local_offset_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_129033(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129033."""
    data_raw = 0
    # date | Offset: 0, Length: 16, Resolution: 1, Field Type: DATE
    field = next(f for f in nmea2000Message.fields if f.id == 'date')
    if field is None:
        raise Exception("Cant encode this message, missing 'Date'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 0
    # time | Offset: 16, Length: 32, Resolution: 0.0001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFFFFFF) << 16
    
    # local_offset | Offset: 48, Length: 16, Resolution: 60, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'local_offset')
    if field is None:
        raise Exception("Cant encode this message, missing 'Local Offset'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 60) & 0xFFFF) << 48
    
    return data_raw


def is_fast_pgn_129038() -> bool:
    """Return True if PGN 129038 is a fast PGN."""
    return True
def decode_pgn_129038(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129038."""
    nmea2000Message = NMEA2000Message(129038, 'aisClassAPositionReport', 'AIS Class A Position Report')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:user_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    user_id = user_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('user_id', 'User ID', None, None, user_id, user_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 4:longitude | Offset: 40, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    longitude = longitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('longitude', 'Longitude', None, 'deg', longitude, longitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 5:latitude | Offset: 72, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    latitude = latitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('latitude', 'Latitude', None, 'deg', latitude, latitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:position_accuracy | Offset: 104, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 104
    position_accuracy_raw = decode_int(_data_raw_, running_bit_offset, 1)
    position_accuracy = master_dict['POSITION_ACCURACY'].get(position_accuracy_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('position_accuracy', 'Position Accuracy', None, None, position_accuracy, position_accuracy_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 7:raim | Offset: 105, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 105
    raim_raw = decode_int(_data_raw_, running_bit_offset, 1)
    raim = master_dict['RAIM_FLAG'].get(raim_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('raim', 'RAIM', None, None, raim, raim_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 8:time_stamp | Offset: 106, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 106
    time_stamp_raw = decode_int(_data_raw_, running_bit_offset, 6)
    time_stamp = master_dict['TIME_STAMP'].get(time_stamp_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('time_stamp', 'Time Stamp', "0-59 = UTC second when the report was generated", None, time_stamp, time_stamp_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 9:cog | Offset: 112, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    cog = cog_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('cog', 'COG', None, 'rad', cog, cog_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 10:sog | Offset: 128, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    sog = sog_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('sog', 'SOG', None, 'm/s', sog, sog_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:communication_state | Offset: 144, Length: 19, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    communication_state = communication_state_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 19))
    nmea2000Message.fields.append(NMEA2000Field('communication_state', 'Communication State', "Information used by the TDMA slot allocation algorithm and synchronization information", None, communication_state, communication_state_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 19

    # 12:ais_transceiver_information | Offset: 163, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 163
    ais_transceiver_information_raw = decode_int(_data_raw_, running_bit_offset, 5)
    ais_transceiver_information = master_dict['AIS_TRANSCEIVER'].get(ais_transceiver_information_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_transceiver_information', 'AIS Transceiver information', None, None, ais_transceiver_information, ais_transceiver_information_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 13:heading | Offset: 168, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 168
    heading = heading_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('heading', 'Heading', "True heading", 'rad', heading, heading_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 14:rate_of_turn | Offset: 184, Length: 16, Signed: True Resolution: 3.125e-05, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 184
    rate_of_turn = rate_of_turn_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 3.125e-05)
    nmea2000Message.fields.append(NMEA2000Field('rate_of_turn', 'Rate of Turn', None, 'rad/s', rate_of_turn, rate_of_turn_raw, PhysicalQuantities.ANGULAR_VELOCITY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 15:nav_status | Offset: 200, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 200
    nav_status_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nav_status = master_dict['NAV_STATUS'].get(nav_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('nav_status', 'Nav Status', None, None, nav_status, nav_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 16:special_maneuver_indicator | Offset: 204, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 204
    special_maneuver_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    special_maneuver_indicator = master_dict['AIS_SPECIAL_MANEUVER'].get(special_maneuver_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('special_maneuver_indicator', 'Special Maneuver Indicator', None, None, special_maneuver_indicator, special_maneuver_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 17:reserved_206 | Offset: 206, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 206
    reserved_206 = reserved_206_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_206', 'Reserved', None, None, reserved_206, reserved_206_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 18:spare | Offset: 208, Length: 3, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 208
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 3)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 3

    # 19:reserved_211 | Offset: 211, Length: 5, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 211
    reserved_211 = reserved_211_raw = decode_int(_data_raw_, running_bit_offset, 5)
    nmea2000Message.fields.append(NMEA2000Field('reserved_211', 'Reserved', None, None, reserved_211, reserved_211_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 5

    # 20:sequence_id | Offset: 216, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 216
    sequence_id = sequence_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sequence_id', 'Sequence ID', None, None, sequence_id, sequence_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_129038(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129038."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 6
    # user_id | Offset: 8, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'user_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'User ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # longitude | Offset: 40, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'longitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Longitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 40
    
    # latitude | Offset: 72, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'latitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Latitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 72
    
    # position_accuracy | Offset: 104, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'position_accuracy')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position Accuracy'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_POSITION_ACCURACY(field.value)
    data_raw |= (field_value & 0x1) << 104
    # raim | Offset: 105, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'raim')
    if field is None:
        raise Exception("Cant encode this message, missing 'RAIM'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_RAIM_FLAG(field.value)
    data_raw |= (field_value & 0x1) << 105
    # time_stamp | Offset: 106, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'time_stamp')
    if field is None:
        raise Exception("Cant encode this message, missing 'Time Stamp'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_TIME_STAMP(field.value)
    data_raw |= (field_value & 0x3F) << 106
    # cog | Offset: 112, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'cog')
    if field is None:
        raise Exception("Cant encode this message, missing 'COG'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 112
    
    # sog | Offset: 128, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sog')
    if field is None:
        raise Exception("Cant encode this message, missing 'SOG'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 128
    
    # communication_state | Offset: 144, Length: 19, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'communication_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'Communication State'")
    field_value = field.value
    data_raw |= (field_value & 0x7FFFF) << 144
    # ais_transceiver_information | Offset: 163, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_transceiver_information')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS Transceiver information'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TRANSCEIVER(field.value)
    data_raw |= (field_value & 0x1F) << 163
    # heading | Offset: 168, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'heading')
    if field is None:
        raise Exception("Cant encode this message, missing 'Heading'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 168
    
    # rate_of_turn | Offset: 184, Length: 16, Resolution: 3.125e-05, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'rate_of_turn')
    if field is None:
        raise Exception("Cant encode this message, missing 'Rate of Turn'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 3.125e-05) & 0xFFFF) << 184
    
    # nav_status | Offset: 200, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'nav_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Nav Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_NAV_STATUS(field.value)
    data_raw |= (field_value & 0xF) << 200
    # special_maneuver_indicator | Offset: 204, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'special_maneuver_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Special Maneuver Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_SPECIAL_MANEUVER(field.value)
    data_raw |= (field_value & 0x3) << 204
    # reserved_206 | Offset: 206, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_206')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 206
    # spare | Offset: 208, Length: 3, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0x7) << 208
    # reserved_211 | Offset: 211, Length: 5, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_211')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1F) << 211
    # sequence_id | Offset: 216, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sequence_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Sequence ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 216
    return data_raw


def is_fast_pgn_129039() -> bool:
    """Return True if PGN 129039 is a fast PGN."""
    return True
def decode_pgn_129039(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129039."""
    nmea2000Message = NMEA2000Message(129039, 'aisClassBPositionReport', 'AIS Class B Position Report')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:user_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    user_id = user_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('user_id', 'User ID', None, None, user_id, user_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 4:longitude | Offset: 40, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    longitude = longitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('longitude', 'Longitude', None, 'deg', longitude, longitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 5:latitude | Offset: 72, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    latitude = latitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('latitude', 'Latitude', None, 'deg', latitude, latitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:position_accuracy | Offset: 104, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 104
    position_accuracy_raw = decode_int(_data_raw_, running_bit_offset, 1)
    position_accuracy = master_dict['POSITION_ACCURACY'].get(position_accuracy_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('position_accuracy', 'Position Accuracy', None, None, position_accuracy, position_accuracy_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 7:raim | Offset: 105, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 105
    raim_raw = decode_int(_data_raw_, running_bit_offset, 1)
    raim = master_dict['RAIM_FLAG'].get(raim_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('raim', 'RAIM', None, None, raim, raim_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 8:time_stamp | Offset: 106, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 106
    time_stamp_raw = decode_int(_data_raw_, running_bit_offset, 6)
    time_stamp = master_dict['TIME_STAMP'].get(time_stamp_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('time_stamp', 'Time Stamp', None, None, time_stamp, time_stamp_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 9:cog | Offset: 112, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    cog = cog_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('cog', 'COG', None, 'rad', cog, cog_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 10:sog | Offset: 128, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    sog = sog_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('sog', 'SOG', None, 'm/s', sog, sog_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:communication_state | Offset: 144, Length: 19, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    communication_state = communication_state_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 19))
    nmea2000Message.fields.append(NMEA2000Field('communication_state', 'Communication State', "Information used by the TDMA slot allocation algorithm and synchronization information", None, communication_state, communication_state_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 19

    # 12:ais_transceiver_information | Offset: 163, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 163
    ais_transceiver_information_raw = decode_int(_data_raw_, running_bit_offset, 5)
    ais_transceiver_information = master_dict['AIS_TRANSCEIVER'].get(ais_transceiver_information_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_transceiver_information', 'AIS Transceiver information', None, None, ais_transceiver_information, ais_transceiver_information_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 13:heading | Offset: 168, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 168
    heading = heading_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('heading', 'Heading', "True heading", 'rad', heading, heading_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 14:regional_application | Offset: 184, Length: 8, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 184
    regional_application = regional_application_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('regional_application', 'Regional Application', None, None, regional_application, regional_application_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 8

    # 15:regional_application_b | Offset: 192, Length: 2, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 192
    regional_application_b = regional_application_b_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('regional_application_b', 'Regional Application B', None, None, regional_application_b, regional_application_b_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 2

    # 16:unit_type | Offset: 194, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 194
    unit_type_raw = decode_int(_data_raw_, running_bit_offset, 1)
    unit_type = master_dict['AIS_TYPE'].get(unit_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('unit_type', 'Unit type', None, None, unit_type, unit_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 17:integrated_display | Offset: 195, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 195
    integrated_display_raw = decode_int(_data_raw_, running_bit_offset, 1)
    integrated_display = master_dict['YES_NO'].get(integrated_display_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('integrated_display', 'Integrated Display', "Whether the unit can show messages 12 and 14", None, integrated_display, integrated_display_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 18:dsc | Offset: 196, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 196
    dsc_raw = decode_int(_data_raw_, running_bit_offset, 1)
    dsc = master_dict['YES_NO'].get(dsc_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('dsc', 'DSC', None, None, dsc, dsc_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 19:band | Offset: 197, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 197
    band_raw = decode_int(_data_raw_, running_bit_offset, 1)
    band = master_dict['AIS_BAND'].get(band_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('band', 'Band', None, None, band, band_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 20:can_handle_msg_22 | Offset: 198, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 198
    can_handle_msg_22_raw = decode_int(_data_raw_, running_bit_offset, 1)
    can_handle_msg_22 = master_dict['YES_NO'].get(can_handle_msg_22_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('can_handle_msg_22', 'Can handle Msg 22', None, None, can_handle_msg_22, can_handle_msg_22_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 21:ais_mode | Offset: 199, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 199
    ais_mode_raw = decode_int(_data_raw_, running_bit_offset, 1)
    ais_mode = master_dict['AIS_MODE'].get(ais_mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_mode', 'AIS mode', None, None, ais_mode, ais_mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 22:ais_communication_state | Offset: 200, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 200
    ais_communication_state_raw = decode_int(_data_raw_, running_bit_offset, 1)
    ais_communication_state = master_dict['AIS_COMMUNICATION_STATE'].get(ais_communication_state_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_communication_state', 'AIS communication state', None, None, ais_communication_state, ais_communication_state_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 23:reserved_201 | Offset: 201, Length: 15, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 201
    reserved_201 = reserved_201_raw = decode_int(_data_raw_, running_bit_offset, 15)
    nmea2000Message.fields.append(NMEA2000Field('reserved_201', 'Reserved', None, None, reserved_201, reserved_201_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 15

    return nmea2000Message

def encode_pgn_129039(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129039."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 6
    # user_id | Offset: 8, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'user_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'User ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # longitude | Offset: 40, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'longitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Longitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 40
    
    # latitude | Offset: 72, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'latitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Latitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 72
    
    # position_accuracy | Offset: 104, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'position_accuracy')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position Accuracy'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_POSITION_ACCURACY(field.value)
    data_raw |= (field_value & 0x1) << 104
    # raim | Offset: 105, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'raim')
    if field is None:
        raise Exception("Cant encode this message, missing 'RAIM'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_RAIM_FLAG(field.value)
    data_raw |= (field_value & 0x1) << 105
    # time_stamp | Offset: 106, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'time_stamp')
    if field is None:
        raise Exception("Cant encode this message, missing 'Time Stamp'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_TIME_STAMP(field.value)
    data_raw |= (field_value & 0x3F) << 106
    # cog | Offset: 112, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'cog')
    if field is None:
        raise Exception("Cant encode this message, missing 'COG'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 112
    
    # sog | Offset: 128, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sog')
    if field is None:
        raise Exception("Cant encode this message, missing 'SOG'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 128
    
    # communication_state | Offset: 144, Length: 19, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'communication_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'Communication State'")
    field_value = field.value
    data_raw |= (field_value & 0x7FFFF) << 144
    # ais_transceiver_information | Offset: 163, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_transceiver_information')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS Transceiver information'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TRANSCEIVER(field.value)
    data_raw |= (field_value & 0x1F) << 163
    # heading | Offset: 168, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'heading')
    if field is None:
        raise Exception("Cant encode this message, missing 'Heading'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 168
    
    # regional_application | Offset: 184, Length: 8, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'regional_application')
    if field is None:
        raise Exception("Cant encode this message, missing 'Regional Application'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 184
    # regional_application_b | Offset: 192, Length: 2, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'regional_application_b')
    if field is None:
        raise Exception("Cant encode this message, missing 'Regional Application B'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 192
    # unit_type | Offset: 194, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'unit_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unit type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TYPE(field.value)
    data_raw |= (field_value & 0x1) << 194
    # integrated_display | Offset: 195, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'integrated_display')
    if field is None:
        raise Exception("Cant encode this message, missing 'Integrated Display'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x1) << 195
    # dsc | Offset: 196, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'dsc')
    if field is None:
        raise Exception("Cant encode this message, missing 'DSC'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x1) << 196
    # band | Offset: 197, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'band')
    if field is None:
        raise Exception("Cant encode this message, missing 'Band'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_BAND(field.value)
    data_raw |= (field_value & 0x1) << 197
    # can_handle_msg_22 | Offset: 198, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'can_handle_msg_22')
    if field is None:
        raise Exception("Cant encode this message, missing 'Can handle Msg 22'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x1) << 198
    # ais_mode | Offset: 199, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MODE(field.value)
    data_raw |= (field_value & 0x1) << 199
    # ais_communication_state | Offset: 200, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_communication_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS communication state'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_COMMUNICATION_STATE(field.value)
    data_raw |= (field_value & 0x1) << 200
    # reserved_201 | Offset: 201, Length: 15, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_201')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x7FFF) << 201
    return data_raw


def is_fast_pgn_129040() -> bool:
    """Return True if PGN 129040 is a fast PGN."""
    return True
def decode_pgn_129040(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129040."""
    nmea2000Message = NMEA2000Message(129040, 'aisClassBExtendedPositionReport', 'AIS Class B Extended Position Report')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:user_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    user_id = user_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('user_id', 'User ID', None, None, user_id, user_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 4:longitude | Offset: 40, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    longitude = longitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('longitude', 'Longitude', None, 'deg', longitude, longitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 5:latitude | Offset: 72, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    latitude = latitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('latitude', 'Latitude', None, 'deg', latitude, latitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:position_accuracy | Offset: 104, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 104
    position_accuracy_raw = decode_int(_data_raw_, running_bit_offset, 1)
    position_accuracy = master_dict['POSITION_ACCURACY'].get(position_accuracy_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('position_accuracy', 'Position Accuracy', None, None, position_accuracy, position_accuracy_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 7:raim | Offset: 105, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 105
    raim_raw = decode_int(_data_raw_, running_bit_offset, 1)
    raim = master_dict['RAIM_FLAG'].get(raim_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('raim', 'RAIM', None, None, raim, raim_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 8:time_stamp | Offset: 106, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 106
    time_stamp_raw = decode_int(_data_raw_, running_bit_offset, 6)
    time_stamp = master_dict['TIME_STAMP'].get(time_stamp_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('time_stamp', 'Time Stamp', None, None, time_stamp, time_stamp_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 9:cog | Offset: 112, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    cog = cog_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('cog', 'COG', None, 'rad', cog, cog_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 10:sog | Offset: 128, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    sog = sog_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('sog', 'SOG', None, 'm/s', sog, sog_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:regional_application | Offset: 144, Length: 8, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    regional_application = regional_application_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('regional_application', 'Regional Application', None, None, regional_application, regional_application_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 8

    # 12:regional_application_b | Offset: 152, Length: 4, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 152
    regional_application_b = regional_application_b_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('regional_application_b', 'Regional Application B', None, None, regional_application_b, regional_application_b_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 4

    # 13:reserved_156 | Offset: 156, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 156
    reserved_156 = reserved_156_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_156', 'Reserved', None, None, reserved_156, reserved_156_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 14:type_of_ship | Offset: 160, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 160
    type_of_ship_raw = decode_int(_data_raw_, running_bit_offset, 8)
    type_of_ship = master_dict['SHIP_TYPE'].get(type_of_ship_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('type_of_ship', 'Type of ship', None, None, type_of_ship, type_of_ship_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 15:true_heading | Offset: 168, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 168
    true_heading = true_heading_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('true_heading', 'True Heading', None, 'rad', true_heading, true_heading_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 16:reserved_184 | Offset: 184, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 184
    reserved_184 = reserved_184_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_184', 'Reserved', None, None, reserved_184, reserved_184_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 17:gnss_type | Offset: 188, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 188
    gnss_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    gnss_type = master_dict['POSITION_FIX_DEVICE'].get(gnss_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('gnss_type', 'GNSS type', None, None, gnss_type, gnss_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 18:length | Offset: 192, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 192
    length = length_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('length', 'Length', None, 'm', length, length_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 19:beam | Offset: 208, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 208
    beam = beam_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('beam', 'Beam', None, 'm', beam, beam_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 20:position_reference_from_starboard | Offset: 224, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 224
    position_reference_from_starboard = position_reference_from_starboard_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('position_reference_from_starboard', 'Position reference from Starboard', None, 'm', position_reference_from_starboard, position_reference_from_starboard_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 21:position_reference_from_bow | Offset: 240, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 240
    position_reference_from_bow = position_reference_from_bow_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('position_reference_from_bow', 'Position reference from Bow', None, 'm', position_reference_from_bow, position_reference_from_bow_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 22:name | Offset: 256, Length: 160, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 256
    name = name_raw = decode_string_fix(_data_raw_, running_bit_offset, 160)
    nmea2000Message.fields.append(NMEA2000Field('name', 'Name', None, None, name, name_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 160

    # 23:dte | Offset: 416, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 416
    dte_raw = decode_int(_data_raw_, running_bit_offset, 1)
    dte = master_dict['AVAILABLE'].get(dte_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('dte', 'DTE', None, None, dte, dte_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 24:ais_mode | Offset: 417, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 417
    ais_mode_raw = decode_int(_data_raw_, running_bit_offset, 1)
    ais_mode = master_dict['AIS_MODE'].get(ais_mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_mode', 'AIS mode', None, None, ais_mode, ais_mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 25:spare | Offset: 418, Length: 4, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 418
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 4

    # 26:ais_transceiver_information | Offset: 422, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 422
    ais_transceiver_information_raw = decode_int(_data_raw_, running_bit_offset, 5)
    ais_transceiver_information = master_dict['AIS_TRANSCEIVER'].get(ais_transceiver_information_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_transceiver_information', 'AIS Transceiver information', None, None, ais_transceiver_information, ais_transceiver_information_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 27:reserved_427 | Offset: 427, Length: 5, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 427
    reserved_427 = reserved_427_raw = decode_int(_data_raw_, running_bit_offset, 5)
    nmea2000Message.fields.append(NMEA2000Field('reserved_427', 'Reserved', None, None, reserved_427, reserved_427_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 5

    return nmea2000Message

def encode_pgn_129040(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129040."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 6
    # user_id | Offset: 8, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'user_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'User ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # longitude | Offset: 40, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'longitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Longitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 40
    
    # latitude | Offset: 72, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'latitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Latitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 72
    
    # position_accuracy | Offset: 104, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'position_accuracy')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position Accuracy'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_POSITION_ACCURACY(field.value)
    data_raw |= (field_value & 0x1) << 104
    # raim | Offset: 105, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'raim')
    if field is None:
        raise Exception("Cant encode this message, missing 'RAIM'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_RAIM_FLAG(field.value)
    data_raw |= (field_value & 0x1) << 105
    # time_stamp | Offset: 106, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'time_stamp')
    if field is None:
        raise Exception("Cant encode this message, missing 'Time Stamp'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_TIME_STAMP(field.value)
    data_raw |= (field_value & 0x3F) << 106
    # cog | Offset: 112, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'cog')
    if field is None:
        raise Exception("Cant encode this message, missing 'COG'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 112
    
    # sog | Offset: 128, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sog')
    if field is None:
        raise Exception("Cant encode this message, missing 'SOG'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 128
    
    # regional_application | Offset: 144, Length: 8, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'regional_application')
    if field is None:
        raise Exception("Cant encode this message, missing 'Regional Application'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 144
    # regional_application_b | Offset: 152, Length: 4, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'regional_application_b')
    if field is None:
        raise Exception("Cant encode this message, missing 'Regional Application B'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 152
    # reserved_156 | Offset: 156, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_156')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 156
    # type_of_ship | Offset: 160, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'type_of_ship')
    if field is None:
        raise Exception("Cant encode this message, missing 'Type of ship'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SHIP_TYPE(field.value)
    data_raw |= (field_value & 0xFF) << 160
    # true_heading | Offset: 168, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'true_heading')
    if field is None:
        raise Exception("Cant encode this message, missing 'True Heading'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 168
    
    # reserved_184 | Offset: 184, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_184')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 184
    # gnss_type | Offset: 188, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'gnss_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'GNSS type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_POSITION_FIX_DEVICE(field.value)
    data_raw |= (field_value & 0xF) << 188
    # length | Offset: 192, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'length')
    if field is None:
        raise Exception("Cant encode this message, missing 'Length'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 192
    
    # beam | Offset: 208, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'beam')
    if field is None:
        raise Exception("Cant encode this message, missing 'Beam'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 208
    
    # position_reference_from_starboard | Offset: 224, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'position_reference_from_starboard')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position reference from Starboard'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 224
    
    # position_reference_from_bow | Offset: 240, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'position_reference_from_bow')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position reference from Bow'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 240
    
    # name | Offset: 256, Length: 160, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Name'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 256
    # dte | Offset: 416, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'dte')
    if field is None:
        raise Exception("Cant encode this message, missing 'DTE'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AVAILABLE(field.value)
    data_raw |= (field_value & 0x1) << 416
    # ais_mode | Offset: 417, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MODE(field.value)
    data_raw |= (field_value & 0x1) << 417
    # spare | Offset: 418, Length: 4, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 418
    # ais_transceiver_information | Offset: 422, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_transceiver_information')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS Transceiver information'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TRANSCEIVER(field.value)
    data_raw |= (field_value & 0x1F) << 422
    # reserved_427 | Offset: 427, Length: 5, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_427')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1F) << 427
    return data_raw


def is_fast_pgn_129041() -> bool:
    """Return True if PGN 129041 is a fast PGN."""
    return True
def decode_pgn_129041(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129041."""
    nmea2000Message = NMEA2000Message(129041, 'aisAidsToNavigationAtonReport', 'AIS Aids to Navigation (AtoN) Report')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:user_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    user_id = user_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('user_id', 'User ID', None, None, user_id, user_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 4:longitude | Offset: 40, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    longitude = longitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('longitude', 'Longitude', None, 'deg', longitude, longitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 5:latitude | Offset: 72, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    latitude = latitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('latitude', 'Latitude', None, 'deg', latitude, latitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:position_accuracy | Offset: 104, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 104
    position_accuracy_raw = decode_int(_data_raw_, running_bit_offset, 1)
    position_accuracy = master_dict['POSITION_ACCURACY'].get(position_accuracy_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('position_accuracy', 'Position Accuracy', None, None, position_accuracy, position_accuracy_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 7:raim | Offset: 105, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 105
    raim_raw = decode_int(_data_raw_, running_bit_offset, 1)
    raim = master_dict['RAIM_FLAG'].get(raim_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('raim', 'RAIM', None, None, raim, raim_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 8:time_stamp | Offset: 106, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 106
    time_stamp_raw = decode_int(_data_raw_, running_bit_offset, 6)
    time_stamp = master_dict['TIME_STAMP'].get(time_stamp_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('time_stamp', 'Time Stamp', None, None, time_stamp, time_stamp_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 9:length_diameter | Offset: 112, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    length_diameter = length_diameter_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('length_diameter', 'Length/Diameter', None, 'm', length_diameter, length_diameter_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 10:beam_diameter | Offset: 128, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    beam_diameter = beam_diameter_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('beam_diameter', 'Beam/Diameter', None, 'm', beam_diameter, beam_diameter_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:position_reference_from_starboard_edge | Offset: 144, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    position_reference_from_starboard_edge = position_reference_from_starboard_edge_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('position_reference_from_starboard_edge', 'Position Reference from Starboard Edge', None, 'm', position_reference_from_starboard_edge, position_reference_from_starboard_edge_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 12:position_reference_from_true_north_facing_edge | Offset: 160, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 160
    position_reference_from_true_north_facing_edge = position_reference_from_true_north_facing_edge_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('position_reference_from_true_north_facing_edge', 'Position Reference from True North Facing Edge', None, 'm', position_reference_from_true_north_facing_edge, position_reference_from_true_north_facing_edge_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 13:aton_type | Offset: 176, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 176
    aton_type_raw = decode_int(_data_raw_, running_bit_offset, 5)
    aton_type = master_dict['ATON_TYPE'].get(aton_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('aton_type', 'AtoN Type', None, None, aton_type, aton_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 14:off_position_indicator | Offset: 181, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 181
    off_position_indicator_raw = decode_int(_data_raw_, running_bit_offset, 1)
    off_position_indicator = master_dict['YES_NO'].get(off_position_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('off_position_indicator', 'Off Position Indicator', None, None, off_position_indicator, off_position_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 15:virtual_aton_flag | Offset: 182, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 182
    virtual_aton_flag_raw = decode_int(_data_raw_, running_bit_offset, 1)
    virtual_aton_flag = master_dict['YES_NO'].get(virtual_aton_flag_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('virtual_aton_flag', 'Virtual AtoN Flag', None, None, virtual_aton_flag, virtual_aton_flag_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 16:assigned_mode_flag | Offset: 183, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 183
    assigned_mode_flag_raw = decode_int(_data_raw_, running_bit_offset, 1)
    assigned_mode_flag = master_dict['AIS_ASSIGNED_MODE'].get(assigned_mode_flag_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('assigned_mode_flag', 'Assigned Mode Flag', None, None, assigned_mode_flag, assigned_mode_flag_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 17:spare | Offset: 184, Length: 1, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 184
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 1)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 1

    # 18:position_fixing_device_type | Offset: 185, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 185
    position_fixing_device_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    position_fixing_device_type = master_dict['POSITION_FIX_DEVICE'].get(position_fixing_device_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('position_fixing_device_type', 'Position Fixing Device Type', None, None, position_fixing_device_type, position_fixing_device_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 19:reserved_189 | Offset: 189, Length: 3, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 189
    reserved_189 = reserved_189_raw = decode_int(_data_raw_, running_bit_offset, 3)
    nmea2000Message.fields.append(NMEA2000Field('reserved_189', 'Reserved', None, None, reserved_189, reserved_189_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 3

    # 20:aton_status | Offset: 192, Length: 8, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 192
    aton_status = aton_status_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 8))
    nmea2000Message.fields.append(NMEA2000Field('aton_status', 'AtoN Status', "00000000 = default", None, aton_status, aton_status_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 8

    # 21:ais_transceiver_information | Offset: 200, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 200
    ais_transceiver_information_raw = decode_int(_data_raw_, running_bit_offset, 5)
    ais_transceiver_information = master_dict['AIS_TRANSCEIVER'].get(ais_transceiver_information_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_transceiver_information', 'AIS Transceiver information', None, None, ais_transceiver_information, ais_transceiver_information_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 22:reserved_205 | Offset: 205, Length: 3, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 205
    reserved_205 = reserved_205_raw = decode_int(_data_raw_, running_bit_offset, 3)
    nmea2000Message.fields.append(NMEA2000Field('reserved_205', 'Reserved', None, None, reserved_205, reserved_205_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 3

    # 23:aton_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    aton_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    aton_name = aton_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('aton_name', 'AtoN Name', None, None, aton_name, aton_name_raw, None, FieldTypes.STRING_LAU, False))
    

    return nmea2000Message

def encode_pgn_129041(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129041."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 6
    # user_id | Offset: 8, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'user_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'User ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # longitude | Offset: 40, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'longitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Longitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 40
    
    # latitude | Offset: 72, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'latitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Latitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 72
    
    # position_accuracy | Offset: 104, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'position_accuracy')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position Accuracy'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_POSITION_ACCURACY(field.value)
    data_raw |= (field_value & 0x1) << 104
    # raim | Offset: 105, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'raim')
    if field is None:
        raise Exception("Cant encode this message, missing 'RAIM'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_RAIM_FLAG(field.value)
    data_raw |= (field_value & 0x1) << 105
    # time_stamp | Offset: 106, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'time_stamp')
    if field is None:
        raise Exception("Cant encode this message, missing 'Time Stamp'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_TIME_STAMP(field.value)
    data_raw |= (field_value & 0x3F) << 106
    # length_diameter | Offset: 112, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'length_diameter')
    if field is None:
        raise Exception("Cant encode this message, missing 'Length/Diameter'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 112
    
    # beam_diameter | Offset: 128, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'beam_diameter')
    if field is None:
        raise Exception("Cant encode this message, missing 'Beam/Diameter'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 128
    
    # position_reference_from_starboard_edge | Offset: 144, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'position_reference_from_starboard_edge')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position Reference from Starboard Edge'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 144
    
    # position_reference_from_true_north_facing_edge | Offset: 160, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'position_reference_from_true_north_facing_edge')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position Reference from True North Facing Edge'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 160
    
    # aton_type | Offset: 176, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'aton_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'AtoN Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ATON_TYPE(field.value)
    data_raw |= (field_value & 0x1F) << 176
    # off_position_indicator | Offset: 181, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'off_position_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Off Position Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x1) << 181
    # virtual_aton_flag | Offset: 182, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'virtual_aton_flag')
    if field is None:
        raise Exception("Cant encode this message, missing 'Virtual AtoN Flag'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x1) << 182
    # assigned_mode_flag | Offset: 183, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'assigned_mode_flag')
    if field is None:
        raise Exception("Cant encode this message, missing 'Assigned Mode Flag'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_ASSIGNED_MODE(field.value)
    data_raw |= (field_value & 0x1) << 183
    # spare | Offset: 184, Length: 1, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0x1) << 184
    # position_fixing_device_type | Offset: 185, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'position_fixing_device_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position Fixing Device Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_POSITION_FIX_DEVICE(field.value)
    data_raw |= (field_value & 0xF) << 185
    # reserved_189 | Offset: 189, Length: 3, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_189')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x7) << 189
    # aton_status | Offset: 192, Length: 8, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'aton_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'AtoN Status'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 192
    # ais_transceiver_information | Offset: 200, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_transceiver_information')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS Transceiver information'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TRANSCEIVER(field.value)
    data_raw |= (field_value & 0x1F) << 200
    # reserved_205 | Offset: 205, Length: 3, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_205')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x7) << 205
    raise Exception ("PGN 129041 not supporting encoding for now as AtoN Name is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_129044() -> bool:
    """Return True if PGN 129044 is a fast PGN."""
    return True
def decode_pgn_129044(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129044."""
    nmea2000Message = NMEA2000Message(129044, 'datum', 'Datum')
    running_bit_offset = 0
    # 1:local_datum | Offset: 0, Length: 32, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    local_datum = local_datum_raw = decode_string_fix(_data_raw_, running_bit_offset, 32)
    nmea2000Message.fields.append(NMEA2000Field('local_datum', 'Local Datum', "defined in IHO Publication S-60, Appendices B and C. First three chars are datum ID as per IHO tables. Fourth char is local datum subdivision code.", None, local_datum, local_datum_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 32

    # 2:delta_latitude | Offset: 32, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    delta_latitude = delta_latitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('delta_latitude', 'Delta Latitude', None, 'deg', delta_latitude, delta_latitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 3:delta_longitude | Offset: 64, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    delta_longitude = delta_longitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('delta_longitude', 'Delta Longitude', None, 'deg', delta_longitude, delta_longitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 4:delta_altitude | Offset: 96, Length: 32, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 96
    delta_altitude = delta_altitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('delta_altitude', 'Delta Altitude', None, 'm', delta_altitude, delta_altitude_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 5:reference_datum | Offset: 128, Length: 32, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    reference_datum = reference_datum_raw = decode_string_fix(_data_raw_, running_bit_offset, 32)
    nmea2000Message.fields.append(NMEA2000Field('reference_datum', 'Reference Datum', "defined in IHO Publication S-60, Appendices B and C. First three chars are datum ID as per IHO tables. Fourth char is local datum subdivision code.", None, reference_datum, reference_datum_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_129044(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129044."""
    data_raw = 0
    # local_datum | Offset: 0, Length: 32, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'local_datum')
    if field is None:
        raise Exception("Cant encode this message, missing 'Local Datum'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # delta_latitude | Offset: 32, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'delta_latitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Delta Latitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 32
    
    # delta_longitude | Offset: 64, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'delta_longitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Delta Longitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 64
    
    # delta_altitude | Offset: 96, Length: 32, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'delta_altitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Delta Altitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFFFFFF) << 96
    
    # reference_datum | Offset: 128, Length: 32, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'reference_datum')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reference Datum'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFF) << 128
    return data_raw


def is_fast_pgn_129045() -> bool:
    """Return True if PGN 129045 is a fast PGN."""
    return True
def decode_pgn_129045(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129045."""
    nmea2000Message = NMEA2000Message(129045, 'userDatum', 'User Datum')
    running_bit_offset = 0
    # 1:delta_x | Offset: 0, Length: 32, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    delta_x = delta_x_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('delta_x', 'Delta X', "Delta shift in X axis from WGS 84", 'm', delta_x, delta_x_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:delta_y | Offset: 32, Length: 32, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    delta_y = delta_y_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('delta_y', 'Delta Y', "Delta shift in Y axis from WGS 84", 'm', delta_y, delta_y_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 3:delta_z | Offset: 64, Length: 32, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    delta_z = delta_z_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('delta_z', 'Delta Z', "Delta shift in Z axis from WGS 84", 'm', delta_z, delta_z_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 4:rotation_in_x | Offset: 96, Length: 32, Signed: True Resolution: 1, Field Type: FLOAT, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 96
    rotation_in_x = rotation_in_x_raw = decode_float(_data_raw_, running_bit_offset, 32)
    nmea2000Message.fields.append(NMEA2000Field('rotation_in_x', 'Rotation in X', "Rotational shift in X axis from WGS 84. Rotations presented use the geodetic sign convention.  When looking along the positive axis towards the origin, counter-clockwise rotations are positive.", None, rotation_in_x, rotation_in_x_raw, None, FieldTypes.FLOAT, False))
    running_bit_offset += 32

    # 5:rotation_in_y | Offset: 128, Length: 32, Signed: True Resolution: 1, Field Type: FLOAT, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    rotation_in_y = rotation_in_y_raw = decode_float(_data_raw_, running_bit_offset, 32)
    nmea2000Message.fields.append(NMEA2000Field('rotation_in_y', 'Rotation in Y', "Rotational shift in Y axis from WGS 84. Rotations presented use the geodetic sign convention.  When looking along the positive axis towards the origin, counter-clockwise rotations are positive.", None, rotation_in_y, rotation_in_y_raw, None, FieldTypes.FLOAT, False))
    running_bit_offset += 32

    # 6:rotation_in_z | Offset: 160, Length: 32, Signed: True Resolution: 1, Field Type: FLOAT, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 160
    rotation_in_z = rotation_in_z_raw = decode_float(_data_raw_, running_bit_offset, 32)
    nmea2000Message.fields.append(NMEA2000Field('rotation_in_z', 'Rotation in Z', "Rotational shift in Z axis from WGS 84. Rotations presented use the geodetic sign convention.  When looking along the positive axis towards the origin, counter-clockwise rotations are positive.", None, rotation_in_z, rotation_in_z_raw, None, FieldTypes.FLOAT, False))
    running_bit_offset += 32

    # 7:scale | Offset: 192, Length: 32, Signed: True Resolution: 1, Field Type: FLOAT, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 192
    scale = scale_raw = decode_float(_data_raw_, running_bit_offset, 32)
    nmea2000Message.fields.append(NMEA2000Field('scale', 'Scale', None, 'ppm', scale, scale_raw, None, FieldTypes.FLOAT, False))
    running_bit_offset += 32

    # 8:ellipsoid_semi_major_axis | Offset: 224, Length: 32, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 224
    ellipsoid_semi_major_axis = ellipsoid_semi_major_axis_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('ellipsoid_semi_major_axis', 'Ellipsoid Semi-major Axis', "Semi-major axis (a) of the User Datum ellipsoid", 'm', ellipsoid_semi_major_axis, ellipsoid_semi_major_axis_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 9:ellipsoid_flattening_inverse | Offset: 256, Length: 32, Signed: True Resolution: 1, Field Type: FLOAT, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 256
    ellipsoid_flattening_inverse = ellipsoid_flattening_inverse_raw = decode_float(_data_raw_, running_bit_offset, 32)
    nmea2000Message.fields.append(NMEA2000Field('ellipsoid_flattening_inverse', 'Ellipsoid Flattening Inverse', "Flattening (1/f) of the User Datum ellipsoid", None, ellipsoid_flattening_inverse, ellipsoid_flattening_inverse_raw, None, FieldTypes.FLOAT, False))
    running_bit_offset += 32

    # 10:datum_name | Offset: 288, Length: 32, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 288
    datum_name = datum_name_raw = decode_string_fix(_data_raw_, running_bit_offset, 32)
    nmea2000Message.fields.append(NMEA2000Field('datum_name', 'Datum Name', "4 character code from IHO Publication S-60,Appendices B and C. First three chars are datum ID as per IHO tables. Fourth char is local datum subdivision code.", None, datum_name, datum_name_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_129045(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129045."""
    data_raw = 0
    # delta_x | Offset: 0, Length: 32, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'delta_x')
    if field is None:
        raise Exception("Cant encode this message, missing 'Delta X'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFFFFFF) << 0
    
    # delta_y | Offset: 32, Length: 32, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'delta_y')
    if field is None:
        raise Exception("Cant encode this message, missing 'Delta Y'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFFFFFF) << 32
    
    # delta_z | Offset: 64, Length: 32, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'delta_z')
    if field is None:
        raise Exception("Cant encode this message, missing 'Delta Z'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFFFFFF) << 64
    
    # rotation_in_x | Offset: 96, Length: 32, Resolution: 1, Field Type: FLOAT
    field = next(f for f in nmea2000Message.fields if f.id == 'rotation_in_x')
    if field is None:
        raise Exception("Cant encode this message, missing 'Rotation in X'")
    field_value = encode_float(field.value)
    data_raw |= (field_value & 0xFFFFFFFF) << 96
    # rotation_in_y | Offset: 128, Length: 32, Resolution: 1, Field Type: FLOAT
    field = next(f for f in nmea2000Message.fields if f.id == 'rotation_in_y')
    if field is None:
        raise Exception("Cant encode this message, missing 'Rotation in Y'")
    field_value = encode_float(field.value)
    data_raw |= (field_value & 0xFFFFFFFF) << 128
    # rotation_in_z | Offset: 160, Length: 32, Resolution: 1, Field Type: FLOAT
    field = next(f for f in nmea2000Message.fields if f.id == 'rotation_in_z')
    if field is None:
        raise Exception("Cant encode this message, missing 'Rotation in Z'")
    field_value = encode_float(field.value)
    data_raw |= (field_value & 0xFFFFFFFF) << 160
    # scale | Offset: 192, Length: 32, Resolution: 1, Field Type: FLOAT
    field = next(f for f in nmea2000Message.fields if f.id == 'scale')
    if field is None:
        raise Exception("Cant encode this message, missing 'Scale'")
    field_value = encode_float(field.value)
    data_raw |= (field_value & 0xFFFFFFFF) << 192
    # ellipsoid_semi_major_axis | Offset: 224, Length: 32, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ellipsoid_semi_major_axis')
    if field is None:
        raise Exception("Cant encode this message, missing 'Ellipsoid Semi-major Axis'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFFFFFF) << 224
    
    # ellipsoid_flattening_inverse | Offset: 256, Length: 32, Resolution: 1, Field Type: FLOAT
    field = next(f for f in nmea2000Message.fields if f.id == 'ellipsoid_flattening_inverse')
    if field is None:
        raise Exception("Cant encode this message, missing 'Ellipsoid Flattening Inverse'")
    field_value = encode_float(field.value)
    data_raw |= (field_value & 0xFFFFFFFF) << 256
    # datum_name | Offset: 288, Length: 32, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'datum_name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Datum Name'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFF) << 288
    return data_raw


def is_fast_pgn_129283() -> bool:
    """Return True if PGN 129283 is a fast PGN."""
    return False
def decode_pgn_129283(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129283."""
    nmea2000Message = NMEA2000Message(129283, 'crossTrackError', 'Cross Track Error')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:xte_mode | Offset: 8, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    xte_mode_raw = decode_int(_data_raw_, running_bit_offset, 4)
    xte_mode = master_dict['RESIDUAL_MODE'].get(xte_mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('xte_mode', 'XTE mode', None, None, xte_mode, xte_mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 3:reserved_12 | Offset: 12, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 12
    reserved_12 = reserved_12_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_12', 'Reserved', None, None, reserved_12, reserved_12_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 4:navigation_terminated | Offset: 14, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 14
    navigation_terminated_raw = decode_int(_data_raw_, running_bit_offset, 2)
    navigation_terminated = master_dict['YES_NO'].get(navigation_terminated_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('navigation_terminated', 'Navigation Terminated', None, None, navigation_terminated, navigation_terminated_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 5:xte | Offset: 16, Length: 32, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    xte = xte_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('xte', 'XTE', None, 'm', xte, xte_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:reserved_48 | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    reserved_48 = reserved_48_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('reserved_48', 'Reserved', None, None, reserved_48, reserved_48_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_129283(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129283."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # xte_mode | Offset: 8, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'xte_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'XTE mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_RESIDUAL_MODE(field.value)
    data_raw |= (field_value & 0xF) << 8
    # reserved_12 | Offset: 12, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_12')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 12
    # navigation_terminated | Offset: 14, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'navigation_terminated')
    if field is None:
        raise Exception("Cant encode this message, missing 'Navigation Terminated'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 14
    # xte | Offset: 16, Length: 32, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'xte')
    if field is None:
        raise Exception("Cant encode this message, missing 'XTE'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFFFFFF) << 16
    
    # reserved_48 | Offset: 48, Length: 16, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_48')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_129284() -> bool:
    """Return True if PGN 129284 is a fast PGN."""
    return True
def decode_pgn_129284(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129284."""
    nmea2000Message = NMEA2000Message(129284, 'navigationData', 'Navigation Data')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:distance_to_waypoint | Offset: 8, Length: 32, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    distance_to_waypoint = distance_to_waypoint_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('distance_to_waypoint', 'Distance to Waypoint', None, 'm', distance_to_waypoint, distance_to_waypoint_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 3:course_bearing_reference | Offset: 40, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    course_bearing_reference_raw = decode_int(_data_raw_, running_bit_offset, 2)
    course_bearing_reference = master_dict['DIRECTION_REFERENCE'].get(course_bearing_reference_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('course_bearing_reference', 'Course/Bearing reference', None, None, course_bearing_reference, course_bearing_reference_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:perpendicular_crossed | Offset: 42, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 42
    perpendicular_crossed_raw = decode_int(_data_raw_, running_bit_offset, 2)
    perpendicular_crossed = master_dict['YES_NO'].get(perpendicular_crossed_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('perpendicular_crossed', 'Perpendicular Crossed', None, None, perpendicular_crossed, perpendicular_crossed_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 5:arrival_circle_entered | Offset: 44, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 44
    arrival_circle_entered_raw = decode_int(_data_raw_, running_bit_offset, 2)
    arrival_circle_entered = master_dict['YES_NO'].get(arrival_circle_entered_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('arrival_circle_entered', 'Arrival Circle Entered', None, None, arrival_circle_entered, arrival_circle_entered_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 6:calculation_type | Offset: 46, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 46
    calculation_type_raw = decode_int(_data_raw_, running_bit_offset, 2)
    calculation_type = master_dict['BEARING_MODE'].get(calculation_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('calculation_type', 'Calculation Type', None, None, calculation_type, calculation_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 7:eta_time | Offset: 48, Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    eta_time_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    eta_time = decode_time(eta_time_raw)
    nmea2000Message.fields.append(NMEA2000Field('eta_time', 'ETA Time', "Seconds since midnight", 's', eta_time, eta_time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 8:eta_date | Offset: 80, Length: 16, Signed: False Resolution: 1, Field Type: DATE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    eta_date_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    eta_date = decode_date(eta_date_raw)
    nmea2000Message.fields.append(NMEA2000Field('eta_date', 'ETA Date', None, 'd', eta_date, eta_date_raw, PhysicalQuantities.DATE, FieldTypes.DATE, False))
    running_bit_offset += 16

    # 9:bearing__origin_to_destination_waypoint | Offset: 96, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 96
    bearing__origin_to_destination_waypoint = bearing__origin_to_destination_waypoint_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('bearing__origin_to_destination_waypoint', 'Bearing, Origin to Destination Waypoint', None, 'rad', bearing__origin_to_destination_waypoint, bearing__origin_to_destination_waypoint_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 10:bearing__position_to_destination_waypoint | Offset: 112, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    bearing__position_to_destination_waypoint = bearing__position_to_destination_waypoint_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('bearing__position_to_destination_waypoint', 'Bearing, Position to Destination Waypoint', None, 'rad', bearing__position_to_destination_waypoint, bearing__position_to_destination_waypoint_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:origin_waypoint_number | Offset: 128, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    origin_waypoint_number = origin_waypoint_number_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('origin_waypoint_number', 'Origin Waypoint Number', None, None, origin_waypoint_number, origin_waypoint_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 12:destination_waypoint_number | Offset: 160, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 160
    destination_waypoint_number = destination_waypoint_number_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('destination_waypoint_number', 'Destination Waypoint Number', None, None, destination_waypoint_number, destination_waypoint_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 13:destination_latitude | Offset: 192, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 192
    destination_latitude = destination_latitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('destination_latitude', 'Destination Latitude', None, 'deg', destination_latitude, destination_latitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 14:destination_longitude | Offset: 224, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 224
    destination_longitude = destination_longitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('destination_longitude', 'Destination Longitude', None, 'deg', destination_longitude, destination_longitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 15:waypoint_closing_velocity | Offset: 256, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 256
    waypoint_closing_velocity = waypoint_closing_velocity_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('waypoint_closing_velocity', 'Waypoint Closing Velocity', None, 'm/s', waypoint_closing_velocity, waypoint_closing_velocity_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_129284(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129284."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # distance_to_waypoint | Offset: 8, Length: 32, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'distance_to_waypoint')
    if field is None:
        raise Exception("Cant encode this message, missing 'Distance to Waypoint'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFFFFFF) << 8
    
    # course_bearing_reference | Offset: 40, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'course_bearing_reference')
    if field is None:
        raise Exception("Cant encode this message, missing 'Course/Bearing reference'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DIRECTION_REFERENCE(field.value)
    data_raw |= (field_value & 0x3) << 40
    # perpendicular_crossed | Offset: 42, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'perpendicular_crossed')
    if field is None:
        raise Exception("Cant encode this message, missing 'Perpendicular Crossed'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 42
    # arrival_circle_entered | Offset: 44, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'arrival_circle_entered')
    if field is None:
        raise Exception("Cant encode this message, missing 'Arrival Circle Entered'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 44
    # calculation_type | Offset: 46, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'calculation_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Calculation Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_BEARING_MODE(field.value)
    data_raw |= (field_value & 0x3) << 46
    # eta_time | Offset: 48, Length: 32, Resolution: 0.0001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'eta_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'ETA Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFFFFFF) << 48
    
    # eta_date | Offset: 80, Length: 16, Resolution: 1, Field Type: DATE
    field = next(f for f in nmea2000Message.fields if f.id == 'eta_date')
    if field is None:
        raise Exception("Cant encode this message, missing 'ETA Date'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 80
    # bearing__origin_to_destination_waypoint | Offset: 96, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'bearing__origin_to_destination_waypoint')
    if field is None:
        raise Exception("Cant encode this message, missing 'Bearing, Origin to Destination Waypoint'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 96
    
    # bearing__position_to_destination_waypoint | Offset: 112, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'bearing__position_to_destination_waypoint')
    if field is None:
        raise Exception("Cant encode this message, missing 'Bearing, Position to Destination Waypoint'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 112
    
    # origin_waypoint_number | Offset: 128, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'origin_waypoint_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Origin Waypoint Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 128
    # destination_waypoint_number | Offset: 160, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'destination_waypoint_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Destination Waypoint Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 160
    # destination_latitude | Offset: 192, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'destination_latitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Destination Latitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 192
    
    # destination_longitude | Offset: 224, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'destination_longitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Destination Longitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 224
    
    # waypoint_closing_velocity | Offset: 256, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'waypoint_closing_velocity')
    if field is None:
        raise Exception("Cant encode this message, missing 'Waypoint Closing Velocity'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 256
    
    return data_raw


def is_fast_pgn_129285() -> bool:
    """Return True if PGN 129285 is a fast PGN."""
    return True
def decode_pgn_129285(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129285."""
    nmea2000Message = NMEA2000Message(129285, 'navigationRouteWpInformation', 'Navigation - Route/WP Information')
    running_bit_offset = 0
    # 1:start_rps_ | Offset: 0, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    start_rps_ = start_rps__raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('start_rps_', 'Start RPS#', None, None, start_rps_, start_rps__raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:nitems | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    nitems = nitems_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('nitems', 'nItems', None, None, nitems, nitems_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:database_id | Offset: 32, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    database_id = database_id_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('database_id', 'Database ID', None, None, database_id, database_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:route_id | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    route_id = route_id_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('route_id', 'Route ID', None, None, route_id, route_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:navigation_direction_in_route | Offset: 64, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    navigation_direction_in_route_raw = decode_int(_data_raw_, running_bit_offset, 3)
    navigation_direction_in_route = master_dict['DIRECTION'].get(navigation_direction_in_route_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('navigation_direction_in_route', 'Navigation direction in route', None, None, navigation_direction_in_route, navigation_direction_in_route_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 6:supplementary_route_wp_data_available | Offset: 67, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 67
    supplementary_route_wp_data_available_raw = decode_int(_data_raw_, running_bit_offset, 2)
    supplementary_route_wp_data_available = master_dict['OFF_ON'].get(supplementary_route_wp_data_available_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('supplementary_route_wp_data_available', 'Supplementary Route/WP data available', None, None, supplementary_route_wp_data_available, supplementary_route_wp_data_available_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 7:reserved_69 | Offset: 69, Length: 3, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 69
    reserved_69 = reserved_69_raw = decode_int(_data_raw_, running_bit_offset, 3)
    nmea2000Message.fields.append(NMEA2000Field('reserved_69', 'Reserved', None, None, reserved_69, reserved_69_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 3

    # 8:route_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    route_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    route_name = route_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('route_name', 'Route Name', None, None, route_name, route_name_raw, None, FieldTypes.STRING_LAU, False))
    

    # 9:reserved_ | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    reserved_ = reserved__raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_', 'Reserved', None, None, reserved_, reserved__raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 10:wp_id | Offset: , Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    wp_id = wp_id_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('wp_id', 'WP ID', None, None, wp_id, wp_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:wp_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    wp_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    wp_name = wp_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('wp_name', 'WP Name', None, None, wp_name, wp_name_raw, None, FieldTypes.STRING_LAU, False))
    

    # 12:wp_latitude | Offset: , Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    wp_latitude = wp_latitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('wp_latitude', 'WP Latitude', None, 'deg', wp_latitude, wp_latitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 13:wp_longitude | Offset: , Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    wp_longitude = wp_longitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('wp_longitude', 'WP Longitude', None, 'deg', wp_longitude, wp_longitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_129285(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129285."""
    data_raw = 0
    # start_rps_ | Offset: 0, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'start_rps_')
    if field is None:
        raise Exception("Cant encode this message, missing 'Start RPS#'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 0
    # nitems | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'nitems')
    if field is None:
        raise Exception("Cant encode this message, missing 'nItems'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # database_id | Offset: 32, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'database_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Database ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 32
    # route_id | Offset: 48, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'route_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Route ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    # navigation_direction_in_route | Offset: 64, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'navigation_direction_in_route')
    if field is None:
        raise Exception("Cant encode this message, missing 'Navigation direction in route'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DIRECTION(field.value)
    data_raw |= (field_value & 0x7) << 64
    # supplementary_route_wp_data_available | Offset: 67, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'supplementary_route_wp_data_available')
    if field is None:
        raise Exception("Cant encode this message, missing 'Supplementary Route/WP data available'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 67
    # reserved_69 | Offset: 69, Length: 3, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_69')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x7) << 69
    raise Exception ("PGN 129285 not supporting encoding for now as Route Name is missing BitLength or BitOffset")
    raise Exception ("PGN 129285 not supporting encoding for now as Reserved is missing BitLength or BitOffset")
    raise Exception ("PGN 129285 not supporting encoding for now as WP ID is missing BitLength or BitOffset")
    raise Exception ("PGN 129285 not supporting encoding for now as WP Name is missing BitLength or BitOffset")
    raise Exception ("PGN 129285 not supporting encoding for now as WP Latitude is missing BitLength or BitOffset")
    raise Exception ("PGN 129285 not supporting encoding for now as WP Longitude is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_129291() -> bool:
    """Return True if PGN 129291 is a fast PGN."""
    return False
def decode_pgn_129291(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129291."""
    nmea2000Message = NMEA2000Message(129291, 'setDriftRapidUpdate', 'Set & Drift, Rapid Update')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:set_reference | Offset: 8, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    set_reference_raw = decode_int(_data_raw_, running_bit_offset, 2)
    set_reference = master_dict['DIRECTION_REFERENCE'].get(set_reference_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('set_reference', 'Set Reference', None, None, set_reference, set_reference_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:reserved_10 | Offset: 10, Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 10
    reserved_10 = reserved_10_raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_10', 'Reserved', None, None, reserved_10, reserved_10_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    # 4:set | Offset: 16, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    set = set_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('set', 'Set', None, 'rad', set, set_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:drift | Offset: 32, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    drift = drift_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('drift', 'Drift', None, 'm/s', drift, drift_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:reserved_48 | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    reserved_48 = reserved_48_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('reserved_48', 'Reserved', None, None, reserved_48, reserved_48_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_129291(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129291."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # set_reference | Offset: 8, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'set_reference')
    if field is None:
        raise Exception("Cant encode this message, missing 'Set Reference'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DIRECTION_REFERENCE(field.value)
    data_raw |= (field_value & 0x3) << 8
    # reserved_10 | Offset: 10, Length: 6, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_10')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 10
    # set | Offset: 16, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'set')
    if field is None:
        raise Exception("Cant encode this message, missing 'Set'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 16
    
    # drift | Offset: 32, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'drift')
    if field is None:
        raise Exception("Cant encode this message, missing 'Drift'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 32
    
    # reserved_48 | Offset: 48, Length: 16, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_48')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_129301() -> bool:
    """Return True if PGN 129301 is a fast PGN."""
    return True
def decode_pgn_129301(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129301."""
    nmea2000Message = NMEA2000Message(129301, 'navigationRouteTimeToFromMark', 'Navigation - Route / Time to+from Mark')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:time_to_mark | Offset: 8, Length: 32, Signed: True Resolution: 0.001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    time_to_mark_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 0.001)
    time_to_mark = decode_time(time_to_mark_raw)
    nmea2000Message.fields.append(NMEA2000Field('time_to_mark', 'Time to mark', "negative = elapsed since event, positive = time to go", 's', time_to_mark, time_to_mark_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 3:mark_type | Offset: 40, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    mark_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    mark_type = master_dict['MARK_TYPE'].get(mark_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('mark_type', 'Mark Type', None, None, mark_type, mark_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 4:reserved_44 | Offset: 44, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 44
    reserved_44 = reserved_44_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_44', 'Reserved', None, None, reserved_44, reserved_44_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 5:mark_id | Offset: 48, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    mark_id = mark_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('mark_id', 'Mark ID', None, None, mark_id, mark_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_129301(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129301."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # time_to_mark | Offset: 8, Length: 32, Resolution: 0.001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'time_to_mark')
    if field is None:
        raise Exception("Cant encode this message, missing 'Time to mark'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFFFFFF) << 8
    
    # mark_type | Offset: 40, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'mark_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mark Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MARK_TYPE(field.value)
    data_raw |= (field_value & 0xF) << 40
    # reserved_44 | Offset: 44, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_44')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 44
    # mark_id | Offset: 48, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'mark_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mark ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 48
    return data_raw


def is_fast_pgn_129302() -> bool:
    """Return True if PGN 129302 is a fast PGN."""
    return True
def decode_pgn_129302(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129302."""
    nmea2000Message = NMEA2000Message(129302, 'bearingAndDistanceBetweenTwoMarks', 'Bearing and Distance between two Marks')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:bearing_reference | Offset: 8, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    bearing_reference_raw = decode_int(_data_raw_, running_bit_offset, 2)
    bearing_reference = master_dict['DIRECTION_REFERENCE'].get(bearing_reference_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('bearing_reference', 'Bearing Reference', None, None, bearing_reference, bearing_reference_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:calculation_type | Offset: 10, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 10
    calculation_type_raw = decode_int(_data_raw_, running_bit_offset, 2)
    calculation_type = master_dict['BEARING_MODE'].get(calculation_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('calculation_type', 'Calculation Type', None, None, calculation_type, calculation_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:reserved_12 | Offset: 12, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 12
    reserved_12 = reserved_12_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_12', 'Reserved', None, None, reserved_12, reserved_12_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 5:bearing__origin_to_destination | Offset: 16, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    bearing__origin_to_destination = bearing__origin_to_destination_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('bearing__origin_to_destination', 'Bearing, Origin to Destination', None, 'rad', bearing__origin_to_destination, bearing__origin_to_destination_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:distance | Offset: 32, Length: 32, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    distance = distance_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('distance', 'Distance', None, 'm', distance, distance_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 7:origin_mark_type | Offset: 64, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    origin_mark_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    origin_mark_type = master_dict['MARK_TYPE'].get(origin_mark_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('origin_mark_type', 'Origin Mark Type', None, None, origin_mark_type, origin_mark_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 8:destination_mark_type | Offset: 68, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 68
    destination_mark_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    destination_mark_type = master_dict['MARK_TYPE'].get(destination_mark_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('destination_mark_type', 'Destination Mark Type', None, None, destination_mark_type, destination_mark_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 9:origin_mark_id | Offset: 72, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    origin_mark_id = origin_mark_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('origin_mark_id', 'Origin Mark ID', None, None, origin_mark_id, origin_mark_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 10:destination_mark_id | Offset: 104, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 104
    destination_mark_id = destination_mark_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('destination_mark_id', 'Destination Mark ID', None, None, destination_mark_id, destination_mark_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_129302(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129302."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # bearing_reference | Offset: 8, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'bearing_reference')
    if field is None:
        raise Exception("Cant encode this message, missing 'Bearing Reference'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DIRECTION_REFERENCE(field.value)
    data_raw |= (field_value & 0x3) << 8
    # calculation_type | Offset: 10, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'calculation_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Calculation Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_BEARING_MODE(field.value)
    data_raw |= (field_value & 0x3) << 10
    # reserved_12 | Offset: 12, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_12')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 12
    # bearing__origin_to_destination | Offset: 16, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'bearing__origin_to_destination')
    if field is None:
        raise Exception("Cant encode this message, missing 'Bearing, Origin to Destination'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 16
    
    # distance | Offset: 32, Length: 32, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'distance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Distance'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFFFFFF) << 32
    
    # origin_mark_type | Offset: 64, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'origin_mark_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Origin Mark Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MARK_TYPE(field.value)
    data_raw |= (field_value & 0xF) << 64
    # destination_mark_type | Offset: 68, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'destination_mark_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Destination Mark Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MARK_TYPE(field.value)
    data_raw |= (field_value & 0xF) << 68
    # origin_mark_id | Offset: 72, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'origin_mark_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Origin Mark ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 72
    # destination_mark_id | Offset: 104, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'destination_mark_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Destination Mark ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 104
    return data_raw


def is_fast_pgn_129538() -> bool:
    """Return True if PGN 129538 is a fast PGN."""
    return True
def decode_pgn_129538(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129538."""
    nmea2000Message = NMEA2000Message(129538, 'gnssControlStatus', 'GNSS Control Status')
    running_bit_offset = 0
    # 1:sv_elevation_mask | Offset: 0, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sv_elevation_mask = sv_elevation_mask_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('sv_elevation_mask', 'SV Elevation Mask', "Will not use SV below this elevation", 'rad', sv_elevation_mask, sv_elevation_mask_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:pdop_mask | Offset: 16, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    pdop_mask = pdop_mask_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('pdop_mask', 'PDOP Mask', "Will not report position above this PDOP", None, pdop_mask, pdop_mask_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:pdop_switch | Offset: 32, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    pdop_switch = pdop_switch_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('pdop_switch', 'PDOP Switch', "Will report 2D position above this PDOP", None, pdop_switch, pdop_switch_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:snr_mask | Offset: 48, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    snr_mask = snr_mask_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('snr_mask', 'SNR Mask', "Will not use SV below this SNR", 'dB', snr_mask, snr_mask_raw, PhysicalQuantities.SIGNAL_TO_NOISE_RATIO, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:gnss_mode__desired_ | Offset: 64, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    gnss_mode__desired__raw = decode_int(_data_raw_, running_bit_offset, 3)
    gnss_mode__desired_ = master_dict['GNSS_MODE'].get(gnss_mode__desired__raw, None)
    nmea2000Message.fields.append(NMEA2000Field('gnss_mode__desired_', 'GNSS Mode (desired)', None, None, gnss_mode__desired_, gnss_mode__desired__raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 6:dgnss_mode__desired_ | Offset: 67, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 67
    dgnss_mode__desired__raw = decode_int(_data_raw_, running_bit_offset, 3)
    dgnss_mode__desired_ = master_dict['DGNSS_MODE'].get(dgnss_mode__desired__raw, None)
    nmea2000Message.fields.append(NMEA2000Field('dgnss_mode__desired_', 'DGNSS Mode (desired)', None, None, dgnss_mode__desired_, dgnss_mode__desired__raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 7:position_velocity_filter | Offset: 70, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 70
    position_velocity_filter = position_velocity_filter_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('position_velocity_filter', 'Position/Velocity Filter', None, None, position_velocity_filter, position_velocity_filter_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 8:max_correction_age | Offset: 72, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    max_correction_age = max_correction_age_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('max_correction_age', 'Max Correction Age', None, None, max_correction_age, max_correction_age_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:antenna_altitude_for_2d_mode | Offset: 88, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    antenna_altitude_for_2d_mode = antenna_altitude_for_2d_mode_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('antenna_altitude_for_2d_mode', 'Antenna Altitude for 2D Mode', None, 'm', antenna_altitude_for_2d_mode, antenna_altitude_for_2d_mode_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 10:use_antenna_altitude_for_2d_mode | Offset: 104, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 104
    use_antenna_altitude_for_2d_mode_raw = decode_int(_data_raw_, running_bit_offset, 2)
    use_antenna_altitude_for_2d_mode = master_dict['YES_NO'].get(use_antenna_altitude_for_2d_mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('use_antenna_altitude_for_2d_mode', 'Use Antenna Altitude for 2D Mode', None, None, use_antenna_altitude_for_2d_mode, use_antenna_altitude_for_2d_mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 11:reserved_106 | Offset: 106, Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 106
    reserved_106 = reserved_106_raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_106', 'Reserved', None, None, reserved_106, reserved_106_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    return nmea2000Message

def encode_pgn_129538(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129538."""
    data_raw = 0
    # sv_elevation_mask | Offset: 0, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sv_elevation_mask')
    if field is None:
        raise Exception("Cant encode this message, missing 'SV Elevation Mask'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 0
    
    # pdop_mask | Offset: 16, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pdop_mask')
    if field is None:
        raise Exception("Cant encode this message, missing 'PDOP Mask'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 16
    
    # pdop_switch | Offset: 32, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pdop_switch')
    if field is None:
        raise Exception("Cant encode this message, missing 'PDOP Switch'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 32
    
    # snr_mask | Offset: 48, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'snr_mask')
    if field is None:
        raise Exception("Cant encode this message, missing 'SNR Mask'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 48
    
    # gnss_mode__desired_ | Offset: 64, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'gnss_mode__desired_')
    if field is None:
        raise Exception("Cant encode this message, missing 'GNSS Mode (desired)'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GNSS_MODE(field.value)
    data_raw |= (field_value & 0x7) << 64
    # dgnss_mode__desired_ | Offset: 67, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'dgnss_mode__desired_')
    if field is None:
        raise Exception("Cant encode this message, missing 'DGNSS Mode (desired)'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DGNSS_MODE(field.value)
    data_raw |= (field_value & 0x7) << 67
    # position_velocity_filter | Offset: 70, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'position_velocity_filter')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position/Velocity Filter'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 70
    # max_correction_age | Offset: 72, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'max_correction_age')
    if field is None:
        raise Exception("Cant encode this message, missing 'Max Correction Age'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 72
    # antenna_altitude_for_2d_mode | Offset: 88, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'antenna_altitude_for_2d_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Antenna Altitude for 2D Mode'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 88
    
    # use_antenna_altitude_for_2d_mode | Offset: 104, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'use_antenna_altitude_for_2d_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Use Antenna Altitude for 2D Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 104
    # reserved_106 | Offset: 106, Length: 6, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_106')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 106
    return data_raw


def is_fast_pgn_129539() -> bool:
    """Return True if PGN 129539 is a fast PGN."""
    return False
def decode_pgn_129539(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129539."""
    nmea2000Message = NMEA2000Message(129539, 'gnssDops', 'GNSS DOPs')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:desired_mode | Offset: 8, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    desired_mode_raw = decode_int(_data_raw_, running_bit_offset, 3)
    desired_mode = master_dict['GNSS_MODE'].get(desired_mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('desired_mode', 'Desired Mode', None, None, desired_mode, desired_mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 3:actual_mode | Offset: 11, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    actual_mode_raw = decode_int(_data_raw_, running_bit_offset, 3)
    actual_mode = master_dict['GNSS_MODE'].get(actual_mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('actual_mode', 'Actual Mode', None, None, actual_mode, actual_mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 4:reserved_14 | Offset: 14, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 14
    reserved_14 = reserved_14_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_14', 'Reserved', None, None, reserved_14, reserved_14_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 5:hdop | Offset: 16, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    hdop = hdop_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('hdop', 'HDOP', "Horizontal dilution of precision", None, hdop, hdop_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:vdop | Offset: 32, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    vdop = vdop_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('vdop', 'VDOP', "Vertical dilution of precision", None, vdop, vdop_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:tdop | Offset: 48, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    tdop = tdop_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('tdop', 'TDOP', "Time dilution of precision", None, tdop, tdop_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_129539(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129539."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # desired_mode | Offset: 8, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'desired_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Desired Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GNSS_MODE(field.value)
    data_raw |= (field_value & 0x7) << 8
    # actual_mode | Offset: 11, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'actual_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Actual Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GNSS_MODE(field.value)
    data_raw |= (field_value & 0x7) << 11
    # reserved_14 | Offset: 14, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_14')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 14
    # hdop | Offset: 16, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'hdop')
    if field is None:
        raise Exception("Cant encode this message, missing 'HDOP'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 16
    
    # vdop | Offset: 32, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'vdop')
    if field is None:
        raise Exception("Cant encode this message, missing 'VDOP'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 32
    
    # tdop | Offset: 48, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'tdop')
    if field is None:
        raise Exception("Cant encode this message, missing 'TDOP'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 48
    
    return data_raw


def is_fast_pgn_129540() -> bool:
    """Return True if PGN 129540 is a fast PGN."""
    return True
def decode_pgn_129540(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129540."""
    nmea2000Message = NMEA2000Message(129540, 'gnssSatsInView', 'GNSS Sats in View')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:range_residual_mode | Offset: 8, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    range_residual_mode_raw = decode_int(_data_raw_, running_bit_offset, 2)
    range_residual_mode = master_dict['RANGE_RESIDUAL_MODE'].get(range_residual_mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('range_residual_mode', 'Range Residual Mode', None, None, range_residual_mode, range_residual_mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:reserved_10 | Offset: 10, Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 10
    reserved_10 = reserved_10_raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_10', 'Reserved', None, None, reserved_10, reserved_10_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    # 4:sats_in_view | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    sats_in_view = sats_in_view_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sats_in_view', 'Sats in View', None, None, sats_in_view, sats_in_view_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:prn | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    prn = prn_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('prn', 'PRN', None, None, prn, prn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:elevation | Offset: 32, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    elevation = elevation_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('elevation', 'Elevation', None, 'rad', elevation, elevation_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:azimuth | Offset: 48, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    azimuth = azimuth_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('azimuth', 'Azimuth', None, 'rad', azimuth, azimuth_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:snr | Offset: 64, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    snr = snr_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('snr', 'SNR', None, 'dB', snr, snr_raw, PhysicalQuantities.SIGNAL_TO_NOISE_RATIO, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:range_residuals | Offset: 80, Length: 32, Signed: True Resolution: 1e-05, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    range_residuals = range_residuals_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-05)
    nmea2000Message.fields.append(NMEA2000Field('range_residuals', 'Range residuals', None, 'm', range_residuals, range_residuals_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 10:status | Offset: 112, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    status_raw = decode_int(_data_raw_, running_bit_offset, 4)
    status = master_dict['SATELLITE_STATUS'].get(status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('status', 'Status', None, None, status, status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 11:reserved_116 | Offset: 116, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 116
    reserved_116 = reserved_116_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_116', 'Reserved', None, None, reserved_116, reserved_116_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    return nmea2000Message

def encode_pgn_129540(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129540."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # range_residual_mode | Offset: 8, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'range_residual_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Range Residual Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_RANGE_RESIDUAL_MODE(field.value)
    data_raw |= (field_value & 0x3) << 8
    # reserved_10 | Offset: 10, Length: 6, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_10')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 10
    # sats_in_view | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sats_in_view')
    if field is None:
        raise Exception("Cant encode this message, missing 'Sats in View'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # prn | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'prn')
    if field is None:
        raise Exception("Cant encode this message, missing 'PRN'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # elevation | Offset: 32, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'elevation')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elevation'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 32
    
    # azimuth | Offset: 48, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'azimuth')
    if field is None:
        raise Exception("Cant encode this message, missing 'Azimuth'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 48
    
    # snr | Offset: 64, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'snr')
    if field is None:
        raise Exception("Cant encode this message, missing 'SNR'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 64
    
    # range_residuals | Offset: 80, Length: 32, Resolution: 1e-05, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'range_residuals')
    if field is None:
        raise Exception("Cant encode this message, missing 'Range residuals'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-05) & 0xFFFFFFFF) << 80
    
    # status | Offset: 112, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SATELLITE_STATUS(field.value)
    data_raw |= (field_value & 0xF) << 112
    # reserved_116 | Offset: 116, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_116')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 116
    return data_raw


def is_fast_pgn_129541() -> bool:
    """Return True if PGN 129541 is a fast PGN."""
    return True
def decode_pgn_129541(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129541."""
    nmea2000Message = NMEA2000Message(129541, 'gpsAlmanacData', 'GPS Almanac Data')
    running_bit_offset = 0
    # 1:prn | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    prn = prn_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('prn', 'PRN', None, None, prn, prn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:gps_week_number | Offset: 8, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    gps_week_number = gps_week_number_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('gps_week_number', 'GPS Week number', None, None, gps_week_number, gps_week_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:sv_health_bits | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    sv_health_bits = sv_health_bits_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 8))
    nmea2000Message.fields.append(NMEA2000Field('sv_health_bits', 'SV Health Bits', None, None, sv_health_bits, sv_health_bits_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 8

    # 4:eccentricity | Offset: 32, Length: 16, Signed: False Resolution: 4.76837e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    eccentricity = eccentricity_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 4.76837e-07)
    nmea2000Message.fields.append(NMEA2000Field('eccentricity', 'Eccentricity', "'e' in table 20-VI in ICD-GPS-200", 'm/m', eccentricity, eccentricity_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:almanac_reference_time | Offset: 48, Length: 8, Signed: False Resolution: 4096, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    almanac_reference_time = almanac_reference_time_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 4096)
    nmea2000Message.fields.append(NMEA2000Field('almanac_reference_time', 'Almanac Reference Time', "'t oa' in table 20-VI in ICD-GPS-200", 's', almanac_reference_time, almanac_reference_time_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:inclination_angle | Offset: 56, Length: 16, Signed: True Resolution: 1.90735e-06, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    inclination_angle = inclination_angle_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 1.90735e-06)
    nmea2000Message.fields.append(NMEA2000Field('inclination_angle', 'Inclination Angle', "'delta i' in table 20-VI in ICD-GPS-200", 'semi-circle', inclination_angle, inclination_angle_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:rate_of_right_ascension | Offset: 72, Length: 16, Signed: True Resolution: 3.63798e-12, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    rate_of_right_ascension = rate_of_right_ascension_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 3.63798e-12)
    nmea2000Message.fields.append(NMEA2000Field('rate_of_right_ascension', 'Rate of Right Ascension', "'OMEGADOT' in table 20-VI in ICD-GPS-200", 'semi-circle/s', rate_of_right_ascension, rate_of_right_ascension_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:root_of_semi_major_axis | Offset: 88, Length: 24, Signed: False Resolution: 0.000488281, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    root_of_semi_major_axis = root_of_semi_major_axis_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 0.000488281)
    nmea2000Message.fields.append(NMEA2000Field('root_of_semi_major_axis', 'Root of Semi-major Axis', "'(A)^0.5' in table 20-VI in ICD-GPS-200", 'sqrt(m)', root_of_semi_major_axis, root_of_semi_major_axis_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    # 9:argument_of_perigee | Offset: 112, Length: 24, Signed: True Resolution: 1.19209e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    argument_of_perigee = argument_of_perigee_raw = decode_number(_data_raw_, running_bit_offset, 24, True, 1.19209e-07)
    nmea2000Message.fields.append(NMEA2000Field('argument_of_perigee', 'Argument of Perigee', "'(OMEGA)0' in table 20-VI in ICD-GPS-200", 'semi-circle', argument_of_perigee, argument_of_perigee_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    # 10:longitude_of_ascension_node | Offset: 136, Length: 24, Signed: True Resolution: 1.19209e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 136
    longitude_of_ascension_node = longitude_of_ascension_node_raw = decode_number(_data_raw_, running_bit_offset, 24, True, 1.19209e-07)
    nmea2000Message.fields.append(NMEA2000Field('longitude_of_ascension_node', 'Longitude of Ascension Node', "'small-omega' in table 20-VI in ICD-GPS-200", 'semi-circle', longitude_of_ascension_node, longitude_of_ascension_node_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    # 11:mean_anomaly | Offset: 160, Length: 24, Signed: True Resolution: 1.19209e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 160
    mean_anomaly = mean_anomaly_raw = decode_number(_data_raw_, running_bit_offset, 24, True, 1.19209e-07)
    nmea2000Message.fields.append(NMEA2000Field('mean_anomaly', 'Mean Anomaly', "'M 0' in table 20-VI in ICD-GPS-200", 'semi-circle', mean_anomaly, mean_anomaly_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    # 12:clock_parameter_1 | Offset: 184, Length: 11, Signed: True Resolution: 9.53674e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 184
    clock_parameter_1 = clock_parameter_1_raw = decode_number(_data_raw_, running_bit_offset, 11, True, 9.53674e-07)
    nmea2000Message.fields.append(NMEA2000Field('clock_parameter_1', 'Clock Parameter 1', "'a f0' in table 20-VI in ICD-GPS-200", 's', clock_parameter_1, clock_parameter_1_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 11

    # 13:clock_parameter_2 | Offset: 195, Length: 11, Signed: True Resolution: 3.63798e-12, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 195
    clock_parameter_2 = clock_parameter_2_raw = decode_number(_data_raw_, running_bit_offset, 11, True, 3.63798e-12)
    nmea2000Message.fields.append(NMEA2000Field('clock_parameter_2', 'Clock Parameter 2', "'a f1' in table 20-VI in ICD-GPS-200", 's/s', clock_parameter_2, clock_parameter_2_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 11

    # 14:reserved_206 | Offset: 206, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 206
    reserved_206 = reserved_206_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_206', 'Reserved', None, None, reserved_206, reserved_206_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    return nmea2000Message

def encode_pgn_129541(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129541."""
    data_raw = 0
    # prn | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'prn')
    if field is None:
        raise Exception("Cant encode this message, missing 'PRN'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # gps_week_number | Offset: 8, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'gps_week_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'GPS Week number'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 8
    # sv_health_bits | Offset: 24, Length: 8, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'sv_health_bits')
    if field is None:
        raise Exception("Cant encode this message, missing 'SV Health Bits'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # eccentricity | Offset: 32, Length: 16, Resolution: 4.76837e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'eccentricity')
    if field is None:
        raise Exception("Cant encode this message, missing 'Eccentricity'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 4.76837e-07) & 0xFFFF) << 32
    
    # almanac_reference_time | Offset: 48, Length: 8, Resolution: 4096, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'almanac_reference_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Almanac Reference Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 4096) & 0xFF) << 48
    
    # inclination_angle | Offset: 56, Length: 16, Resolution: 1.90735e-06, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'inclination_angle')
    if field is None:
        raise Exception("Cant encode this message, missing 'Inclination Angle'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1.90735e-06) & 0xFFFF) << 56
    
    # rate_of_right_ascension | Offset: 72, Length: 16, Resolution: 3.63798e-12, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'rate_of_right_ascension')
    if field is None:
        raise Exception("Cant encode this message, missing 'Rate of Right Ascension'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 3.63798e-12) & 0xFFFF) << 72
    
    # root_of_semi_major_axis | Offset: 88, Length: 24, Resolution: 0.000488281, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'root_of_semi_major_axis')
    if field is None:
        raise Exception("Cant encode this message, missing 'Root of Semi-major Axis'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.000488281) & 0xFFFFFF) << 88
    
    # argument_of_perigee | Offset: 112, Length: 24, Resolution: 1.19209e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'argument_of_perigee')
    if field is None:
        raise Exception("Cant encode this message, missing 'Argument of Perigee'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1.19209e-07) & 0xFFFFFF) << 112
    
    # longitude_of_ascension_node | Offset: 136, Length: 24, Resolution: 1.19209e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'longitude_of_ascension_node')
    if field is None:
        raise Exception("Cant encode this message, missing 'Longitude of Ascension Node'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1.19209e-07) & 0xFFFFFF) << 136
    
    # mean_anomaly | Offset: 160, Length: 24, Resolution: 1.19209e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'mean_anomaly')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mean Anomaly'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1.19209e-07) & 0xFFFFFF) << 160
    
    # clock_parameter_1 | Offset: 184, Length: 11, Resolution: 9.53674e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'clock_parameter_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Clock Parameter 1'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 9.53674e-07) & 0x7FF) << 184
    
    # clock_parameter_2 | Offset: 195, Length: 11, Resolution: 3.63798e-12, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'clock_parameter_2')
    if field is None:
        raise Exception("Cant encode this message, missing 'Clock Parameter 2'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 3.63798e-12) & 0x7FF) << 195
    
    # reserved_206 | Offset: 206, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_206')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 206
    return data_raw


def is_fast_pgn_129542() -> bool:
    """Return True if PGN 129542 is a fast PGN."""
    return True
def decode_pgn_129542(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129542."""
    nmea2000Message = NMEA2000Message(129542, 'gnssPseudorangeNoiseStatistics', 'GNSS Pseudorange Noise Statistics')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:rms_of_position_uncertainty | Offset: 8, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    rms_of_position_uncertainty = rms_of_position_uncertainty_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('rms_of_position_uncertainty', 'RMS of Position Uncertainty', None, None, rms_of_position_uncertainty, rms_of_position_uncertainty_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:std_of_major_axis | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    std_of_major_axis = std_of_major_axis_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('std_of_major_axis', 'STD of Major axis', None, None, std_of_major_axis, std_of_major_axis_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:std_of_minor_axis | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    std_of_minor_axis = std_of_minor_axis_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('std_of_minor_axis', 'STD of Minor axis', None, None, std_of_minor_axis, std_of_minor_axis_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:orientation_of_major_axis | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    orientation_of_major_axis = orientation_of_major_axis_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('orientation_of_major_axis', 'Orientation of Major axis', None, None, orientation_of_major_axis, orientation_of_major_axis_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:std_of_lat_error | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    std_of_lat_error = std_of_lat_error_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('std_of_lat_error', 'STD of Lat Error', None, None, std_of_lat_error, std_of_lat_error_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:std_of_lon_error | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    std_of_lon_error = std_of_lon_error_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('std_of_lon_error', 'STD of Lon Error', None, None, std_of_lon_error, std_of_lon_error_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:std_of_alt_error | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    std_of_alt_error = std_of_alt_error_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('std_of_alt_error', 'STD of Alt Error', None, None, std_of_alt_error, std_of_alt_error_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_129542(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129542."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # rms_of_position_uncertainty | Offset: 8, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'rms_of_position_uncertainty')
    if field is None:
        raise Exception("Cant encode this message, missing 'RMS of Position Uncertainty'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 8
    # std_of_major_axis | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'std_of_major_axis')
    if field is None:
        raise Exception("Cant encode this message, missing 'STD of Major axis'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # std_of_minor_axis | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'std_of_minor_axis')
    if field is None:
        raise Exception("Cant encode this message, missing 'STD of Minor axis'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # orientation_of_major_axis | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'orientation_of_major_axis')
    if field is None:
        raise Exception("Cant encode this message, missing 'Orientation of Major axis'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # std_of_lat_error | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'std_of_lat_error')
    if field is None:
        raise Exception("Cant encode this message, missing 'STD of Lat Error'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # std_of_lon_error | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'std_of_lon_error')
    if field is None:
        raise Exception("Cant encode this message, missing 'STD of Lon Error'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    # std_of_alt_error | Offset: 64, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'std_of_alt_error')
    if field is None:
        raise Exception("Cant encode this message, missing 'STD of Alt Error'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 64
    return data_raw


def is_fast_pgn_129545() -> bool:
    """Return True if PGN 129545 is a fast PGN."""
    return True
def decode_pgn_129545(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129545."""
    nmea2000Message = NMEA2000Message(129545, 'gnssRaimOutput', 'GNSS RAIM Output')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:integrity_flag | Offset: 8, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    integrity_flag = integrity_flag_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('integrity_flag', 'Integrity flag', None, None, integrity_flag, integrity_flag_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 3:reserved_12 | Offset: 12, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 12
    reserved_12 = reserved_12_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_12', 'Reserved', None, None, reserved_12, reserved_12_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 4:latitude_expected_error | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    latitude_expected_error = latitude_expected_error_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('latitude_expected_error', 'Latitude expected error', None, None, latitude_expected_error, latitude_expected_error_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:longitude_expected_error | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    longitude_expected_error = longitude_expected_error_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('longitude_expected_error', 'Longitude expected error', None, None, longitude_expected_error, longitude_expected_error_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:altitude_expected_error | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    altitude_expected_error = altitude_expected_error_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('altitude_expected_error', 'Altitude expected error', None, None, altitude_expected_error, altitude_expected_error_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:sv_id_of_most_likely_failed_sat | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    sv_id_of_most_likely_failed_sat = sv_id_of_most_likely_failed_sat_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sv_id_of_most_likely_failed_sat', 'SV ID of most likely failed sat', None, None, sv_id_of_most_likely_failed_sat, sv_id_of_most_likely_failed_sat_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:probability_of_missed_detection | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    probability_of_missed_detection = probability_of_missed_detection_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('probability_of_missed_detection', 'Probability of missed detection', None, None, probability_of_missed_detection, probability_of_missed_detection_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:estimate_of_pseudorange_bias | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    estimate_of_pseudorange_bias = estimate_of_pseudorange_bias_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('estimate_of_pseudorange_bias', 'Estimate of pseudorange bias', None, None, estimate_of_pseudorange_bias, estimate_of_pseudorange_bias_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:std_deviation_of_bias | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    std_deviation_of_bias = std_deviation_of_bias_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('std_deviation_of_bias', 'Std Deviation of bias', None, None, std_deviation_of_bias, std_deviation_of_bias_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_129545(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129545."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # integrity_flag | Offset: 8, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'integrity_flag')
    if field is None:
        raise Exception("Cant encode this message, missing 'Integrity flag'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 8
    # reserved_12 | Offset: 12, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_12')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 12
    # latitude_expected_error | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'latitude_expected_error')
    if field is None:
        raise Exception("Cant encode this message, missing 'Latitude expected error'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # longitude_expected_error | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'longitude_expected_error')
    if field is None:
        raise Exception("Cant encode this message, missing 'Longitude expected error'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # altitude_expected_error | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'altitude_expected_error')
    if field is None:
        raise Exception("Cant encode this message, missing 'Altitude expected error'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # sv_id_of_most_likely_failed_sat | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sv_id_of_most_likely_failed_sat')
    if field is None:
        raise Exception("Cant encode this message, missing 'SV ID of most likely failed sat'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # probability_of_missed_detection | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'probability_of_missed_detection')
    if field is None:
        raise Exception("Cant encode this message, missing 'Probability of missed detection'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # estimate_of_pseudorange_bias | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'estimate_of_pseudorange_bias')
    if field is None:
        raise Exception("Cant encode this message, missing 'Estimate of pseudorange bias'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    # std_deviation_of_bias | Offset: 64, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'std_deviation_of_bias')
    if field is None:
        raise Exception("Cant encode this message, missing 'Std Deviation of bias'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 64
    return data_raw


def is_fast_pgn_129546() -> bool:
    """Return True if PGN 129546 is a fast PGN."""
    return False
def decode_pgn_129546(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129546."""
    nmea2000Message = NMEA2000Message(129546, 'gnssRaimSettings', 'GNSS RAIM Settings')
    running_bit_offset = 0
    # 1:radial_position_error_maximum_threshold | Offset: 0, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    radial_position_error_maximum_threshold = radial_position_error_maximum_threshold_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('radial_position_error_maximum_threshold', 'Radial Position Error Maximum Threshold', None, 'm', radial_position_error_maximum_threshold, radial_position_error_maximum_threshold_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:probability_of_false_alarm | Offset: 16, Length: 8, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    probability_of_false_alarm = probability_of_false_alarm_raw = decode_number(_data_raw_, running_bit_offset, 8, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('probability_of_false_alarm', 'Probability of False Alarm', None, '%', probability_of_false_alarm, probability_of_false_alarm_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:probability_of_missed_detection | Offset: 24, Length: 8, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    probability_of_missed_detection = probability_of_missed_detection_raw = decode_number(_data_raw_, running_bit_offset, 8, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('probability_of_missed_detection', 'Probability of Missed Detection', None, '%', probability_of_missed_detection, probability_of_missed_detection_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:pseudorange_residual_filtering_time_constant | Offset: 32, Length: 16, Signed: False Resolution: 1, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    pseudorange_residual_filtering_time_constant_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    pseudorange_residual_filtering_time_constant = decode_time(pseudorange_residual_filtering_time_constant_raw)
    nmea2000Message.fields.append(NMEA2000Field('pseudorange_residual_filtering_time_constant', 'Pseudorange Residual Filtering Time Constant', None, 's', pseudorange_residual_filtering_time_constant, pseudorange_residual_filtering_time_constant_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    # 5:reserved_48 | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    reserved_48 = reserved_48_raw = decode_int(_data_raw_, running_bit_offset, 16)
    nmea2000Message.fields.append(NMEA2000Field('reserved_48', 'Reserved', None, None, reserved_48, reserved_48_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_129546(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129546."""
    data_raw = 0
    # radial_position_error_maximum_threshold | Offset: 0, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'radial_position_error_maximum_threshold')
    if field is None:
        raise Exception("Cant encode this message, missing 'Radial Position Error Maximum Threshold'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 0
    
    # probability_of_false_alarm | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'probability_of_false_alarm')
    if field is None:
        raise Exception("Cant encode this message, missing 'Probability of False Alarm'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # probability_of_missed_detection | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'probability_of_missed_detection')
    if field is None:
        raise Exception("Cant encode this message, missing 'Probability of Missed Detection'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # pseudorange_residual_filtering_time_constant | Offset: 32, Length: 16, Resolution: 1, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'pseudorange_residual_filtering_time_constant')
    if field is None:
        raise Exception("Cant encode this message, missing 'Pseudorange Residual Filtering Time Constant'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 32
    # reserved_48 | Offset: 48, Length: 16, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_48')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    return data_raw


def is_fast_pgn_129547() -> bool:
    """Return True if PGN 129547 is a fast PGN."""
    return True
def decode_pgn_129547(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129547."""
    nmea2000Message = NMEA2000Message(129547, 'gnssPseudorangeErrorStatistics', 'GNSS Pseudorange Error Statistics')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:rms_std_dev_of_range_inputs | Offset: 8, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    rms_std_dev_of_range_inputs = rms_std_dev_of_range_inputs_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('rms_std_dev_of_range_inputs', 'RMS Std Dev of Range Inputs', None, 'm', rms_std_dev_of_range_inputs, rms_std_dev_of_range_inputs_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:std_dev_of_major_error_ellipse | Offset: 24, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    std_dev_of_major_error_ellipse = std_dev_of_major_error_ellipse_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('std_dev_of_major_error_ellipse', 'Std Dev of Major error ellipse', None, 'm', std_dev_of_major_error_ellipse, std_dev_of_major_error_ellipse_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:std_dev_of_minor_error_ellipse | Offset: 40, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    std_dev_of_minor_error_ellipse = std_dev_of_minor_error_ellipse_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('std_dev_of_minor_error_ellipse', 'Std Dev of Minor error ellipse', None, 'm', std_dev_of_minor_error_ellipse, std_dev_of_minor_error_ellipse_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:orientation_of_error_ellipse | Offset: 56, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    orientation_of_error_ellipse = orientation_of_error_ellipse_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('orientation_of_error_ellipse', 'Orientation of error ellipse', None, 'rad', orientation_of_error_ellipse, orientation_of_error_ellipse_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:std_dev_lat_error | Offset: 72, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    std_dev_lat_error = std_dev_lat_error_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('std_dev_lat_error', 'Std Dev Lat Error', None, 'm', std_dev_lat_error, std_dev_lat_error_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:std_dev_lon_error | Offset: 88, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    std_dev_lon_error = std_dev_lon_error_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('std_dev_lon_error', 'Std Dev Lon Error', None, 'm', std_dev_lon_error, std_dev_lon_error_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:std_dev_alt_error | Offset: 104, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 104
    std_dev_alt_error = std_dev_alt_error_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('std_dev_alt_error', 'Std Dev Alt Error', None, 'm', std_dev_alt_error, std_dev_alt_error_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_129547(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129547."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # rms_std_dev_of_range_inputs | Offset: 8, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'rms_std_dev_of_range_inputs')
    if field is None:
        raise Exception("Cant encode this message, missing 'RMS Std Dev of Range Inputs'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 8
    
    # std_dev_of_major_error_ellipse | Offset: 24, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'std_dev_of_major_error_ellipse')
    if field is None:
        raise Exception("Cant encode this message, missing 'Std Dev of Major error ellipse'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 24
    
    # std_dev_of_minor_error_ellipse | Offset: 40, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'std_dev_of_minor_error_ellipse')
    if field is None:
        raise Exception("Cant encode this message, missing 'Std Dev of Minor error ellipse'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 40
    
    # orientation_of_error_ellipse | Offset: 56, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'orientation_of_error_ellipse')
    if field is None:
        raise Exception("Cant encode this message, missing 'Orientation of error ellipse'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 56
    
    # std_dev_lat_error | Offset: 72, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'std_dev_lat_error')
    if field is None:
        raise Exception("Cant encode this message, missing 'Std Dev Lat Error'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 72
    
    # std_dev_lon_error | Offset: 88, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'std_dev_lon_error')
    if field is None:
        raise Exception("Cant encode this message, missing 'Std Dev Lon Error'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 88
    
    # std_dev_alt_error | Offset: 104, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'std_dev_alt_error')
    if field is None:
        raise Exception("Cant encode this message, missing 'Std Dev Alt Error'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 104
    
    return data_raw


def is_fast_pgn_129549() -> bool:
    """Return True if PGN 129549 is a fast PGN."""
    return True
def decode_pgn_129549(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129549."""
    nmea2000Message = NMEA2000Message(129549, 'dgnssCorrections', 'DGNSS Corrections')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:reference_station_id | Offset: 8, Length: 12, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    reference_station_id = reference_station_id_raw = decode_number(_data_raw_, running_bit_offset, 12, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('reference_station_id', 'Reference Station ID', None, None, reference_station_id, reference_station_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 12

    # 3:reference_station_type | Offset: 20, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 20
    reference_station_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    reference_station_type = master_dict['GNS'].get(reference_station_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('reference_station_type', 'Reference Station Type', None, None, reference_station_type, reference_station_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 4:time_of_corrections | Offset: 24, Length: 16, Signed: False Resolution: 0.001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    time_of_corrections_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.001)
    time_of_corrections = decode_time(time_of_corrections_raw)
    nmea2000Message.fields.append(NMEA2000Field('time_of_corrections', 'Time of corrections', None, 's', time_of_corrections, time_of_corrections_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    # 5:station_health | Offset: 40, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    station_health_raw = decode_int(_data_raw_, running_bit_offset, 4)
    station_health = master_dict['STATION_HEALTH'].get(station_health_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('station_health', 'Station Health', None, None, station_health, station_health_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 6:reserved_44 | Offset: 44, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 44
    reserved_44 = reserved_44_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_44', 'Reserved', None, None, reserved_44, reserved_44_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 7:satellite_id | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    satellite_id = satellite_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('satellite_id', 'Satellite ID', None, None, satellite_id, satellite_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:prc | Offset: 56, Length: 32, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    prc = prc_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('prc', 'PRC', None, 'm', prc, prc_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 9:rrc | Offset: 88, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    rrc = rrc_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('rrc', 'RRC', None, 'm/s', rrc, rrc_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 10:udre | Offset: 104, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 104
    udre = udre_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('udre', 'UDRE', None, 'm', udre, udre_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:iod | Offset: 120, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    iod = iod_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('iod', 'IOD', None, None, iod, iod_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_129549(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129549."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # reference_station_id | Offset: 8, Length: 12, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'reference_station_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reference Station ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFF) << 8
    # reference_station_type | Offset: 20, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'reference_station_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reference Station Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GNS(field.value)
    data_raw |= (field_value & 0xF) << 20
    # time_of_corrections | Offset: 24, Length: 16, Resolution: 0.001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'time_of_corrections')
    if field is None:
        raise Exception("Cant encode this message, missing 'Time of corrections'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFF) << 24
    
    # station_health | Offset: 40, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'station_health')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station Health'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_STATION_HEALTH(field.value)
    data_raw |= (field_value & 0xF) << 40
    # reserved_44 | Offset: 44, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_44')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 44
    # satellite_id | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'satellite_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Satellite ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # prc | Offset: 56, Length: 32, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'prc')
    if field is None:
        raise Exception("Cant encode this message, missing 'PRC'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFFFFFF) << 56
    
    # rrc | Offset: 88, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'rrc')
    if field is None:
        raise Exception("Cant encode this message, missing 'RRC'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 88
    
    # udre | Offset: 104, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'udre')
    if field is None:
        raise Exception("Cant encode this message, missing 'UDRE'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 104
    
    # iod | Offset: 120, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'iod')
    if field is None:
        raise Exception("Cant encode this message, missing 'IOD'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 120
    return data_raw


def is_fast_pgn_129550() -> bool:
    """Return True if PGN 129550 is a fast PGN."""
    return False
def decode_pgn_129550(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129550."""
    nmea2000Message = NMEA2000Message(129550, 'gnssDifferentialCorrectionReceiverInterface', 'GNSS Differential Correction Receiver Interface')
    running_bit_offset = 0
    # 1:channel | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    channel = channel_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('channel', 'Channel', None, None, channel, channel_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:frequency | Offset: 8, Length: 32, Signed: False Resolution: 10, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    frequency = frequency_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 10)
    nmea2000Message.fields.append(NMEA2000Field('frequency', 'Frequency', None, 'Hz', frequency, frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 3:serial_interface_bit_rate | Offset: 40, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    serial_interface_bit_rate_raw = decode_int(_data_raw_, running_bit_offset, 5)
    serial_interface_bit_rate = master_dict['SERIAL_BIT_RATE'].get(serial_interface_bit_rate_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('serial_interface_bit_rate', 'Serial Interface Bit Rate', None, None, serial_interface_bit_rate, serial_interface_bit_rate_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 4:serial_interface_detection_mode | Offset: 45, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 45
    serial_interface_detection_mode_raw = decode_int(_data_raw_, running_bit_offset, 3)
    serial_interface_detection_mode = master_dict['SERIAL_DETECTION_MODE'].get(serial_interface_detection_mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('serial_interface_detection_mode', 'Serial Interface Detection Mode', None, None, serial_interface_detection_mode, serial_interface_detection_mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 5:differential_source | Offset: 48, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    differential_source_raw = decode_int(_data_raw_, running_bit_offset, 4)
    differential_source = master_dict['DIFFERENTIAL_SOURCE'].get(differential_source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('differential_source', 'Differential Source', None, None, differential_source, differential_source_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 6:differential_operation_mode | Offset: 52, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 52
    differential_operation_mode_raw = decode_int(_data_raw_, running_bit_offset, 4)
    differential_operation_mode = master_dict['DIFFERENTIAL_MODE'].get(differential_operation_mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('differential_operation_mode', 'Differential Operation Mode', None, None, differential_operation_mode, differential_operation_mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 7:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_129550(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129550."""
    data_raw = 0
    # channel | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'channel')
    if field is None:
        raise Exception("Cant encode this message, missing 'Channel'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # frequency | Offset: 8, Length: 32, Resolution: 10, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'Frequency'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 10) & 0xFFFFFFFF) << 8
    
    # serial_interface_bit_rate | Offset: 40, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'serial_interface_bit_rate')
    if field is None:
        raise Exception("Cant encode this message, missing 'Serial Interface Bit Rate'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SERIAL_BIT_RATE(field.value)
    data_raw |= (field_value & 0x1F) << 40
    # serial_interface_detection_mode | Offset: 45, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'serial_interface_detection_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Serial Interface Detection Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SERIAL_DETECTION_MODE(field.value)
    data_raw |= (field_value & 0x7) << 45
    # differential_source | Offset: 48, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'differential_source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Differential Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DIFFERENTIAL_SOURCE(field.value)
    data_raw |= (field_value & 0xF) << 48
    # differential_operation_mode | Offset: 52, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'differential_operation_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Differential Operation Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DIFFERENTIAL_MODE(field.value)
    data_raw |= (field_value & 0xF) << 52
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_129551() -> bool:
    """Return True if PGN 129551 is a fast PGN."""
    return True
def decode_pgn_129551(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129551."""
    nmea2000Message = NMEA2000Message(129551, 'gnssDifferentialCorrectionReceiverSignal', 'GNSS Differential Correction Receiver Signal')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:channel | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    channel = channel_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('channel', 'Channel', None, None, channel, channel_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:signal_strength | Offset: 16, Length: 32, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    signal_strength = signal_strength_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('signal_strength', 'Signal Strength', "Signal strength in dB relative to 1 uV/m", 'dB', signal_strength, signal_strength_raw, PhysicalQuantities.SIGNAL_STRENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 4:signal_snr | Offset: 48, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    signal_snr = signal_snr_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('signal_snr', 'Signal SNR', None, 'dB', signal_snr, signal_snr_raw, PhysicalQuantities.SIGNAL_TO_NOISE_RATIO, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:frequency | Offset: 64, Length: 32, Signed: False Resolution: 10, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    frequency = frequency_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 10)
    nmea2000Message.fields.append(NMEA2000Field('frequency', 'Frequency', None, 'Hz', frequency, frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:station_type | Offset: 96, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 96
    station_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    station_type = master_dict['GNS'].get(station_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('station_type', 'Station Type', None, None, station_type, station_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 7:reference_station_id | Offset: 100, Length: 12, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 100
    reference_station_id = reference_station_id_raw = decode_number(_data_raw_, running_bit_offset, 12, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('reference_station_id', 'Reference Station ID', None, None, reference_station_id, reference_station_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 12

    # 8:differential_signal_bit_rate | Offset: 112, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    differential_signal_bit_rate_raw = decode_int(_data_raw_, running_bit_offset, 5)
    differential_signal_bit_rate = master_dict['SERIAL_BIT_RATE'].get(differential_signal_bit_rate_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('differential_signal_bit_rate', 'Differential Signal Bit Rate', None, None, differential_signal_bit_rate, differential_signal_bit_rate_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 9:differential_signal_detection_mode | Offset: 117, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 117
    differential_signal_detection_mode_raw = decode_int(_data_raw_, running_bit_offset, 3)
    differential_signal_detection_mode = master_dict['SERIAL_DETECTION_MODE'].get(differential_signal_detection_mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('differential_signal_detection_mode', 'Differential Signal Detection Mode', None, None, differential_signal_detection_mode, differential_signal_detection_mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 10:used_as_correction_source | Offset: 120, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    used_as_correction_source_raw = decode_int(_data_raw_, running_bit_offset, 2)
    used_as_correction_source = master_dict['YES_NO'].get(used_as_correction_source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('used_as_correction_source', 'Used as Correction Source', None, None, used_as_correction_source, used_as_correction_source_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 11:reserved_122 | Offset: 122, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 122
    reserved_122 = reserved_122_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_122', 'Reserved', None, None, reserved_122, reserved_122_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 12:differential_source | Offset: 124, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 124
    differential_source_raw = decode_int(_data_raw_, running_bit_offset, 4)
    differential_source = master_dict['DIFFERENTIAL_SOURCE'].get(differential_source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('differential_source', 'Differential Source', None, None, differential_source, differential_source_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 13:time_since_last_sat_differential_sync | Offset: 128, Length: 16, Signed: False Resolution: 0.01, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    time_since_last_sat_differential_sync_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    time_since_last_sat_differential_sync = decode_time(time_since_last_sat_differential_sync_raw)
    nmea2000Message.fields.append(NMEA2000Field('time_since_last_sat_differential_sync', 'Time since Last Sat Differential Sync', "Age of differential corrections", 's', time_since_last_sat_differential_sync, time_since_last_sat_differential_sync_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    # 14:satellite_service_id_no_ | Offset: 144, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    satellite_service_id_no_ = satellite_service_id_no__raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('satellite_service_id_no_', 'Satellite Service ID No.', None, None, satellite_service_id_no_, satellite_service_id_no__raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_129551(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129551."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # channel | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'channel')
    if field is None:
        raise Exception("Cant encode this message, missing 'Channel'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # signal_strength | Offset: 16, Length: 32, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'signal_strength')
    if field is None:
        raise Exception("Cant encode this message, missing 'Signal Strength'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFFFFFF) << 16
    
    # signal_snr | Offset: 48, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'signal_snr')
    if field is None:
        raise Exception("Cant encode this message, missing 'Signal SNR'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 48
    
    # frequency | Offset: 64, Length: 32, Resolution: 10, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'Frequency'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 10) & 0xFFFFFFFF) << 64
    
    # station_type | Offset: 96, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'station_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_GNS(field.value)
    data_raw |= (field_value & 0xF) << 96
    # reference_station_id | Offset: 100, Length: 12, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'reference_station_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reference Station ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFF) << 100
    # differential_signal_bit_rate | Offset: 112, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'differential_signal_bit_rate')
    if field is None:
        raise Exception("Cant encode this message, missing 'Differential Signal Bit Rate'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SERIAL_BIT_RATE(field.value)
    data_raw |= (field_value & 0x1F) << 112
    # differential_signal_detection_mode | Offset: 117, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'differential_signal_detection_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Differential Signal Detection Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SERIAL_DETECTION_MODE(field.value)
    data_raw |= (field_value & 0x7) << 117
    # used_as_correction_source | Offset: 120, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'used_as_correction_source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Used as Correction Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 120
    # reserved_122 | Offset: 122, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_122')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 122
    # differential_source | Offset: 124, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'differential_source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Differential Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DIFFERENTIAL_SOURCE(field.value)
    data_raw |= (field_value & 0xF) << 124
    # time_since_last_sat_differential_sync | Offset: 128, Length: 16, Resolution: 0.01, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'time_since_last_sat_differential_sync')
    if field is None:
        raise Exception("Cant encode this message, missing 'Time since Last Sat Differential Sync'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 128
    
    # satellite_service_id_no_ | Offset: 144, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'satellite_service_id_no_')
    if field is None:
        raise Exception("Cant encode this message, missing 'Satellite Service ID No.'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 144
    return data_raw


def is_fast_pgn_129556() -> bool:
    """Return True if PGN 129556 is a fast PGN."""
    return True
def decode_pgn_129556(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129556."""
    nmea2000Message = NMEA2000Message(129556, 'glonassAlmanacData', 'GLONASS Almanac Data')
    running_bit_offset = 0
    # 1:prn | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    prn = prn_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('prn', 'PRN', "Satellite ID number", None, prn, prn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:na | Offset: 8, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    na = na_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('na', 'NA', "Calendar day count within the four year period beginning with the previous leap year", None, na, na_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:reserved_24 | Offset: 24, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    reserved_24 = reserved_24_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_24', 'Reserved', None, None, reserved_24, reserved_24_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 4:cna | Offset: 26, Length: 1, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 26
    cna = cna_raw = decode_number(_data_raw_, running_bit_offset, 1, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('cna', 'CnA', "Generalized health of the satellite", None, cna, cna_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 1

    # 5:hna | Offset: 27, Length: 5, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 27
    hna = hna_raw = decode_number(_data_raw_, running_bit_offset, 5, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('hna', 'HnA', "Carrier frequency number", None, hna, hna_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 5

    # 6:_epsilon_na | Offset: 32, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    _epsilon_na = _epsilon_na_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('_epsilon_na', '(epsilon)nA', "Eccentricity", None, _epsilon_na, _epsilon_na_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:_deltatna_dot | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    _deltatna_dot = _deltatna_dot_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('_deltatna_dot', '(deltaTnA)DOT', "Rate of change of the draconitic circling time", None, _deltatna_dot, _deltatna_dot_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:_omega_na | Offset: 56, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    _omega_na = _omega_na_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('_omega_na', '(omega)nA', "Rate of change of the draconitic circling time", None, _omega_na, _omega_na_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:_delta_tna | Offset: 72, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    _delta_tna = _delta_tna_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('_delta_tna', '(delta)TnA', "Correction to the average value of the draconitic circling time", None, _delta_tna, _delta_tna_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    # 10:tna | Offset: 96, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 96
    tna = tna_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('tna', 'tnA', "Time of the ascension node", None, tna, tna_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    # 11:_lambda_na | Offset: 120, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    _lambda_na = _lambda_na_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('_lambda_na', '(lambda)nA', "Greenwich longitude of the ascension node", None, _lambda_na, _lambda_na_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    # 12:_delta_ina | Offset: 144, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    _delta_ina = _delta_ina_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('_delta_ina', '(delta)inA', "Correction to the average value of the inclination angle", None, _delta_ina, _delta_ina_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    # 13:_tau_ca | Offset: 168, Length: 28, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 168
    _tau_ca = _tau_ca_raw = decode_number(_data_raw_, running_bit_offset, 28, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('_tau_ca', '(tau)cA', "System time scale correction", None, _tau_ca, _tau_ca_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 28

    # 14:_tau_na | Offset: 196, Length: 12, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 196
    _tau_na = _tau_na_raw = decode_number(_data_raw_, running_bit_offset, 12, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('_tau_na', '(tau)nA', "Course value of the time scale shift", None, _tau_na, _tau_na_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 12

    return nmea2000Message

def encode_pgn_129556(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129556."""
    data_raw = 0
    # prn | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'prn')
    if field is None:
        raise Exception("Cant encode this message, missing 'PRN'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # na | Offset: 8, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'na')
    if field is None:
        raise Exception("Cant encode this message, missing 'NA'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 8
    # reserved_24 | Offset: 24, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_24')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 24
    # cna | Offset: 26, Length: 1, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'cna')
    if field is None:
        raise Exception("Cant encode this message, missing 'CnA'")
    field_value = field.value
    data_raw |= (field_value & 0x1) << 26
    # hna | Offset: 27, Length: 5, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'hna')
    if field is None:
        raise Exception("Cant encode this message, missing 'HnA'")
    field_value = field.value
    data_raw |= (field_value & 0x1F) << 27
    # _epsilon_na | Offset: 32, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == '_epsilon_na')
    if field is None:
        raise Exception("Cant encode this message, missing '(epsilon)nA'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 32
    # _deltatna_dot | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == '_deltatna_dot')
    if field is None:
        raise Exception("Cant encode this message, missing '(deltaTnA)DOT'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # _omega_na | Offset: 56, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == '_omega_na')
    if field is None:
        raise Exception("Cant encode this message, missing '(omega)nA'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 56
    # _delta_tna | Offset: 72, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == '_delta_tna')
    if field is None:
        raise Exception("Cant encode this message, missing '(delta)TnA'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 72
    # tna | Offset: 96, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'tna')
    if field is None:
        raise Exception("Cant encode this message, missing 'tnA'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 96
    # _lambda_na | Offset: 120, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == '_lambda_na')
    if field is None:
        raise Exception("Cant encode this message, missing '(lambda)nA'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 120
    # _delta_ina | Offset: 144, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == '_delta_ina')
    if field is None:
        raise Exception("Cant encode this message, missing '(delta)inA'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 144
    # _tau_ca | Offset: 168, Length: 28, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == '_tau_ca')
    if field is None:
        raise Exception("Cant encode this message, missing '(tau)cA'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFF) << 168
    # _tau_na | Offset: 196, Length: 12, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == '_tau_na')
    if field is None:
        raise Exception("Cant encode this message, missing '(tau)nA'")
    field_value = field.value
    data_raw |= (field_value & 0xFFF) << 196
    return data_raw


def is_fast_pgn_129792() -> bool:
    """Return True if PGN 129792 is a fast PGN."""
    return True
def decode_pgn_129792(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129792."""
    nmea2000Message = NMEA2000Message(129792, 'aisDgnssBroadcastBinaryMessage', 'AIS DGNSS Broadcast Binary Message')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator = repeat_indicator_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 3:source_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    source_id = source_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('source_id', 'Source ID', None, None, source_id, source_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 4:reserved_40 | Offset: 40, Length: 1, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    reserved_40 = reserved_40_raw = decode_int(_data_raw_, running_bit_offset, 1)
    nmea2000Message.fields.append(NMEA2000Field('reserved_40', 'Reserved', None, None, reserved_40, reserved_40_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 1

    # 5:ais_transceiver_information | Offset: 41, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 41
    ais_transceiver_information_raw = decode_int(_data_raw_, running_bit_offset, 5)
    ais_transceiver_information = master_dict['AIS_TRANSCEIVER'].get(ais_transceiver_information_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_transceiver_information', 'AIS Transceiver information', None, None, ais_transceiver_information, ais_transceiver_information_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 6:spare | Offset: 46, Length: 2, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 46
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 2

    # 7:longitude | Offset: 48, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    longitude = longitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('longitude', 'Longitude', None, 'deg', longitude, longitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 8:latitude | Offset: 80, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    latitude = latitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('latitude', 'Latitude', None, 'deg', latitude, latitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 9:reserved_112 | Offset: 112, Length: 3, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    reserved_112 = reserved_112_raw = decode_int(_data_raw_, running_bit_offset, 3)
    nmea2000Message.fields.append(NMEA2000Field('reserved_112', 'Reserved', None, None, reserved_112, reserved_112_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 3

    # 10:spare | Offset: 115, Length: 5, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 115
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 5)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 5

    # 11:number_of_bits_in_binary_data_field | Offset: 120, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    number_of_bits_in_binary_data_field = number_of_bits_in_binary_data_field_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_bits_in_binary_data_field', 'Number of Bits in Binary Data Field', None, None, number_of_bits_in_binary_data_field, number_of_bits_in_binary_data_field_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 12:binary_data | Offset: , Length: , Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    binary_data = binary_data_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, number_of_bits_in_binary_data_field))
    nmea2000Message.fields.append(NMEA2000Field('binary_data', 'Binary Data', None, None, binary_data, binary_data_raw, None, FieldTypes.BINARY, False))
    

    return nmea2000Message

def encode_pgn_129792(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129792."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 6
    # source_id | Offset: 8, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'source_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # reserved_40 | Offset: 40, Length: 1, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_40')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1) << 40
    # ais_transceiver_information | Offset: 41, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_transceiver_information')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS Transceiver information'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TRANSCEIVER(field.value)
    data_raw |= (field_value & 0x1F) << 41
    # spare | Offset: 46, Length: 2, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 46
    # longitude | Offset: 48, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'longitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Longitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 48
    
    # latitude | Offset: 80, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'latitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Latitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 80
    
    # reserved_112 | Offset: 112, Length: 3, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_112')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x7) << 112
    # spare | Offset: 115, Length: 5, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0x1F) << 115
    # number_of_bits_in_binary_data_field | Offset: 120, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_bits_in_binary_data_field')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of Bits in Binary Data Field'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 120
    raise Exception ("PGN 129792 not supporting encoding for now as Binary Data is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_129793() -> bool:
    """Return True if PGN 129793 is a fast PGN."""
    return True
def decode_pgn_129793(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129793."""
    nmea2000Message = NMEA2000Message(129793, 'aisUtcAndDateReport', 'AIS UTC and Date Report')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:user_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    user_id = user_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('user_id', 'User ID', None, None, user_id, user_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 4:longitude | Offset: 40, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    longitude = longitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('longitude', 'Longitude', None, 'deg', longitude, longitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 5:latitude | Offset: 72, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    latitude = latitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('latitude', 'Latitude', None, 'deg', latitude, latitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:position_accuracy | Offset: 104, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 104
    position_accuracy_raw = decode_int(_data_raw_, running_bit_offset, 1)
    position_accuracy = master_dict['POSITION_ACCURACY'].get(position_accuracy_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('position_accuracy', 'Position Accuracy', None, None, position_accuracy, position_accuracy_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 7:raim | Offset: 105, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 105
    raim_raw = decode_int(_data_raw_, running_bit_offset, 1)
    raim = master_dict['RAIM_FLAG'].get(raim_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('raim', 'RAIM', None, None, raim, raim_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 8:reserved_106 | Offset: 106, Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 106
    reserved_106 = reserved_106_raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_106', 'Reserved', None, None, reserved_106, reserved_106_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    # 9:position_time | Offset: 112, Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    position_time_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    position_time = decode_time(position_time_raw)
    nmea2000Message.fields.append(NMEA2000Field('position_time', 'Position Time', "Seconds since midnight", 's', position_time, position_time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 10:communication_state | Offset: 144, Length: 19, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    communication_state = communication_state_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 19))
    nmea2000Message.fields.append(NMEA2000Field('communication_state', 'Communication State', "Information used by the TDMA slot allocation algorithm and synchronization information", None, communication_state, communication_state_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 19

    # 11:ais_transceiver_information | Offset: 163, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 163
    ais_transceiver_information_raw = decode_int(_data_raw_, running_bit_offset, 5)
    ais_transceiver_information = master_dict['AIS_TRANSCEIVER'].get(ais_transceiver_information_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_transceiver_information', 'AIS Transceiver information', None, None, ais_transceiver_information, ais_transceiver_information_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 12:position_date | Offset: 168, Length: 16, Signed: False Resolution: 1, Field Type: DATE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 168
    position_date_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    position_date = decode_date(position_date_raw)
    nmea2000Message.fields.append(NMEA2000Field('position_date', 'Position Date', None, 'd', position_date, position_date_raw, PhysicalQuantities.DATE, FieldTypes.DATE, False))
    running_bit_offset += 16

    # 13:reserved_184 | Offset: 184, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 184
    reserved_184 = reserved_184_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_184', 'Reserved', None, None, reserved_184, reserved_184_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 14:gnss_type | Offset: 188, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 188
    gnss_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    gnss_type = master_dict['POSITION_FIX_DEVICE'].get(gnss_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('gnss_type', 'GNSS type', None, None, gnss_type, gnss_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 15:spare | Offset: 192, Length: 8, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 192
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_129793(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129793."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 6
    # user_id | Offset: 8, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'user_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'User ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # longitude | Offset: 40, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'longitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Longitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 40
    
    # latitude | Offset: 72, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'latitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Latitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 72
    
    # position_accuracy | Offset: 104, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'position_accuracy')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position Accuracy'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_POSITION_ACCURACY(field.value)
    data_raw |= (field_value & 0x1) << 104
    # raim | Offset: 105, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'raim')
    if field is None:
        raise Exception("Cant encode this message, missing 'RAIM'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_RAIM_FLAG(field.value)
    data_raw |= (field_value & 0x1) << 105
    # reserved_106 | Offset: 106, Length: 6, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_106')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 106
    # position_time | Offset: 112, Length: 32, Resolution: 0.0001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'position_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFFFFFF) << 112
    
    # communication_state | Offset: 144, Length: 19, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'communication_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'Communication State'")
    field_value = field.value
    data_raw |= (field_value & 0x7FFFF) << 144
    # ais_transceiver_information | Offset: 163, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_transceiver_information')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS Transceiver information'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TRANSCEIVER(field.value)
    data_raw |= (field_value & 0x1F) << 163
    # position_date | Offset: 168, Length: 16, Resolution: 1, Field Type: DATE
    field = next(f for f in nmea2000Message.fields if f.id == 'position_date')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position Date'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 168
    # reserved_184 | Offset: 184, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_184')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 184
    # gnss_type | Offset: 188, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'gnss_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'GNSS type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_POSITION_FIX_DEVICE(field.value)
    data_raw |= (field_value & 0xF) << 188
    # spare | Offset: 192, Length: 8, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 192
    return data_raw


def is_fast_pgn_129794() -> bool:
    """Return True if PGN 129794 is a fast PGN."""
    return True
def decode_pgn_129794(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129794."""
    nmea2000Message = NMEA2000Message(129794, 'aisClassAStaticAndVoyageRelatedData', 'AIS Class A Static and Voyage Related Data')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:user_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    user_id = user_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('user_id', 'User ID', None, None, user_id, user_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 4:imo_number | Offset: 40, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    imo_number = imo_number_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('imo_number', 'IMO number', None, None, imo_number, imo_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 5:callsign | Offset: 72, Length: 56, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    callsign = callsign_raw = decode_string_fix(_data_raw_, running_bit_offset, 56)
    nmea2000Message.fields.append(NMEA2000Field('callsign', 'Callsign', None, None, callsign, callsign_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 56

    # 6:name | Offset: 128, Length: 160, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    name = name_raw = decode_string_fix(_data_raw_, running_bit_offset, 160)
    nmea2000Message.fields.append(NMEA2000Field('name', 'Name', None, None, name, name_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 160

    # 7:type_of_ship | Offset: 288, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 288
    type_of_ship_raw = decode_int(_data_raw_, running_bit_offset, 8)
    type_of_ship = master_dict['SHIP_TYPE'].get(type_of_ship_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('type_of_ship', 'Type of ship', None, None, type_of_ship, type_of_ship_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 8:length | Offset: 296, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 296
    length = length_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('length', 'Length', None, 'm', length, length_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:beam | Offset: 312, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 312
    beam = beam_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('beam', 'Beam', None, 'm', beam, beam_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 10:position_reference_from_starboard | Offset: 328, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 328
    position_reference_from_starboard = position_reference_from_starboard_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('position_reference_from_starboard', 'Position reference from Starboard', None, 'm', position_reference_from_starboard, position_reference_from_starboard_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:position_reference_from_bow | Offset: 344, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 344
    position_reference_from_bow = position_reference_from_bow_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('position_reference_from_bow', 'Position reference from Bow', None, 'm', position_reference_from_bow, position_reference_from_bow_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 12:eta_date | Offset: 360, Length: 16, Signed: False Resolution: 1, Field Type: DATE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 360
    eta_date_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    eta_date = decode_date(eta_date_raw)
    nmea2000Message.fields.append(NMEA2000Field('eta_date', 'ETA Date', None, 'd', eta_date, eta_date_raw, PhysicalQuantities.DATE, FieldTypes.DATE, False))
    running_bit_offset += 16

    # 13:eta_time | Offset: 376, Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 376
    eta_time_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    eta_time = decode_time(eta_time_raw)
    nmea2000Message.fields.append(NMEA2000Field('eta_time', 'ETA Time', "Seconds since midnight", 's', eta_time, eta_time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 14:draft | Offset: 408, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 408
    draft = draft_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('draft', 'Draft', None, 'm', draft, draft_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 15:destination | Offset: 424, Length: 160, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 424
    destination = destination_raw = decode_string_fix(_data_raw_, running_bit_offset, 160)
    nmea2000Message.fields.append(NMEA2000Field('destination', 'Destination', None, None, destination, destination_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 160

    # 16:ais_version_indicator | Offset: 584, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 584
    ais_version_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    ais_version_indicator = master_dict['AIS_VERSION'].get(ais_version_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_version_indicator', 'AIS version indicator', None, None, ais_version_indicator, ais_version_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 17:gnss_type | Offset: 586, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 586
    gnss_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    gnss_type = master_dict['POSITION_FIX_DEVICE'].get(gnss_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('gnss_type', 'GNSS type', None, None, gnss_type, gnss_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 18:dte | Offset: 590, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 590
    dte_raw = decode_int(_data_raw_, running_bit_offset, 1)
    dte = master_dict['AVAILABLE'].get(dte_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('dte', 'DTE', None, None, dte, dte_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 19:reserved_591 | Offset: 591, Length: 1, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 591
    reserved_591 = reserved_591_raw = decode_int(_data_raw_, running_bit_offset, 1)
    nmea2000Message.fields.append(NMEA2000Field('reserved_591', 'Reserved', None, None, reserved_591, reserved_591_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 1

    # 20:ais_transceiver_information | Offset: 592, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 592
    ais_transceiver_information_raw = decode_int(_data_raw_, running_bit_offset, 5)
    ais_transceiver_information = master_dict['AIS_TRANSCEIVER'].get(ais_transceiver_information_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_transceiver_information', 'AIS Transceiver information', None, None, ais_transceiver_information, ais_transceiver_information_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 21:reserved_597 | Offset: 597, Length: 3, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 597
    reserved_597 = reserved_597_raw = decode_int(_data_raw_, running_bit_offset, 3)
    nmea2000Message.fields.append(NMEA2000Field('reserved_597', 'Reserved', None, None, reserved_597, reserved_597_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 3

    return nmea2000Message

def encode_pgn_129794(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129794."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 6
    # user_id | Offset: 8, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'user_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'User ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # imo_number | Offset: 40, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'imo_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'IMO number'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 40
    # callsign | Offset: 72, Length: 56, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'callsign')
    if field is None:
        raise Exception("Cant encode this message, missing 'Callsign'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFF) << 72
    # name | Offset: 128, Length: 160, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Name'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 128
    # type_of_ship | Offset: 288, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'type_of_ship')
    if field is None:
        raise Exception("Cant encode this message, missing 'Type of ship'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SHIP_TYPE(field.value)
    data_raw |= (field_value & 0xFF) << 288
    # length | Offset: 296, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'length')
    if field is None:
        raise Exception("Cant encode this message, missing 'Length'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 296
    
    # beam | Offset: 312, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'beam')
    if field is None:
        raise Exception("Cant encode this message, missing 'Beam'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 312
    
    # position_reference_from_starboard | Offset: 328, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'position_reference_from_starboard')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position reference from Starboard'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 328
    
    # position_reference_from_bow | Offset: 344, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'position_reference_from_bow')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position reference from Bow'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 344
    
    # eta_date | Offset: 360, Length: 16, Resolution: 1, Field Type: DATE
    field = next(f for f in nmea2000Message.fields if f.id == 'eta_date')
    if field is None:
        raise Exception("Cant encode this message, missing 'ETA Date'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 360
    # eta_time | Offset: 376, Length: 32, Resolution: 0.0001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'eta_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'ETA Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFFFFFF) << 376
    
    # draft | Offset: 408, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'draft')
    if field is None:
        raise Exception("Cant encode this message, missing 'Draft'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 408
    
    # destination | Offset: 424, Length: 160, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'destination')
    if field is None:
        raise Exception("Cant encode this message, missing 'Destination'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 424
    # ais_version_indicator | Offset: 584, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_version_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS version indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_VERSION(field.value)
    data_raw |= (field_value & 0x3) << 584
    # gnss_type | Offset: 586, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'gnss_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'GNSS type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_POSITION_FIX_DEVICE(field.value)
    data_raw |= (field_value & 0xF) << 586
    # dte | Offset: 590, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'dte')
    if field is None:
        raise Exception("Cant encode this message, missing 'DTE'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AVAILABLE(field.value)
    data_raw |= (field_value & 0x1) << 590
    # reserved_591 | Offset: 591, Length: 1, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_591')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1) << 591
    # ais_transceiver_information | Offset: 592, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_transceiver_information')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS Transceiver information'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TRANSCEIVER(field.value)
    data_raw |= (field_value & 0x1F) << 592
    # reserved_597 | Offset: 597, Length: 3, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_597')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x7) << 597
    return data_raw


def is_fast_pgn_129795() -> bool:
    """Return True if PGN 129795 is a fast PGN."""
    return True
def decode_pgn_129795(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129795."""
    nmea2000Message = NMEA2000Message(129795, 'aisAddressedBinaryMessage', 'AIS Addressed Binary Message')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:source_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    source_id = source_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('source_id', 'Source ID', None, None, source_id, source_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 4:reserved_40 | Offset: 40, Length: 1, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    reserved_40 = reserved_40_raw = decode_int(_data_raw_, running_bit_offset, 1)
    nmea2000Message.fields.append(NMEA2000Field('reserved_40', 'Reserved', None, None, reserved_40, reserved_40_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 1

    # 5:ais_transceiver_information | Offset: 41, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 41
    ais_transceiver_information_raw = decode_int(_data_raw_, running_bit_offset, 5)
    ais_transceiver_information = master_dict['AIS_TRANSCEIVER'].get(ais_transceiver_information_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_transceiver_information', 'AIS Transceiver information', None, None, ais_transceiver_information, ais_transceiver_information_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 6:sequence_number | Offset: 46, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 46
    sequence_number = sequence_number_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sequence_number', 'Sequence Number', None, None, sequence_number, sequence_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 7:destination_id | Offset: 48, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 48
    destination_id = destination_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('destination_id', 'Destination ID', None, None, destination_id, destination_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 8:reserved_80 | Offset: 80, Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    reserved_80 = reserved_80_raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_80', 'Reserved', None, None, reserved_80, reserved_80_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    # 9:retransmit_flag | Offset: 86, Length: 1, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 86
    retransmit_flag = retransmit_flag_raw = decode_number(_data_raw_, running_bit_offset, 1, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('retransmit_flag', 'Retransmit flag', None, None, retransmit_flag, retransmit_flag_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 1

    # 10:reserved_87 | Offset: 87, Length: 1, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 87
    reserved_87 = reserved_87_raw = decode_int(_data_raw_, running_bit_offset, 1)
    nmea2000Message.fields.append(NMEA2000Field('reserved_87', 'Reserved', None, None, reserved_87, reserved_87_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 1

    # 11:number_of_bits_in_binary_data_field | Offset: 88, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    number_of_bits_in_binary_data_field = number_of_bits_in_binary_data_field_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_bits_in_binary_data_field', 'Number of Bits in Binary Data Field', None, None, number_of_bits_in_binary_data_field, number_of_bits_in_binary_data_field_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 12:binary_data | Offset: , Length: , Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    binary_data = binary_data_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, number_of_bits_in_binary_data_field))
    nmea2000Message.fields.append(NMEA2000Field('binary_data', 'Binary Data', None, None, binary_data, binary_data_raw, None, FieldTypes.BINARY, False))
    

    return nmea2000Message

def encode_pgn_129795(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129795."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 6
    # source_id | Offset: 8, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'source_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # reserved_40 | Offset: 40, Length: 1, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_40')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1) << 40
    # ais_transceiver_information | Offset: 41, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_transceiver_information')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS Transceiver information'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TRANSCEIVER(field.value)
    data_raw |= (field_value & 0x1F) << 41
    # sequence_number | Offset: 46, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sequence_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Sequence Number'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 46
    # destination_id | Offset: 48, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'destination_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Destination ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 48
    # reserved_80 | Offset: 80, Length: 6, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_80')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 80
    # retransmit_flag | Offset: 86, Length: 1, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'retransmit_flag')
    if field is None:
        raise Exception("Cant encode this message, missing 'Retransmit flag'")
    field_value = field.value
    data_raw |= (field_value & 0x1) << 86
    # reserved_87 | Offset: 87, Length: 1, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_87')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1) << 87
    # number_of_bits_in_binary_data_field | Offset: 88, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_bits_in_binary_data_field')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of Bits in Binary Data Field'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 88
    raise Exception ("PGN 129795 not supporting encoding for now as Binary Data is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_129796() -> bool:
    """Return True if PGN 129796 is a fast PGN."""
    return True
def decode_pgn_129796(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129796."""
    nmea2000Message = NMEA2000Message(129796, 'aisAcknowledge', 'AIS Acknowledge')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:source_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    source_id = source_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('source_id', 'Source ID', None, None, source_id, source_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 4:reserved_40 | Offset: 40, Length: 1, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    reserved_40 = reserved_40_raw = decode_int(_data_raw_, running_bit_offset, 1)
    nmea2000Message.fields.append(NMEA2000Field('reserved_40', 'Reserved', None, None, reserved_40, reserved_40_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 1

    # 5:ais_transceiver_information | Offset: 41, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 41
    ais_transceiver_information_raw = decode_int(_data_raw_, running_bit_offset, 5)
    ais_transceiver_information = master_dict['AIS_TRANSCEIVER'].get(ais_transceiver_information_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_transceiver_information', 'AIS Transceiver information', None, None, ais_transceiver_information, ais_transceiver_information_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 6:reserved_46 | Offset: 46, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 46
    reserved_46 = reserved_46_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_46', 'Reserved', None, None, reserved_46, reserved_46_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 7:destination_id__1 | Offset: 48, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    destination_id__1 = destination_id__1_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('destination_id__1', 'Destination ID #1', None, None, destination_id__1, destination_id__1_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 8:sequence_number_for_id_1 | Offset: 80, Length: 2, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    sequence_number_for_id_1 = sequence_number_for_id_1_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 2))
    nmea2000Message.fields.append(NMEA2000Field('sequence_number_for_id_1', 'Sequence Number for ID 1', "reserved", None, sequence_number_for_id_1, sequence_number_for_id_1_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 2

    # 9:reserved_82 | Offset: 82, Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 82
    reserved_82 = reserved_82_raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_82', 'Reserved', None, None, reserved_82, reserved_82_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    # 10:sequence_number_for_id_n | Offset: 88, Length: 2, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    sequence_number_for_id_n = sequence_number_for_id_n_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 2))
    nmea2000Message.fields.append(NMEA2000Field('sequence_number_for_id_n', 'Sequence Number for ID n', "reserved", None, sequence_number_for_id_n, sequence_number_for_id_n_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 2

    # 11:reserved_90 | Offset: 90, Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 90
    reserved_90 = reserved_90_raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_90', 'Reserved', None, None, reserved_90, reserved_90_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    return nmea2000Message

def encode_pgn_129796(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129796."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 6
    # source_id | Offset: 8, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'source_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # reserved_40 | Offset: 40, Length: 1, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_40')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1) << 40
    # ais_transceiver_information | Offset: 41, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_transceiver_information')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS Transceiver information'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TRANSCEIVER(field.value)
    data_raw |= (field_value & 0x1F) << 41
    # reserved_46 | Offset: 46, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_46')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 46
    # destination_id__1 | Offset: 48, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'destination_id__1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Destination ID #1'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 48
    # sequence_number_for_id_1 | Offset: 80, Length: 2, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'sequence_number_for_id_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Sequence Number for ID 1'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 80
    # reserved_82 | Offset: 82, Length: 6, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_82')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 82
    # sequence_number_for_id_n | Offset: 88, Length: 2, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'sequence_number_for_id_n')
    if field is None:
        raise Exception("Cant encode this message, missing 'Sequence Number for ID n'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 88
    # reserved_90 | Offset: 90, Length: 6, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_90')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 90
    return data_raw


def is_fast_pgn_129797() -> bool:
    """Return True if PGN 129797 is a fast PGN."""
    return True
def decode_pgn_129797(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129797."""
    nmea2000Message = NMEA2000Message(129797, 'aisBinaryBroadcastMessage', 'AIS Binary Broadcast Message')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:source_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    source_id = source_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('source_id', 'Source ID', None, None, source_id, source_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 4:reserved_40 | Offset: 40, Length: 1, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    reserved_40 = reserved_40_raw = decode_int(_data_raw_, running_bit_offset, 1)
    nmea2000Message.fields.append(NMEA2000Field('reserved_40', 'Reserved', None, None, reserved_40, reserved_40_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 1

    # 5:ais_transceiver_information | Offset: 41, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 41
    ais_transceiver_information_raw = decode_int(_data_raw_, running_bit_offset, 5)
    ais_transceiver_information = master_dict['AIS_TRANSCEIVER'].get(ais_transceiver_information_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_transceiver_information', 'AIS Transceiver information', None, None, ais_transceiver_information, ais_transceiver_information_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 6:reserved_46 | Offset: 46, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 46
    reserved_46 = reserved_46_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_46', 'Reserved', None, None, reserved_46, reserved_46_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 7:number_of_bits_in_binary_data_field | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    number_of_bits_in_binary_data_field = number_of_bits_in_binary_data_field_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_bits_in_binary_data_field', 'Number of Bits in Binary Data Field', None, None, number_of_bits_in_binary_data_field, number_of_bits_in_binary_data_field_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:binary_data | Offset: , Length: , Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    binary_data = binary_data_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, number_of_bits_in_binary_data_field))
    nmea2000Message.fields.append(NMEA2000Field('binary_data', 'Binary Data', None, None, binary_data, binary_data_raw, None, FieldTypes.BINARY, False))
    

    return nmea2000Message

def encode_pgn_129797(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129797."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 6
    # source_id | Offset: 8, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'source_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # reserved_40 | Offset: 40, Length: 1, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_40')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1) << 40
    # ais_transceiver_information | Offset: 41, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_transceiver_information')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS Transceiver information'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TRANSCEIVER(field.value)
    data_raw |= (field_value & 0x1F) << 41
    # reserved_46 | Offset: 46, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_46')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 46
    # number_of_bits_in_binary_data_field | Offset: 48, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_bits_in_binary_data_field')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of Bits in Binary Data Field'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    raise Exception ("PGN 129797 not supporting encoding for now as Binary Data is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_129798() -> bool:
    """Return True if PGN 129798 is a fast PGN."""
    return True
def decode_pgn_129798(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129798."""
    nmea2000Message = NMEA2000Message(129798, 'aisSarAircraftPositionReport', 'AIS SAR Aircraft Position Report')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:user_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    user_id = user_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('user_id', 'User ID', None, None, user_id, user_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 4:longitude | Offset: 40, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    longitude = longitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('longitude', 'Longitude', None, 'deg', longitude, longitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 5:latitude | Offset: 72, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    latitude = latitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('latitude', 'Latitude', None, 'deg', latitude, latitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:position_accuracy | Offset: 104, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 104
    position_accuracy_raw = decode_int(_data_raw_, running_bit_offset, 1)
    position_accuracy = master_dict['POSITION_ACCURACY'].get(position_accuracy_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('position_accuracy', 'Position Accuracy', None, None, position_accuracy, position_accuracy_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 7:raim | Offset: 105, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 105
    raim_raw = decode_int(_data_raw_, running_bit_offset, 1)
    raim = master_dict['RAIM_FLAG'].get(raim_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('raim', 'RAIM', None, None, raim, raim_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 8:time_stamp | Offset: 106, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 106
    time_stamp_raw = decode_int(_data_raw_, running_bit_offset, 6)
    time_stamp = master_dict['TIME_STAMP'].get(time_stamp_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('time_stamp', 'Time Stamp', None, None, time_stamp, time_stamp_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 9:cog | Offset: 112, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    cog = cog_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('cog', 'COG', None, 'rad', cog, cog_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 10:sog | Offset: 128, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    sog = sog_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('sog', 'SOG', None, 'm/s', sog, sog_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:communication_state | Offset: 144, Length: 19, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    communication_state = communication_state_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 19))
    nmea2000Message.fields.append(NMEA2000Field('communication_state', 'Communication State', "Information used by the TDMA slot allocation algorithm and synchronization information", None, communication_state, communication_state_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 19

    # 12:ais_transceiver_information | Offset: 163, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 163
    ais_transceiver_information_raw = decode_int(_data_raw_, running_bit_offset, 5)
    ais_transceiver_information = master_dict['AIS_TRANSCEIVER'].get(ais_transceiver_information_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_transceiver_information', 'AIS Transceiver information', None, None, ais_transceiver_information, ais_transceiver_information_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 13:altitude | Offset: 168, Length: 32, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 168
    altitude = altitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('altitude', 'Altitude', None, 'm', altitude, altitude_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 14:reserved_for_regional_applications | Offset: 200, Length: 8, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 200
    reserved_for_regional_applications = reserved_for_regional_applications_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 8))
    nmea2000Message.fields.append(NMEA2000Field('reserved_for_regional_applications', 'Reserved for Regional Applications', None, None, reserved_for_regional_applications, reserved_for_regional_applications_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 8

    # 15:dte | Offset: 208, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 208
    dte_raw = decode_int(_data_raw_, running_bit_offset, 1)
    dte = master_dict['AVAILABLE'].get(dte_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('dte', 'DTE', None, None, dte, dte_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 16:reserved_209 | Offset: 209, Length: 7, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 209
    reserved_209 = reserved_209_raw = decode_int(_data_raw_, running_bit_offset, 7)
    nmea2000Message.fields.append(NMEA2000Field('reserved_209', 'Reserved', None, None, reserved_209, reserved_209_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 7

    return nmea2000Message

def encode_pgn_129798(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129798."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 6
    # user_id | Offset: 8, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'user_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'User ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # longitude | Offset: 40, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'longitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Longitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 40
    
    # latitude | Offset: 72, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'latitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Latitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 72
    
    # position_accuracy | Offset: 104, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'position_accuracy')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position Accuracy'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_POSITION_ACCURACY(field.value)
    data_raw |= (field_value & 0x1) << 104
    # raim | Offset: 105, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'raim')
    if field is None:
        raise Exception("Cant encode this message, missing 'RAIM'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_RAIM_FLAG(field.value)
    data_raw |= (field_value & 0x1) << 105
    # time_stamp | Offset: 106, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'time_stamp')
    if field is None:
        raise Exception("Cant encode this message, missing 'Time Stamp'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_TIME_STAMP(field.value)
    data_raw |= (field_value & 0x3F) << 106
    # cog | Offset: 112, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'cog')
    if field is None:
        raise Exception("Cant encode this message, missing 'COG'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 112
    
    # sog | Offset: 128, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sog')
    if field is None:
        raise Exception("Cant encode this message, missing 'SOG'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 128
    
    # communication_state | Offset: 144, Length: 19, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'communication_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'Communication State'")
    field_value = field.value
    data_raw |= (field_value & 0x7FFFF) << 144
    # ais_transceiver_information | Offset: 163, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_transceiver_information')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS Transceiver information'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TRANSCEIVER(field.value)
    data_raw |= (field_value & 0x1F) << 163
    # altitude | Offset: 168, Length: 32, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'altitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Altitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFFFFFF) << 168
    
    # reserved_for_regional_applications | Offset: 200, Length: 8, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_for_regional_applications')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved for Regional Applications'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 200
    # dte | Offset: 208, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'dte')
    if field is None:
        raise Exception("Cant encode this message, missing 'DTE'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AVAILABLE(field.value)
    data_raw |= (field_value & 0x1) << 208
    # reserved_209 | Offset: 209, Length: 7, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_209')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x7F) << 209
    return data_raw


def is_fast_pgn_129799() -> bool:
    """Return True if PGN 129799 is a fast PGN."""
    return True
def decode_pgn_129799(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129799."""
    nmea2000Message = NMEA2000Message(129799, 'radioFrequencyModePower', 'Radio Frequency/Mode/Power')
    running_bit_offset = 0
    # 1:rx_frequency | Offset: 0, Length: 32, Signed: False Resolution: 10, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    rx_frequency = rx_frequency_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 10)
    nmea2000Message.fields.append(NMEA2000Field('rx_frequency', 'Rx Frequency', None, 'Hz', rx_frequency, rx_frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:tx_frequency | Offset: 32, Length: 32, Signed: False Resolution: 10, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    tx_frequency = tx_frequency_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 10)
    nmea2000Message.fields.append(NMEA2000Field('tx_frequency', 'Tx Frequency', None, 'Hz', tx_frequency, tx_frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 3:radio_channel | Offset: 64, Length: 48, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    radio_channel = radio_channel_raw = decode_string_fix(_data_raw_, running_bit_offset, 48)
    nmea2000Message.fields.append(NMEA2000Field('radio_channel', 'Radio Channel', None, None, radio_channel, radio_channel_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 48

    # 4:tx_power | Offset: 112, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    tx_power = tx_power_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('tx_power', 'Tx Power', None, 'W', tx_power, tx_power_raw, PhysicalQuantities.ELECTRICAL_POWER, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:mode | Offset: 120, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    mode = mode_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('mode', 'Mode', None, None, mode, mode_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:channel_bandwidth | Offset: 136, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 136
    channel_bandwidth = channel_bandwidth_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('channel_bandwidth', 'Channel Bandwidth', None, 'Hz', channel_bandwidth, channel_bandwidth_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_129799(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129799."""
    data_raw = 0
    # rx_frequency | Offset: 0, Length: 32, Resolution: 10, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'rx_frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'Rx Frequency'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 10) & 0xFFFFFFFF) << 0
    
    # tx_frequency | Offset: 32, Length: 32, Resolution: 10, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'tx_frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'Tx Frequency'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 10) & 0xFFFFFFFF) << 32
    
    # radio_channel | Offset: 64, Length: 48, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'radio_channel')
    if field is None:
        raise Exception("Cant encode this message, missing 'Radio Channel'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFF) << 64
    # tx_power | Offset: 112, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'tx_power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Tx Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 112
    # mode | Offset: 120, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mode'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 120
    # channel_bandwidth | Offset: 136, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'channel_bandwidth')
    if field is None:
        raise Exception("Cant encode this message, missing 'Channel Bandwidth'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 136
    return data_raw


def is_fast_pgn_129800() -> bool:
    """Return True if PGN 129800 is a fast PGN."""
    return True
def decode_pgn_129800(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129800."""
    nmea2000Message = NMEA2000Message(129800, 'aisUtcDateInquiry', 'AIS UTC/Date Inquiry')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:source_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    source_id = source_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('source_id', 'Source ID', None, None, source_id, source_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 4:ais_transceiver_information | Offset: 40, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    ais_transceiver_information_raw = decode_int(_data_raw_, running_bit_offset, 5)
    ais_transceiver_information = master_dict['AIS_TRANSCEIVER'].get(ais_transceiver_information_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_transceiver_information', 'AIS Transceiver information', None, None, ais_transceiver_information, ais_transceiver_information_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 5:reserved_45 | Offset: 45, Length: 3, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 45
    reserved_45 = reserved_45_raw = decode_int(_data_raw_, running_bit_offset, 3)
    nmea2000Message.fields.append(NMEA2000Field('reserved_45', 'Reserved', None, None, reserved_45, reserved_45_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 3

    # 6:destination_id | Offset: 48, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 48
    destination_id = destination_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('destination_id', 'Destination ID', None, None, destination_id, destination_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_129800(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129800."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 6
    # source_id | Offset: 8, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'source_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # ais_transceiver_information | Offset: 40, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_transceiver_information')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS Transceiver information'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TRANSCEIVER(field.value)
    data_raw |= (field_value & 0x1F) << 40
    # reserved_45 | Offset: 45, Length: 3, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_45')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x7) << 45
    # destination_id | Offset: 48, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'destination_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Destination ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 48
    return data_raw


def is_fast_pgn_129801() -> bool:
    """Return True if PGN 129801 is a fast PGN."""
    return True
def decode_pgn_129801(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129801."""
    nmea2000Message = NMEA2000Message(129801, 'aisAddressedSafetyRelatedMessage', 'AIS Addressed Safety Related Message')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:source_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    source_id = source_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('source_id', 'Source ID', None, None, source_id, source_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 4:ais_transceiver_information | Offset: 40, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    ais_transceiver_information_raw = decode_int(_data_raw_, running_bit_offset, 5)
    ais_transceiver_information = master_dict['AIS_TRANSCEIVER'].get(ais_transceiver_information_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_transceiver_information', 'AIS Transceiver information', None, None, ais_transceiver_information, ais_transceiver_information_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 5:sequence_number | Offset: 45, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 45
    sequence_number = sequence_number_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sequence_number', 'Sequence Number', None, None, sequence_number, sequence_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 6:reserved_47 | Offset: 47, Length: 1, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 47
    reserved_47 = reserved_47_raw = decode_int(_data_raw_, running_bit_offset, 1)
    nmea2000Message.fields.append(NMEA2000Field('reserved_47', 'Reserved', None, None, reserved_47, reserved_47_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 1

    # 7:destination_id | Offset: 48, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 48
    destination_id = destination_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('destination_id', 'Destination ID', None, None, destination_id, destination_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 8:retransmit_flag | Offset: 80, Length: 1, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    retransmit_flag = retransmit_flag_raw = decode_number(_data_raw_, running_bit_offset, 1, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('retransmit_flag', 'Retransmit flag', None, None, retransmit_flag, retransmit_flag_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 1

    # 9:reserved_81 | Offset: 81, Length: 7, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 81
    reserved_81 = reserved_81_raw = decode_int(_data_raw_, running_bit_offset, 7)
    nmea2000Message.fields.append(NMEA2000Field('reserved_81', 'Reserved', None, None, reserved_81, reserved_81_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 7

    # 10:safety_related_text | Offset: 88, Length: 936, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    safety_related_text = safety_related_text_raw = decode_string_fix(_data_raw_, running_bit_offset, 936)
    nmea2000Message.fields.append(NMEA2000Field('safety_related_text', 'Safety Related Text', None, None, safety_related_text, safety_related_text_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 936

    return nmea2000Message

def encode_pgn_129801(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129801."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 6
    # source_id | Offset: 8, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'source_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # ais_transceiver_information | Offset: 40, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_transceiver_information')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS Transceiver information'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TRANSCEIVER(field.value)
    data_raw |= (field_value & 0x1F) << 40
    # sequence_number | Offset: 45, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sequence_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Sequence Number'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 45
    # reserved_47 | Offset: 47, Length: 1, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_47')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1) << 47
    # destination_id | Offset: 48, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'destination_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Destination ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 48
    # retransmit_flag | Offset: 80, Length: 1, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'retransmit_flag')
    if field is None:
        raise Exception("Cant encode this message, missing 'Retransmit flag'")
    field_value = field.value
    data_raw |= (field_value & 0x1) << 80
    # reserved_81 | Offset: 81, Length: 7, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_81')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x7F) << 81
    # safety_related_text | Offset: 88, Length: 936, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'safety_related_text')
    if field is None:
        raise Exception("Cant encode this message, missing 'Safety Related Text'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 88
    return data_raw


def is_fast_pgn_129802() -> bool:
    """Return True if PGN 129802 is a fast PGN."""
    return True
def decode_pgn_129802(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129802."""
    nmea2000Message = NMEA2000Message(129802, 'aisSafetyRelatedBroadcastMessage', 'AIS Safety Related Broadcast Message')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:source_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    source_id = source_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('source_id', 'Source ID', None, None, source_id, source_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 4:ais_transceiver_information | Offset: 40, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    ais_transceiver_information_raw = decode_int(_data_raw_, running_bit_offset, 5)
    ais_transceiver_information = master_dict['AIS_TRANSCEIVER'].get(ais_transceiver_information_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_transceiver_information', 'AIS Transceiver information', None, None, ais_transceiver_information, ais_transceiver_information_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 5:reserved_45 | Offset: 45, Length: 3, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 45
    reserved_45 = reserved_45_raw = decode_int(_data_raw_, running_bit_offset, 3)
    nmea2000Message.fields.append(NMEA2000Field('reserved_45', 'Reserved', None, None, reserved_45, reserved_45_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 3

    # 6:safety_related_text | Offset: 48, Length: 1296, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    safety_related_text = safety_related_text_raw = decode_string_fix(_data_raw_, running_bit_offset, 1296)
    nmea2000Message.fields.append(NMEA2000Field('safety_related_text', 'Safety Related Text', None, None, safety_related_text, safety_related_text_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 1296

    return nmea2000Message

def encode_pgn_129802(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129802."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 6
    # source_id | Offset: 8, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'source_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # ais_transceiver_information | Offset: 40, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_transceiver_information')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS Transceiver information'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TRANSCEIVER(field.value)
    data_raw |= (field_value & 0x1F) << 40
    # reserved_45 | Offset: 45, Length: 3, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_45')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x7) << 45
    # safety_related_text | Offset: 48, Length: 1296, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'safety_related_text')
    if field is None:
        raise Exception("Cant encode this message, missing 'Safety Related Text'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 48
    return data_raw


def is_fast_pgn_129803() -> bool:
    """Return True if PGN 129803 is a fast PGN."""
    return True
def decode_pgn_129803(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129803."""
    nmea2000Message = NMEA2000Message(129803, 'aisInterrogation', 'AIS Interrogation')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:source_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    source_id = source_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('source_id', 'Source ID', None, None, source_id, source_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 4:reserved_40 | Offset: 40, Length: 1, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    reserved_40 = reserved_40_raw = decode_int(_data_raw_, running_bit_offset, 1)
    nmea2000Message.fields.append(NMEA2000Field('reserved_40', 'Reserved', None, None, reserved_40, reserved_40_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 1

    # 5:ais_transceiver_information | Offset: 41, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 41
    ais_transceiver_information_raw = decode_int(_data_raw_, running_bit_offset, 5)
    ais_transceiver_information = master_dict['AIS_TRANSCEIVER'].get(ais_transceiver_information_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_transceiver_information', 'AIS Transceiver information', None, None, ais_transceiver_information, ais_transceiver_information_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 6:spare | Offset: 46, Length: 2, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 46
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 2

    # 7:destination_id_1 | Offset: 48, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 48
    destination_id_1 = destination_id_1_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('destination_id_1', 'Destination ID 1', None, None, destination_id_1, destination_id_1_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 8:message_id_1_1 | Offset: 80, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    message_id_1_1_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id_1_1 = master_dict['AIS_MESSAGE_ID'].get(message_id_1_1_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id_1_1', 'Message ID 1.1', None, None, message_id_1_1, message_id_1_1_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 9:slot_offset_1_1 | Offset: 86, Length: 12, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 86
    slot_offset_1_1 = slot_offset_1_1_raw = decode_number(_data_raw_, running_bit_offset, 12, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('slot_offset_1_1', 'Slot Offset 1.1', None, None, slot_offset_1_1, slot_offset_1_1_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 12

    # 10:spare | Offset: 98, Length: 2, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 98
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 2

    # 11:message_id_1_2 | Offset: 100, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 100
    message_id_1_2_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id_1_2 = master_dict['AIS_MESSAGE_ID'].get(message_id_1_2_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id_1_2', 'Message ID 1.2', None, None, message_id_1_2, message_id_1_2_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 12:slot_offset_1_2 | Offset: 106, Length: 12, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 106
    slot_offset_1_2 = slot_offset_1_2_raw = decode_number(_data_raw_, running_bit_offset, 12, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('slot_offset_1_2', 'Slot Offset 1.2', None, None, slot_offset_1_2, slot_offset_1_2_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 12

    # 13:spare | Offset: 118, Length: 2, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 118
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 2

    # 14:destination_id_2 | Offset: 120, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 120
    destination_id_2 = destination_id_2_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('destination_id_2', 'Destination ID 2', None, None, destination_id_2, destination_id_2_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 15:message_id_2_1 | Offset: 152, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 152
    message_id_2_1_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id_2_1 = master_dict['AIS_MESSAGE_ID'].get(message_id_2_1_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id_2_1', 'Message ID 2.1', None, None, message_id_2_1, message_id_2_1_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 16:slot_offset_2_1 | Offset: 158, Length: 12, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 158
    slot_offset_2_1 = slot_offset_2_1_raw = decode_number(_data_raw_, running_bit_offset, 12, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('slot_offset_2_1', 'Slot Offset 2.1', None, None, slot_offset_2_1, slot_offset_2_1_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 12

    # 17:spare | Offset: 170, Length: 2, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 170
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 2

    # 18:reserved_172 | Offset: 172, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 172
    reserved_172 = reserved_172_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_172', 'Reserved', None, None, reserved_172, reserved_172_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 19:sid | Offset: 176, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 176
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_129803(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129803."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 6
    # source_id | Offset: 8, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'source_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # reserved_40 | Offset: 40, Length: 1, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_40')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1) << 40
    # ais_transceiver_information | Offset: 41, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_transceiver_information')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS Transceiver information'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TRANSCEIVER(field.value)
    data_raw |= (field_value & 0x1F) << 41
    # spare | Offset: 46, Length: 2, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 46
    # destination_id_1 | Offset: 48, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'destination_id_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Destination ID 1'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 48
    # message_id_1_1 | Offset: 80, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id_1_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID 1.1'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 80
    # slot_offset_1_1 | Offset: 86, Length: 12, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'slot_offset_1_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Slot Offset 1.1'")
    field_value = field.value
    data_raw |= (field_value & 0xFFF) << 86
    # spare | Offset: 98, Length: 2, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 98
    # message_id_1_2 | Offset: 100, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id_1_2')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID 1.2'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 100
    # slot_offset_1_2 | Offset: 106, Length: 12, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'slot_offset_1_2')
    if field is None:
        raise Exception("Cant encode this message, missing 'Slot Offset 1.2'")
    field_value = field.value
    data_raw |= (field_value & 0xFFF) << 106
    # spare | Offset: 118, Length: 2, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 118
    # destination_id_2 | Offset: 120, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'destination_id_2')
    if field is None:
        raise Exception("Cant encode this message, missing 'Destination ID 2'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 120
    # message_id_2_1 | Offset: 152, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id_2_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID 2.1'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 152
    # slot_offset_2_1 | Offset: 158, Length: 12, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'slot_offset_2_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Slot Offset 2.1'")
    field_value = field.value
    data_raw |= (field_value & 0xFFF) << 158
    # spare | Offset: 170, Length: 2, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 170
    # reserved_172 | Offset: 172, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_172')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 172
    # sid | Offset: 176, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 176
    return data_raw


def is_fast_pgn_129804() -> bool:
    """Return True if PGN 129804 is a fast PGN."""
    return True
def decode_pgn_129804(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129804."""
    nmea2000Message = NMEA2000Message(129804, 'aisAssignmentModeCommand', 'AIS Assignment Mode Command')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:source_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    source_id = source_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('source_id', 'Source ID', None, None, source_id, source_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 4:ais_transceiver_information | Offset: 40, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    ais_transceiver_information_raw = decode_int(_data_raw_, running_bit_offset, 5)
    ais_transceiver_information = master_dict['AIS_TRANSCEIVER'].get(ais_transceiver_information_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_transceiver_information', 'AIS Transceiver information', None, None, ais_transceiver_information, ais_transceiver_information_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 5:reserved_45 | Offset: 45, Length: 3, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 45
    reserved_45 = reserved_45_raw = decode_int(_data_raw_, running_bit_offset, 3)
    nmea2000Message.fields.append(NMEA2000Field('reserved_45', 'Reserved', None, None, reserved_45, reserved_45_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 3

    # 6:destination_id_a | Offset: 48, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 48
    destination_id_a = destination_id_a_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('destination_id_a', 'Destination ID A', None, None, destination_id_a, destination_id_a_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 7:offset_a | Offset: 80, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    offset_a = offset_a_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('offset_a', 'Offset A', None, None, offset_a, offset_a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:increment_a | Offset: 96, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 96
    increment_a = increment_a_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('increment_a', 'Increment A', None, None, increment_a, increment_a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:destination_id_b | Offset: 112, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 112
    destination_id_b = destination_id_b_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('destination_id_b', 'Destination ID B', None, None, destination_id_b, destination_id_b_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 10:offset_b | Offset: 144, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    offset_b = offset_b_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('offset_b', 'Offset B', None, None, offset_b, offset_b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:increment_b | Offset: 160, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 160
    increment_b = increment_b_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('increment_b', 'Increment B', None, None, increment_b, increment_b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_129804(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129804."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 6
    # source_id | Offset: 8, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'source_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # ais_transceiver_information | Offset: 40, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_transceiver_information')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS Transceiver information'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TRANSCEIVER(field.value)
    data_raw |= (field_value & 0x1F) << 40
    # reserved_45 | Offset: 45, Length: 3, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_45')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x7) << 45
    # destination_id_a | Offset: 48, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'destination_id_a')
    if field is None:
        raise Exception("Cant encode this message, missing 'Destination ID A'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 48
    # offset_a | Offset: 80, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'offset_a')
    if field is None:
        raise Exception("Cant encode this message, missing 'Offset A'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 80
    # increment_a | Offset: 96, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'increment_a')
    if field is None:
        raise Exception("Cant encode this message, missing 'Increment A'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 96
    # destination_id_b | Offset: 112, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'destination_id_b')
    if field is None:
        raise Exception("Cant encode this message, missing 'Destination ID B'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 112
    # offset_b | Offset: 144, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'offset_b')
    if field is None:
        raise Exception("Cant encode this message, missing 'Offset B'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 144
    # increment_b | Offset: 160, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'increment_b')
    if field is None:
        raise Exception("Cant encode this message, missing 'Increment B'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 160
    return data_raw


def is_fast_pgn_129805() -> bool:
    """Return True if PGN 129805 is a fast PGN."""
    return True
def decode_pgn_129805(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129805."""
    nmea2000Message = NMEA2000Message(129805, 'aisDataLinkManagementMessage', 'AIS Data Link Management Message')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:source_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    source_id = source_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('source_id', 'Source ID', None, None, source_id, source_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 4:ais_transceiver_information | Offset: 40, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    ais_transceiver_information_raw = decode_int(_data_raw_, running_bit_offset, 5)
    ais_transceiver_information = master_dict['AIS_TRANSCEIVER'].get(ais_transceiver_information_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_transceiver_information', 'AIS Transceiver information', None, None, ais_transceiver_information, ais_transceiver_information_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 5:reserved_45 | Offset: 45, Length: 3, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 45
    reserved_45 = reserved_45_raw = decode_int(_data_raw_, running_bit_offset, 3)
    nmea2000Message.fields.append(NMEA2000Field('reserved_45', 'Reserved', None, None, reserved_45, reserved_45_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 3

    # 6:offset | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    offset = offset_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('offset', 'Offset', None, None, offset, offset_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:number_of_slots | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    number_of_slots = number_of_slots_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_slots', 'Number of Slots', None, None, number_of_slots, number_of_slots_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:timeout | Offset: 72, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    timeout = timeout_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('timeout', 'Timeout', None, None, timeout, timeout_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:increment | Offset: 80, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    increment = increment_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('increment', 'Increment', None, None, increment, increment_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_129805(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129805."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 6
    # source_id | Offset: 8, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'source_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # ais_transceiver_information | Offset: 40, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_transceiver_information')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS Transceiver information'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TRANSCEIVER(field.value)
    data_raw |= (field_value & 0x1F) << 40
    # reserved_45 | Offset: 45, Length: 3, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_45')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x7) << 45
    # offset | Offset: 48, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'offset')
    if field is None:
        raise Exception("Cant encode this message, missing 'Offset'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    # number_of_slots | Offset: 64, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_slots')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of Slots'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 64
    # timeout | Offset: 72, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'timeout')
    if field is None:
        raise Exception("Cant encode this message, missing 'Timeout'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 72
    # increment | Offset: 80, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'increment')
    if field is None:
        raise Exception("Cant encode this message, missing 'Increment'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 80
    return data_raw


def is_fast_pgn_129806() -> bool:
    """Return True if PGN 129806 is a fast PGN."""
    return True
def decode_pgn_129806(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129806."""
    nmea2000Message = NMEA2000Message(129806, 'aisChannelManagement', 'AIS Channel Management')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:source_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    source_id = source_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('source_id', 'Source ID', None, None, source_id, source_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 4:ais_transceiver_information | Offset: 40, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    ais_transceiver_information_raw = decode_int(_data_raw_, running_bit_offset, 5)
    ais_transceiver_information = master_dict['AIS_TRANSCEIVER'].get(ais_transceiver_information_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_transceiver_information', 'AIS Transceiver information', None, None, ais_transceiver_information, ais_transceiver_information_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 5:reserved_45 | Offset: 45, Length: 3, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 45
    reserved_45 = reserved_45_raw = decode_int(_data_raw_, running_bit_offset, 3)
    nmea2000Message.fields.append(NMEA2000Field('reserved_45', 'Reserved', None, None, reserved_45, reserved_45_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 3

    # 6:channel_a | Offset: 48, Length: 7, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    channel_a = channel_a_raw = decode_number(_data_raw_, running_bit_offset, 7, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('channel_a', 'Channel A', None, None, channel_a, channel_a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 7

    # 7:channel_b | Offset: 55, Length: 7, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 55
    channel_b = channel_b_raw = decode_number(_data_raw_, running_bit_offset, 7, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('channel_b', 'Channel B', None, None, channel_b, channel_b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 7

    # 8:reserved_62 | Offset: 62, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 62
    reserved_62 = reserved_62_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_62', 'Reserved', None, None, reserved_62, reserved_62_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 9:power | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    power = power_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('power', 'Power', "reserved", None, power, power_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:tx_rx_mode | Offset: 72, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    tx_rx_mode = tx_rx_mode_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('tx_rx_mode', 'Tx/Rx Mode', None, None, tx_rx_mode, tx_rx_mode_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 11:north_east_longitude_corner_1 | Offset: 80, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    north_east_longitude_corner_1 = north_east_longitude_corner_1_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('north_east_longitude_corner_1', 'North East Longitude Corner 1', None, 'deg', north_east_longitude_corner_1, north_east_longitude_corner_1_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 12:north_east_latitude_corner_1 | Offset: 112, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    north_east_latitude_corner_1 = north_east_latitude_corner_1_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('north_east_latitude_corner_1', 'North East Latitude Corner 1', None, 'deg', north_east_latitude_corner_1, north_east_latitude_corner_1_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 13:south_west_longitude_corner_1 | Offset: 144, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    south_west_longitude_corner_1 = south_west_longitude_corner_1_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('south_west_longitude_corner_1', 'South West Longitude Corner 1', None, 'deg', south_west_longitude_corner_1, south_west_longitude_corner_1_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 14:south_west_latitude_corner_2 | Offset: 176, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 176
    south_west_latitude_corner_2 = south_west_latitude_corner_2_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('south_west_latitude_corner_2', 'South West Latitude Corner 2', None, 'deg', south_west_latitude_corner_2, south_west_latitude_corner_2_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 15:reserved_208 | Offset: 208, Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 208
    reserved_208 = reserved_208_raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_208', 'Reserved', None, None, reserved_208, reserved_208_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    # 16:addressed_or_broadcast_message_indicator | Offset: 214, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 214
    addressed_or_broadcast_message_indicator = addressed_or_broadcast_message_indicator_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('addressed_or_broadcast_message_indicator', 'Addressed or Broadcast Message Indicator', None, None, addressed_or_broadcast_message_indicator, addressed_or_broadcast_message_indicator_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 17:channel_a_bandwidth | Offset: 216, Length: 7, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 216
    channel_a_bandwidth = channel_a_bandwidth_raw = decode_number(_data_raw_, running_bit_offset, 7, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('channel_a_bandwidth', 'Channel A Bandwidth', None, None, channel_a_bandwidth, channel_a_bandwidth_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 7

    # 18:channel_b_bandwidth | Offset: 223, Length: 7, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 223
    channel_b_bandwidth = channel_b_bandwidth_raw = decode_number(_data_raw_, running_bit_offset, 7, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('channel_b_bandwidth', 'Channel B Bandwidth', None, None, channel_b_bandwidth, channel_b_bandwidth_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 7

    # 19:reserved_230 | Offset: 230, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 230
    reserved_230 = reserved_230_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_230', 'Reserved', None, None, reserved_230, reserved_230_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 20:transitional_zone_size | Offset: 232, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 232
    transitional_zone_size = transitional_zone_size_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('transitional_zone_size', 'Transitional Zone Size', None, None, transitional_zone_size, transitional_zone_size_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_129806(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129806."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 6
    # source_id | Offset: 8, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'source_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # ais_transceiver_information | Offset: 40, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_transceiver_information')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS Transceiver information'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TRANSCEIVER(field.value)
    data_raw |= (field_value & 0x1F) << 40
    # reserved_45 | Offset: 45, Length: 3, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_45')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x7) << 45
    # channel_a | Offset: 48, Length: 7, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'channel_a')
    if field is None:
        raise Exception("Cant encode this message, missing 'Channel A'")
    field_value = field.value
    data_raw |= (field_value & 0x7F) << 48
    # channel_b | Offset: 55, Length: 7, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'channel_b')
    if field is None:
        raise Exception("Cant encode this message, missing 'Channel B'")
    field_value = field.value
    data_raw |= (field_value & 0x7F) << 55
    # reserved_62 | Offset: 62, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_62')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 62
    # power | Offset: 64, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 64
    # tx_rx_mode | Offset: 72, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'tx_rx_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Tx/Rx Mode'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 72
    # north_east_longitude_corner_1 | Offset: 80, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'north_east_longitude_corner_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'North East Longitude Corner 1'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 80
    
    # north_east_latitude_corner_1 | Offset: 112, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'north_east_latitude_corner_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'North East Latitude Corner 1'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 112
    
    # south_west_longitude_corner_1 | Offset: 144, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'south_west_longitude_corner_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'South West Longitude Corner 1'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 144
    
    # south_west_latitude_corner_2 | Offset: 176, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'south_west_latitude_corner_2')
    if field is None:
        raise Exception("Cant encode this message, missing 'South West Latitude Corner 2'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 176
    
    # reserved_208 | Offset: 208, Length: 6, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_208')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 208
    # addressed_or_broadcast_message_indicator | Offset: 214, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'addressed_or_broadcast_message_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Addressed or Broadcast Message Indicator'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 214
    # channel_a_bandwidth | Offset: 216, Length: 7, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'channel_a_bandwidth')
    if field is None:
        raise Exception("Cant encode this message, missing 'Channel A Bandwidth'")
    field_value = field.value
    data_raw |= (field_value & 0x7F) << 216
    # channel_b_bandwidth | Offset: 223, Length: 7, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'channel_b_bandwidth')
    if field is None:
        raise Exception("Cant encode this message, missing 'Channel B Bandwidth'")
    field_value = field.value
    data_raw |= (field_value & 0x7F) << 223
    # reserved_230 | Offset: 230, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_230')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 230
    # transitional_zone_size | Offset: 232, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'transitional_zone_size')
    if field is None:
        raise Exception("Cant encode this message, missing 'Transitional Zone Size'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 232
    return data_raw


def is_fast_pgn_129807() -> bool:
    """Return True if PGN 129807 is a fast PGN."""
    return True
def decode_pgn_129807(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129807."""
    nmea2000Message = NMEA2000Message(129807, 'aisClassBGroupAssignment', 'AIS Class B Group Assignment')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:source_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    source_id = source_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('source_id', 'Source ID', None, None, source_id, source_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 4:spare | Offset: 40, Length: 2, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 2

    # 5:tx_rx_mode | Offset: 42, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 42
    tx_rx_mode_raw = decode_int(_data_raw_, running_bit_offset, 4)
    tx_rx_mode = master_dict['TX_RX_MODE'].get(tx_rx_mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('tx_rx_mode', 'Tx/Rx Mode', None, None, tx_rx_mode, tx_rx_mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 6:reserved_46 | Offset: 46, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 46
    reserved_46 = reserved_46_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_46', 'Reserved', None, None, reserved_46, reserved_46_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 7:north_east_longitude_corner_1 | Offset: 48, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    north_east_longitude_corner_1 = north_east_longitude_corner_1_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('north_east_longitude_corner_1', 'North East Longitude Corner 1', None, 'deg', north_east_longitude_corner_1, north_east_longitude_corner_1_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 8:north_east_latitude_corner_1 | Offset: 80, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    north_east_latitude_corner_1 = north_east_latitude_corner_1_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('north_east_latitude_corner_1', 'North East Latitude Corner 1', None, 'deg', north_east_latitude_corner_1, north_east_latitude_corner_1_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 9:south_west_longitude_corner_1 | Offset: 112, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    south_west_longitude_corner_1 = south_west_longitude_corner_1_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('south_west_longitude_corner_1', 'South West Longitude Corner 1', None, 'deg', south_west_longitude_corner_1, south_west_longitude_corner_1_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 10:south_west_latitude_corner_2 | Offset: 144, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    south_west_latitude_corner_2 = south_west_latitude_corner_2_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('south_west_latitude_corner_2', 'South West Latitude Corner 2', None, 'deg', south_west_latitude_corner_2, south_west_latitude_corner_2_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 11:station_type | Offset: 176, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 176
    station_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    station_type = master_dict['STATION_TYPE'].get(station_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('station_type', 'Station Type', None, None, station_type, station_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 12:reserved_180 | Offset: 180, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 180
    reserved_180 = reserved_180_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_180', 'Reserved', None, None, reserved_180, reserved_180_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 13:ship_and_cargo_filter | Offset: 184, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 184
    ship_and_cargo_filter = ship_and_cargo_filter_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('ship_and_cargo_filter', 'Ship and Cargo Filter', None, None, ship_and_cargo_filter, ship_and_cargo_filter_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 14:spare | Offset: 192, Length: 22, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 192
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 22)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 22

    # 15:reserved_214 | Offset: 214, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 214
    reserved_214 = reserved_214_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_214', 'Reserved', None, None, reserved_214, reserved_214_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 16:reporting_interval | Offset: 216, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 216
    reporting_interval_raw = decode_int(_data_raw_, running_bit_offset, 4)
    reporting_interval = master_dict['REPORTING_INTERVAL'].get(reporting_interval_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('reporting_interval', 'Reporting Interval', None, None, reporting_interval, reporting_interval_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 17:quiet_time | Offset: 220, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 220
    quiet_time = quiet_time_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('quiet_time', 'Quiet Time', None, None, quiet_time, quiet_time_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    return nmea2000Message

def encode_pgn_129807(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129807."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 6
    # source_id | Offset: 8, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'source_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # spare | Offset: 40, Length: 2, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 40
    # tx_rx_mode | Offset: 42, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'tx_rx_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Tx/Rx Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_TX_RX_MODE(field.value)
    data_raw |= (field_value & 0xF) << 42
    # reserved_46 | Offset: 46, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_46')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 46
    # north_east_longitude_corner_1 | Offset: 48, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'north_east_longitude_corner_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'North East Longitude Corner 1'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 48
    
    # north_east_latitude_corner_1 | Offset: 80, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'north_east_latitude_corner_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'North East Latitude Corner 1'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 80
    
    # south_west_longitude_corner_1 | Offset: 112, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'south_west_longitude_corner_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'South West Longitude Corner 1'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 112
    
    # south_west_latitude_corner_2 | Offset: 144, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'south_west_latitude_corner_2')
    if field is None:
        raise Exception("Cant encode this message, missing 'South West Latitude Corner 2'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 144
    
    # station_type | Offset: 176, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'station_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_STATION_TYPE(field.value)
    data_raw |= (field_value & 0xF) << 176
    # reserved_180 | Offset: 180, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_180')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 180
    # ship_and_cargo_filter | Offset: 184, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ship_and_cargo_filter')
    if field is None:
        raise Exception("Cant encode this message, missing 'Ship and Cargo Filter'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 184
    # spare | Offset: 192, Length: 22, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0x3FFFFF) << 192
    # reserved_214 | Offset: 214, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_214')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 214
    # reporting_interval | Offset: 216, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'reporting_interval')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reporting Interval'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPORTING_INTERVAL(field.value)
    data_raw |= (field_value & 0xF) << 216
    # quiet_time | Offset: 220, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'quiet_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Quiet Time'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 220
    return data_raw


def is_fast_pgn_129808() -> bool:
    """Return True if PGN 129808 is a fast PGN."""
    return True
# Complex PGN. number of matches: 2
def decode_pgn_129808(data_raw: int) -> NMEA2000Message:
    # dscDistressCallInformation | Description: DSC Distress Call Information
    if (
        (((data_raw >> 8) & 0xFF) == 112)
        ):
        return decode_pgn_129808_dscDistressCallInformation(data_raw)
    
    # dscCallInformation | Description: DSC Call Information
    if (
        ):
        return decode_pgn_129808_dscCallInformation(data_raw)
    
    
    raise Exception("No matching sub-PGN found")
    
def decode_pgn_129808_dscDistressCallInformation(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129808."""
    nmea2000Message = NMEA2000Message(129808, 'dscDistressCallInformation', 'DSC Distress Call Information')
    running_bit_offset = 0
    # 1:dsc_format | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    dsc_format_raw = decode_int(_data_raw_, running_bit_offset, 8)
    dsc_format = master_dict['DSC_FORMAT'].get(dsc_format_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('dsc_format', 'DSC Format', None, None, dsc_format, dsc_format_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:dsc_category | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: 112, PartOfPrimaryKey: ,
    running_bit_offset = 8
    dsc_category = dsc_category_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('dsc_category', 'DSC Category', "Distress", None, dsc_category, dsc_category_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:dsc_message_address | Offset: 16, Length: 40, Signed: False Resolution: 1, Field Type: DECIMAL, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    raise Exception("FieldType (DECIMAL) not supported")
    nmea2000Message.fields.append(NMEA2000Field('dsc_message_address', 'DSC Message Address', "MMSI, Geographic Area or blank", None, dsc_message_address, dsc_message_address_raw, None, FieldTypes.DECIMAL, False))
    running_bit_offset += 40

    # 4:nature_of_distress | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    nature_of_distress_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nature_of_distress = master_dict['DSC_NATURE'].get(nature_of_distress_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('nature_of_distress', 'Nature of Distress', None, None, nature_of_distress, nature_of_distress_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:subsequent_communication_mode_or_2nd_telecommand | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    subsequent_communication_mode_or_2nd_telecommand_raw = decode_int(_data_raw_, running_bit_offset, 8)
    subsequent_communication_mode_or_2nd_telecommand = master_dict['DSC_SECOND_TELECOMMAND'].get(subsequent_communication_mode_or_2nd_telecommand_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('subsequent_communication_mode_or_2nd_telecommand', 'Subsequent Communication Mode or 2nd Telecommand', None, None, subsequent_communication_mode_or_2nd_telecommand, subsequent_communication_mode_or_2nd_telecommand_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 6:proposed_rx_frequency_channel | Offset: 72, Length: 48, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    proposed_rx_frequency_channel = proposed_rx_frequency_channel_raw = decode_string_fix(_data_raw_, running_bit_offset, 48)
    nmea2000Message.fields.append(NMEA2000Field('proposed_rx_frequency_channel', 'Proposed Rx Frequency/Channel', None, None, proposed_rx_frequency_channel, proposed_rx_frequency_channel_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 48

    # 7:proposed_tx_frequency_channel | Offset: 120, Length: 48, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    proposed_tx_frequency_channel = proposed_tx_frequency_channel_raw = decode_string_fix(_data_raw_, running_bit_offset, 48)
    nmea2000Message.fields.append(NMEA2000Field('proposed_tx_frequency_channel', 'Proposed Tx Frequency/Channel', None, None, proposed_tx_frequency_channel, proposed_tx_frequency_channel_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 48

    # 8:telephone_number | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    telephone_number_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    telephone_number = telephone_number_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('telephone_number', 'Telephone Number', None, None, telephone_number, telephone_number_raw, None, FieldTypes.STRING_LAU, False))
    

    # 9:latitude_of_vessel_reported | Offset: , Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    latitude_of_vessel_reported = latitude_of_vessel_reported_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('latitude_of_vessel_reported', 'Latitude of Vessel Reported', None, 'deg', latitude_of_vessel_reported, latitude_of_vessel_reported_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 10:longitude_of_vessel_reported | Offset: , Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    longitude_of_vessel_reported = longitude_of_vessel_reported_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('longitude_of_vessel_reported', 'Longitude of Vessel Reported', None, 'deg', longitude_of_vessel_reported, longitude_of_vessel_reported_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 11:time_of_position | Offset: , Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    time_of_position_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    time_of_position = decode_time(time_of_position_raw)
    nmea2000Message.fields.append(NMEA2000Field('time_of_position', 'Time of Position', "Seconds since midnight", 's', time_of_position, time_of_position_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 12:mmsi_of_ship_in_distress | Offset: , Length: 40, Signed: False Resolution: 1, Field Type: DECIMAL, Match: , PartOfPrimaryKey: ,
    raise Exception("FieldType (DECIMAL) not supported")
    nmea2000Message.fields.append(NMEA2000Field('mmsi_of_ship_in_distress', 'MMSI of Ship In Distress', None, None, mmsi_of_ship_in_distress, mmsi_of_ship_in_distress_raw, None, FieldTypes.DECIMAL, False))
    running_bit_offset += 40

    # 13:dsc_eos_symbol | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    dsc_eos_symbol = dsc_eos_symbol_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('dsc_eos_symbol', 'DSC EOS Symbol', None, None, dsc_eos_symbol, dsc_eos_symbol_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 14:expansion_enabled | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    expansion_enabled_raw = decode_int(_data_raw_, running_bit_offset, 2)
    expansion_enabled = master_dict['YES_NO'].get(expansion_enabled_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('expansion_enabled', 'Expansion Enabled', None, None, expansion_enabled, expansion_enabled_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 15:reserved_ | Offset: , Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    reserved_ = reserved__raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_', 'Reserved', None, None, reserved_, reserved__raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    # 16:calling_rx_frequency_channel | Offset: , Length: 48, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    calling_rx_frequency_channel = calling_rx_frequency_channel_raw = decode_string_fix(_data_raw_, running_bit_offset, 48)
    nmea2000Message.fields.append(NMEA2000Field('calling_rx_frequency_channel', 'Calling Rx Frequency/Channel', None, None, calling_rx_frequency_channel, calling_rx_frequency_channel_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 48

    # 17:calling_tx_frequency_channel | Offset: , Length: 48, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    calling_tx_frequency_channel = calling_tx_frequency_channel_raw = decode_string_fix(_data_raw_, running_bit_offset, 48)
    nmea2000Message.fields.append(NMEA2000Field('calling_tx_frequency_channel', 'Calling Tx Frequency/Channel', None, None, calling_tx_frequency_channel, calling_tx_frequency_channel_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 48

    # 18:time_of_receipt | Offset: , Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    time_of_receipt_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    time_of_receipt = decode_time(time_of_receipt_raw)
    nmea2000Message.fields.append(NMEA2000Field('time_of_receipt', 'Time of Receipt', "Seconds since midnight", 's', time_of_receipt, time_of_receipt_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 19:date_of_receipt | Offset: , Length: 16, Signed: False Resolution: 1, Field Type: DATE, Match: , PartOfPrimaryKey: ,
    date_of_receipt_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    date_of_receipt = decode_date(date_of_receipt_raw)
    nmea2000Message.fields.append(NMEA2000Field('date_of_receipt', 'Date of Receipt', None, 'd', date_of_receipt, date_of_receipt_raw, PhysicalQuantities.DATE, FieldTypes.DATE, False))
    running_bit_offset += 16

    # 20:dsc_equipment_assigned_message_id | Offset: , Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    dsc_equipment_assigned_message_id = dsc_equipment_assigned_message_id_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('dsc_equipment_assigned_message_id', 'DSC Equipment Assigned Message ID', None, None, dsc_equipment_assigned_message_id, dsc_equipment_assigned_message_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 21:dsc_expansion_field_symbol | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    dsc_expansion_field_symbol_raw = decode_int(_data_raw_, running_bit_offset, 8)
    dsc_expansion_field_symbol = master_dict['DSC_EXPANSION_DATA'].get(dsc_expansion_field_symbol_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('dsc_expansion_field_symbol', 'DSC Expansion Field Symbol', None, None, dsc_expansion_field_symbol, dsc_expansion_field_symbol_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 22:dsc_expansion_field_data | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    dsc_expansion_field_data_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    dsc_expansion_field_data = dsc_expansion_field_data_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('dsc_expansion_field_data', 'DSC Expansion Field Data', None, None, dsc_expansion_field_data, dsc_expansion_field_data_raw, None, FieldTypes.STRING_LAU, False))
    

    return nmea2000Message

def encode_pgn_129808_dscDistressCallInformation(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129808."""
    data_raw = 0
    # dsc_format | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'dsc_format')
    if field is None:
        raise Exception("Cant encode this message, missing 'DSC Format'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DSC_FORMAT(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # dsc_category | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'dsc_category')
    if field is None:
        raise Exception("Cant encode this message, missing 'DSC Category'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # dsc_message_address | Offset: 16, Length: 40, Resolution: 1, Field Type: DECIMAL
    field = next(f for f in nmea2000Message.fields if f.id == 'dsc_message_address')
    if field is None:
        raise Exception("Cant encode this message, missing 'DSC Message Address'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFF) << 16
    # nature_of_distress | Offset: 56, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'nature_of_distress')
    if field is None:
        raise Exception("Cant encode this message, missing 'Nature of Distress'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DSC_NATURE(field.value)
    data_raw |= (field_value & 0xFF) << 56
    # subsequent_communication_mode_or_2nd_telecommand | Offset: 64, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'subsequent_communication_mode_or_2nd_telecommand')
    if field is None:
        raise Exception("Cant encode this message, missing 'Subsequent Communication Mode or 2nd Telecommand'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DSC_SECOND_TELECOMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 64
    # proposed_rx_frequency_channel | Offset: 72, Length: 48, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'proposed_rx_frequency_channel')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proposed Rx Frequency/Channel'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFF) << 72
    # proposed_tx_frequency_channel | Offset: 120, Length: 48, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'proposed_tx_frequency_channel')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proposed Tx Frequency/Channel'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFF) << 120
    raise Exception ("PGN 129808 not supporting encoding for now as Telephone Number is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as Latitude of Vessel Reported is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as Longitude of Vessel Reported is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as Time of Position is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as MMSI of Ship In Distress is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as DSC EOS Symbol is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as Expansion Enabled is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as Reserved is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as Calling Rx Frequency/Channel is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as Calling Tx Frequency/Channel is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as Time of Receipt is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as Date of Receipt is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as DSC Equipment Assigned Message ID is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as DSC Expansion Field Symbol is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as DSC Expansion Field Data is missing BitLength or BitOffset")
    return data_raw

def decode_pgn_129808_dscCallInformation(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129808."""
    nmea2000Message = NMEA2000Message(129808, 'dscCallInformation', 'DSC Call Information')
    running_bit_offset = 0
    # 1:dsc_format_symbol | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    dsc_format_symbol_raw = decode_int(_data_raw_, running_bit_offset, 8)
    dsc_format_symbol = master_dict['DSC_FORMAT'].get(dsc_format_symbol_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('dsc_format_symbol', 'DSC Format Symbol', None, None, dsc_format_symbol, dsc_format_symbol_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:dsc_category_symbol | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    dsc_category_symbol_raw = decode_int(_data_raw_, running_bit_offset, 8)
    dsc_category_symbol = master_dict['DSC_CATEGORY'].get(dsc_category_symbol_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('dsc_category_symbol', 'DSC Category Symbol', None, None, dsc_category_symbol, dsc_category_symbol_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 3:dsc_message_address | Offset: 16, Length: 40, Signed: False Resolution: 1, Field Type: DECIMAL, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    raise Exception("FieldType (DECIMAL) not supported")
    nmea2000Message.fields.append(NMEA2000Field('dsc_message_address', 'DSC Message Address', "MMSI, Geographic Area or blank", None, dsc_message_address, dsc_message_address_raw, None, FieldTypes.DECIMAL, False))
    running_bit_offset += 40

    # 4:__1st_telecommand | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    __1st_telecommand_raw = decode_int(_data_raw_, running_bit_offset, 8)
    __1st_telecommand = master_dict['DSC_FIRST_TELECOMMAND'].get(__1st_telecommand_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('__1st_telecommand', '1st Telecommand', None, None, __1st_telecommand, __1st_telecommand_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:subsequent_communication_mode_or_2nd_telecommand | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    subsequent_communication_mode_or_2nd_telecommand_raw = decode_int(_data_raw_, running_bit_offset, 8)
    subsequent_communication_mode_or_2nd_telecommand = master_dict['DSC_SECOND_TELECOMMAND'].get(subsequent_communication_mode_or_2nd_telecommand_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('subsequent_communication_mode_or_2nd_telecommand', 'Subsequent Communication Mode or 2nd Telecommand', None, None, subsequent_communication_mode_or_2nd_telecommand, subsequent_communication_mode_or_2nd_telecommand_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 6:proposed_rx_frequency_channel | Offset: 72, Length: 48, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    proposed_rx_frequency_channel = proposed_rx_frequency_channel_raw = decode_string_fix(_data_raw_, running_bit_offset, 48)
    nmea2000Message.fields.append(NMEA2000Field('proposed_rx_frequency_channel', 'Proposed Rx Frequency/Channel', None, None, proposed_rx_frequency_channel, proposed_rx_frequency_channel_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 48

    # 7:proposed_tx_frequency_channel | Offset: 120, Length: 48, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    proposed_tx_frequency_channel = proposed_tx_frequency_channel_raw = decode_string_fix(_data_raw_, running_bit_offset, 48)
    nmea2000Message.fields.append(NMEA2000Field('proposed_tx_frequency_channel', 'Proposed Tx Frequency/Channel', None, None, proposed_tx_frequency_channel, proposed_tx_frequency_channel_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 48

    # 8:telephone_number | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    telephone_number_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    telephone_number = telephone_number_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('telephone_number', 'Telephone Number', None, None, telephone_number, telephone_number_raw, None, FieldTypes.STRING_LAU, False))
    

    # 9:latitude_of_vessel_reported | Offset: , Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    latitude_of_vessel_reported = latitude_of_vessel_reported_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('latitude_of_vessel_reported', 'Latitude of Vessel Reported', None, 'deg', latitude_of_vessel_reported, latitude_of_vessel_reported_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 10:longitude_of_vessel_reported | Offset: , Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    longitude_of_vessel_reported = longitude_of_vessel_reported_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('longitude_of_vessel_reported', 'Longitude of Vessel Reported', None, 'deg', longitude_of_vessel_reported, longitude_of_vessel_reported_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 11:time_of_position | Offset: , Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    time_of_position_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    time_of_position = decode_time(time_of_position_raw)
    nmea2000Message.fields.append(NMEA2000Field('time_of_position', 'Time of Position', "Seconds since midnight", 's', time_of_position, time_of_position_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 12:mmsi_of_ship_in_distress | Offset: , Length: 40, Signed: False Resolution: 1, Field Type: DECIMAL, Match: , PartOfPrimaryKey: ,
    raise Exception("FieldType (DECIMAL) not supported")
    nmea2000Message.fields.append(NMEA2000Field('mmsi_of_ship_in_distress', 'MMSI of Ship In Distress', None, None, mmsi_of_ship_in_distress, mmsi_of_ship_in_distress_raw, None, FieldTypes.DECIMAL, False))
    running_bit_offset += 40

    # 13:dsc_eos_symbol | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    dsc_eos_symbol = dsc_eos_symbol_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('dsc_eos_symbol', 'DSC EOS Symbol', None, None, dsc_eos_symbol, dsc_eos_symbol_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 14:expansion_enabled | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    expansion_enabled_raw = decode_int(_data_raw_, running_bit_offset, 2)
    expansion_enabled = master_dict['YES_NO'].get(expansion_enabled_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('expansion_enabled', 'Expansion Enabled', None, None, expansion_enabled, expansion_enabled_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 15:reserved_ | Offset: , Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    reserved_ = reserved__raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_', 'Reserved', None, None, reserved_, reserved__raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    # 16:calling_rx_frequency_channel | Offset: , Length: 48, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    calling_rx_frequency_channel = calling_rx_frequency_channel_raw = decode_string_fix(_data_raw_, running_bit_offset, 48)
    nmea2000Message.fields.append(NMEA2000Field('calling_rx_frequency_channel', 'Calling Rx Frequency/Channel', None, None, calling_rx_frequency_channel, calling_rx_frequency_channel_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 48

    # 17:calling_tx_frequency_channel | Offset: , Length: 48, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    calling_tx_frequency_channel = calling_tx_frequency_channel_raw = decode_string_fix(_data_raw_, running_bit_offset, 48)
    nmea2000Message.fields.append(NMEA2000Field('calling_tx_frequency_channel', 'Calling Tx Frequency/Channel', None, None, calling_tx_frequency_channel, calling_tx_frequency_channel_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 48

    # 18:time_of_receipt | Offset: , Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    time_of_receipt_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    time_of_receipt = decode_time(time_of_receipt_raw)
    nmea2000Message.fields.append(NMEA2000Field('time_of_receipt', 'Time of Receipt', "Seconds since midnight", 's', time_of_receipt, time_of_receipt_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 19:date_of_receipt | Offset: , Length: 16, Signed: False Resolution: 1, Field Type: DATE, Match: , PartOfPrimaryKey: ,
    date_of_receipt_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    date_of_receipt = decode_date(date_of_receipt_raw)
    nmea2000Message.fields.append(NMEA2000Field('date_of_receipt', 'Date of Receipt', None, 'd', date_of_receipt, date_of_receipt_raw, PhysicalQuantities.DATE, FieldTypes.DATE, False))
    running_bit_offset += 16

    # 20:dsc_equipment_assigned_message_id | Offset: , Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    dsc_equipment_assigned_message_id = dsc_equipment_assigned_message_id_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('dsc_equipment_assigned_message_id', 'DSC Equipment Assigned Message ID', None, None, dsc_equipment_assigned_message_id, dsc_equipment_assigned_message_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 21:dsc_expansion_field_symbol | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    dsc_expansion_field_symbol_raw = decode_int(_data_raw_, running_bit_offset, 8)
    dsc_expansion_field_symbol = master_dict['DSC_EXPANSION_DATA'].get(dsc_expansion_field_symbol_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('dsc_expansion_field_symbol', 'DSC Expansion Field Symbol', None, None, dsc_expansion_field_symbol, dsc_expansion_field_symbol_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 22:dsc_expansion_field_data | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    dsc_expansion_field_data_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    dsc_expansion_field_data = dsc_expansion_field_data_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('dsc_expansion_field_data', 'DSC Expansion Field Data', None, None, dsc_expansion_field_data, dsc_expansion_field_data_raw, None, FieldTypes.STRING_LAU, False))
    

    return nmea2000Message

def encode_pgn_129808_dscCallInformation(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129808."""
    data_raw = 0
    # dsc_format_symbol | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'dsc_format_symbol')
    if field is None:
        raise Exception("Cant encode this message, missing 'DSC Format Symbol'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DSC_FORMAT(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # dsc_category_symbol | Offset: 8, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'dsc_category_symbol')
    if field is None:
        raise Exception("Cant encode this message, missing 'DSC Category Symbol'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DSC_CATEGORY(field.value)
    data_raw |= (field_value & 0xFF) << 8
    # dsc_message_address | Offset: 16, Length: 40, Resolution: 1, Field Type: DECIMAL
    field = next(f for f in nmea2000Message.fields if f.id == 'dsc_message_address')
    if field is None:
        raise Exception("Cant encode this message, missing 'DSC Message Address'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFF) << 16
    # __1st_telecommand | Offset: 56, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == '__1st_telecommand')
    if field is None:
        raise Exception("Cant encode this message, missing '1st Telecommand'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DSC_FIRST_TELECOMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 56
    # subsequent_communication_mode_or_2nd_telecommand | Offset: 64, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'subsequent_communication_mode_or_2nd_telecommand')
    if field is None:
        raise Exception("Cant encode this message, missing 'Subsequent Communication Mode or 2nd Telecommand'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DSC_SECOND_TELECOMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 64
    # proposed_rx_frequency_channel | Offset: 72, Length: 48, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'proposed_rx_frequency_channel')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proposed Rx Frequency/Channel'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFF) << 72
    # proposed_tx_frequency_channel | Offset: 120, Length: 48, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'proposed_tx_frequency_channel')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proposed Tx Frequency/Channel'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFF) << 120
    raise Exception ("PGN 129808 not supporting encoding for now as Telephone Number is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as Latitude of Vessel Reported is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as Longitude of Vessel Reported is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as Time of Position is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as MMSI of Ship In Distress is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as DSC EOS Symbol is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as Expansion Enabled is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as Reserved is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as Calling Rx Frequency/Channel is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as Calling Tx Frequency/Channel is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as Time of Receipt is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as Date of Receipt is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as DSC Equipment Assigned Message ID is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as DSC Expansion Field Symbol is missing BitLength or BitOffset")
    raise Exception ("PGN 129808 not supporting encoding for now as DSC Expansion Field Data is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_129809() -> bool:
    """Return True if PGN 129809 is a fast PGN."""
    return True
def decode_pgn_129809(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129809."""
    nmea2000Message = NMEA2000Message(129809, 'aisClassBStaticDataMsg24PartA', 'AIS Class B static data (msg 24 Part A)')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:user_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    user_id = user_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('user_id', 'User ID', None, None, user_id, user_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 4:name | Offset: 40, Length: 160, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    name = name_raw = decode_string_fix(_data_raw_, running_bit_offset, 160)
    nmea2000Message.fields.append(NMEA2000Field('name', 'Name', None, None, name, name_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 160

    # 5:ais_transceiver_information | Offset: 200, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 200
    ais_transceiver_information_raw = decode_int(_data_raw_, running_bit_offset, 5)
    ais_transceiver_information = master_dict['AIS_TRANSCEIVER'].get(ais_transceiver_information_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_transceiver_information', 'AIS Transceiver information', None, None, ais_transceiver_information, ais_transceiver_information_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 6:reserved_205 | Offset: 205, Length: 3, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 205
    reserved_205 = reserved_205_raw = decode_int(_data_raw_, running_bit_offset, 3)
    nmea2000Message.fields.append(NMEA2000Field('reserved_205', 'Reserved', None, None, reserved_205, reserved_205_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 3

    # 7:sequence_id | Offset: 208, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 208
    sequence_id = sequence_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sequence_id', 'Sequence ID', None, None, sequence_id, sequence_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_129809(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129809."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 6
    # user_id | Offset: 8, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'user_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'User ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # name | Offset: 40, Length: 160, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Name'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 40
    # ais_transceiver_information | Offset: 200, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_transceiver_information')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS Transceiver information'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TRANSCEIVER(field.value)
    data_raw |= (field_value & 0x1F) << 200
    # reserved_205 | Offset: 205, Length: 3, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_205')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x7) << 205
    # sequence_id | Offset: 208, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sequence_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Sequence ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 208
    return data_raw


def is_fast_pgn_129810() -> bool:
    """Return True if PGN 129810 is a fast PGN."""
    return True
def decode_pgn_129810(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 129810."""
    nmea2000Message = NMEA2000Message(129810, 'aisClassBStaticDataMsg24PartB', 'AIS Class B static data (msg 24 Part B)')
    running_bit_offset = 0
    # 1:message_id | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 6)
    message_id = master_dict['AIS_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:repeat_indicator | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:user_id | Offset: 8, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    user_id = user_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('user_id', 'User ID', None, None, user_id, user_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 4:type_of_ship | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    type_of_ship_raw = decode_int(_data_raw_, running_bit_offset, 8)
    type_of_ship = master_dict['SHIP_TYPE'].get(type_of_ship_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('type_of_ship', 'Type of ship', None, None, type_of_ship, type_of_ship_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:vendor_id | Offset: 48, Length: 56, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    vendor_id = vendor_id_raw = decode_string_fix(_data_raw_, running_bit_offset, 56)
    nmea2000Message.fields.append(NMEA2000Field('vendor_id', 'Vendor ID', None, None, vendor_id, vendor_id_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 56

    # 6:callsign | Offset: 104, Length: 56, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 104
    callsign = callsign_raw = decode_string_fix(_data_raw_, running_bit_offset, 56)
    nmea2000Message.fields.append(NMEA2000Field('callsign', 'Callsign', None, None, callsign, callsign_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 56

    # 7:length | Offset: 160, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 160
    length = length_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('length', 'Length', None, 'm', length, length_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:beam | Offset: 176, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 176
    beam = beam_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('beam', 'Beam', None, 'm', beam, beam_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:position_reference_from_starboard | Offset: 192, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 192
    position_reference_from_starboard = position_reference_from_starboard_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('position_reference_from_starboard', 'Position reference from Starboard', None, 'm', position_reference_from_starboard, position_reference_from_starboard_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 10:position_reference_from_bow | Offset: 208, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 208
    position_reference_from_bow = position_reference_from_bow_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('position_reference_from_bow', 'Position reference from Bow', None, 'm', position_reference_from_bow, position_reference_from_bow_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:mothership_user_id | Offset: 224, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 224
    mothership_user_id = mothership_user_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('mothership_user_id', 'Mothership User ID', None, None, mothership_user_id, mothership_user_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 12:reserved_256 | Offset: 256, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 256
    reserved_256 = reserved_256_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_256', 'Reserved', None, None, reserved_256, reserved_256_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 13:spare | Offset: 258, Length: 2, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 258
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 2

    # 14:gnss_type | Offset: 260, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 260
    gnss_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    gnss_type = master_dict['POSITION_FIX_DEVICE'].get(gnss_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('gnss_type', 'GNSS type', None, None, gnss_type, gnss_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 15:ais_transceiver_information | Offset: 264, Length: 5, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 264
    ais_transceiver_information_raw = decode_int(_data_raw_, running_bit_offset, 5)
    ais_transceiver_information = master_dict['AIS_TRANSCEIVER'].get(ais_transceiver_information_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ais_transceiver_information', 'AIS Transceiver information', None, None, ais_transceiver_information, ais_transceiver_information_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 5

    # 16:reserved_269 | Offset: 269, Length: 3, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 269
    reserved_269 = reserved_269_raw = decode_int(_data_raw_, running_bit_offset, 3)
    nmea2000Message.fields.append(NMEA2000Field('reserved_269', 'Reserved', None, None, reserved_269, reserved_269_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 3

    # 17:sequence_id | Offset: 272, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 272
    sequence_id = sequence_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sequence_id', 'Sequence ID', None, None, sequence_id, sequence_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_129810(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 129810."""
    data_raw = 0
    # message_id | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # repeat_indicator | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 6
    # user_id | Offset: 8, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'user_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'User ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 8
    # type_of_ship | Offset: 40, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'type_of_ship')
    if field is None:
        raise Exception("Cant encode this message, missing 'Type of ship'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SHIP_TYPE(field.value)
    data_raw |= (field_value & 0xFF) << 40
    # vendor_id | Offset: 48, Length: 56, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'vendor_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Vendor ID'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFF) << 48
    # callsign | Offset: 104, Length: 56, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'callsign')
    if field is None:
        raise Exception("Cant encode this message, missing 'Callsign'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFF) << 104
    # length | Offset: 160, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'length')
    if field is None:
        raise Exception("Cant encode this message, missing 'Length'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 160
    
    # beam | Offset: 176, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'beam')
    if field is None:
        raise Exception("Cant encode this message, missing 'Beam'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 176
    
    # position_reference_from_starboard | Offset: 192, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'position_reference_from_starboard')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position reference from Starboard'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 192
    
    # position_reference_from_bow | Offset: 208, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'position_reference_from_bow')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position reference from Bow'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 208
    
    # mothership_user_id | Offset: 224, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'mothership_user_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mothership User ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 224
    # reserved_256 | Offset: 256, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_256')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 256
    # spare | Offset: 258, Length: 2, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 258
    # gnss_type | Offset: 260, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'gnss_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'GNSS type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_POSITION_FIX_DEVICE(field.value)
    data_raw |= (field_value & 0xF) << 260
    # ais_transceiver_information | Offset: 264, Length: 5, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ais_transceiver_information')
    if field is None:
        raise Exception("Cant encode this message, missing 'AIS Transceiver information'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIS_TRANSCEIVER(field.value)
    data_raw |= (field_value & 0x1F) << 264
    # reserved_269 | Offset: 269, Length: 3, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_269')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x7) << 269
    # sequence_id | Offset: 272, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sequence_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Sequence ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 272
    return data_raw


def is_fast_pgn_130052() -> bool:
    """Return True if PGN 130052 is a fast PGN."""
    return True
def decode_pgn_130052(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130052."""
    nmea2000Message = NMEA2000Message(130052, 'loranCTdData', 'Loran-C TD Data')
    running_bit_offset = 0
    # 1:group_repetition_interval__gri_ | Offset: 0, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    group_repetition_interval__gri_ = group_repetition_interval__gri__raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('group_repetition_interval__gri_', 'Group Repetition Interval (GRI)', None, None, group_repetition_interval__gri_, group_repetition_interval__gri__raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:master_range | Offset: 32, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    master_range = master_range_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('master_range', 'Master Range', None, None, master_range, master_range_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 3:v_secondary_td | Offset: 64, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    v_secondary_td = v_secondary_td_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('v_secondary_td', 'V Secondary TD', None, None, v_secondary_td, v_secondary_td_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 4:w_secondary_td | Offset: 96, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 96
    w_secondary_td = w_secondary_td_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('w_secondary_td', 'W Secondary TD', None, None, w_secondary_td, w_secondary_td_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 5:x_secondary_td | Offset: 128, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    x_secondary_td = x_secondary_td_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('x_secondary_td', 'X Secondary TD', None, None, x_secondary_td, x_secondary_td_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:y_secondary_td | Offset: 160, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 160
    y_secondary_td = y_secondary_td_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('y_secondary_td', 'Y Secondary TD', None, None, y_secondary_td, y_secondary_td_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 7:z_secondary_td | Offset: 192, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 192
    z_secondary_td = z_secondary_td_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('z_secondary_td', 'Z Secondary TD', None, None, z_secondary_td, z_secondary_td_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 8:station_status__master | Offset: 224, Length: 4, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 224
    station_status__master_raw = decode_int(_data_raw_, running_bit_offset, 4)
    station_status__master = decode_bit_lookup(station_status__master_raw, master_flags_dict['STATION_STATUS'])
    nmea2000Message.fields.append(NMEA2000Field('station_status__master', 'Station status: Master', None, None, station_status__master, station_status__master_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 4

    # 9:station_status__v | Offset: 228, Length: 4, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 228
    station_status__v_raw = decode_int(_data_raw_, running_bit_offset, 4)
    station_status__v = decode_bit_lookup(station_status__v_raw, master_flags_dict['STATION_STATUS'])
    nmea2000Message.fields.append(NMEA2000Field('station_status__v', 'Station status: V', None, None, station_status__v, station_status__v_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 4

    # 10:station_status__w | Offset: 232, Length: 4, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 232
    station_status__w_raw = decode_int(_data_raw_, running_bit_offset, 4)
    station_status__w = decode_bit_lookup(station_status__w_raw, master_flags_dict['STATION_STATUS'])
    nmea2000Message.fields.append(NMEA2000Field('station_status__w', 'Station status: W', None, None, station_status__w, station_status__w_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 4

    # 11:station_status__x | Offset: 236, Length: 4, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 236
    station_status__x_raw = decode_int(_data_raw_, running_bit_offset, 4)
    station_status__x = decode_bit_lookup(station_status__x_raw, master_flags_dict['STATION_STATUS'])
    nmea2000Message.fields.append(NMEA2000Field('station_status__x', 'Station status: X', None, None, station_status__x, station_status__x_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 4

    # 12:station_status__y | Offset: 240, Length: 4, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 240
    station_status__y_raw = decode_int(_data_raw_, running_bit_offset, 4)
    station_status__y = decode_bit_lookup(station_status__y_raw, master_flags_dict['STATION_STATUS'])
    nmea2000Message.fields.append(NMEA2000Field('station_status__y', 'Station status: Y', None, None, station_status__y, station_status__y_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 4

    # 13:station_status__z | Offset: 244, Length: 4, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 244
    station_status__z_raw = decode_int(_data_raw_, running_bit_offset, 4)
    station_status__z = decode_bit_lookup(station_status__z_raw, master_flags_dict['STATION_STATUS'])
    nmea2000Message.fields.append(NMEA2000Field('station_status__z', 'Station status: Z', None, None, station_status__z, station_status__z_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 4

    # 14:mode | Offset: 248, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 248
    mode_raw = decode_int(_data_raw_, running_bit_offset, 4)
    mode = master_dict['RESIDUAL_MODE'].get(mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('mode', 'Mode', None, None, mode, mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 15:reserved_252 | Offset: 252, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 252
    reserved_252 = reserved_252_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_252', 'Reserved', None, None, reserved_252, reserved_252_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    return nmea2000Message

def encode_pgn_130052(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130052."""
    data_raw = 0
    # group_repetition_interval__gri_ | Offset: 0, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'group_repetition_interval__gri_')
    if field is None:
        raise Exception("Cant encode this message, missing 'Group Repetition Interval (GRI)'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # master_range | Offset: 32, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'master_range')
    if field is None:
        raise Exception("Cant encode this message, missing 'Master Range'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    # v_secondary_td | Offset: 64, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'v_secondary_td')
    if field is None:
        raise Exception("Cant encode this message, missing 'V Secondary TD'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 64
    # w_secondary_td | Offset: 96, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'w_secondary_td')
    if field is None:
        raise Exception("Cant encode this message, missing 'W Secondary TD'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 96
    # x_secondary_td | Offset: 128, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'x_secondary_td')
    if field is None:
        raise Exception("Cant encode this message, missing 'X Secondary TD'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 128
    # y_secondary_td | Offset: 160, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'y_secondary_td')
    if field is None:
        raise Exception("Cant encode this message, missing 'Y Secondary TD'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 160
    # z_secondary_td | Offset: 192, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'z_secondary_td')
    if field is None:
        raise Exception("Cant encode this message, missing 'Z Secondary TD'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 192
    # station_status__master | Offset: 224, Length: 4, Resolution: 1, Field Type: BITLOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'station_status__master')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station status: Master'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 224
    # station_status__v | Offset: 228, Length: 4, Resolution: 1, Field Type: BITLOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'station_status__v')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station status: V'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 228
    # station_status__w | Offset: 232, Length: 4, Resolution: 1, Field Type: BITLOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'station_status__w')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station status: W'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 232
    # station_status__x | Offset: 236, Length: 4, Resolution: 1, Field Type: BITLOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'station_status__x')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station status: X'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 236
    # station_status__y | Offset: 240, Length: 4, Resolution: 1, Field Type: BITLOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'station_status__y')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station status: Y'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 240
    # station_status__z | Offset: 244, Length: 4, Resolution: 1, Field Type: BITLOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'station_status__z')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station status: Z'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 244
    # mode | Offset: 248, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_RESIDUAL_MODE(field.value)
    data_raw |= (field_value & 0xF) << 248
    # reserved_252 | Offset: 252, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_252')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 252
    return data_raw


def is_fast_pgn_130053() -> bool:
    """Return True if PGN 130053 is a fast PGN."""
    return True
def decode_pgn_130053(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130053."""
    nmea2000Message = NMEA2000Message(130053, 'loranCRangeData', 'Loran-C Range Data')
    running_bit_offset = 0
    # 1:group_repetition_interval__gri_ | Offset: 0, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    group_repetition_interval__gri_ = group_repetition_interval__gri__raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('group_repetition_interval__gri_', 'Group Repetition Interval (GRI)', None, None, group_repetition_interval__gri_, group_repetition_interval__gri__raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:master_range | Offset: 32, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    master_range = master_range_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('master_range', 'Master Range', None, None, master_range, master_range_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 3:v_secondary_range | Offset: 64, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    v_secondary_range = v_secondary_range_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('v_secondary_range', 'V Secondary Range', None, None, v_secondary_range, v_secondary_range_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 4:w_secondary_range | Offset: 96, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 96
    w_secondary_range = w_secondary_range_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('w_secondary_range', 'W Secondary Range', None, None, w_secondary_range, w_secondary_range_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 5:x_secondary_range | Offset: 128, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    x_secondary_range = x_secondary_range_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('x_secondary_range', 'X Secondary Range', None, None, x_secondary_range, x_secondary_range_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:y_secondary_range | Offset: 160, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 160
    y_secondary_range = y_secondary_range_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('y_secondary_range', 'Y Secondary Range', None, None, y_secondary_range, y_secondary_range_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 7:z_secondary_range | Offset: 192, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 192
    z_secondary_range = z_secondary_range_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('z_secondary_range', 'Z Secondary Range', None, None, z_secondary_range, z_secondary_range_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 8:station_status__master | Offset: 224, Length: 4, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 224
    station_status__master_raw = decode_int(_data_raw_, running_bit_offset, 4)
    station_status__master = decode_bit_lookup(station_status__master_raw, master_flags_dict['STATION_STATUS'])
    nmea2000Message.fields.append(NMEA2000Field('station_status__master', 'Station status: Master', None, None, station_status__master, station_status__master_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 4

    # 9:station_status__v | Offset: 228, Length: 4, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 228
    station_status__v_raw = decode_int(_data_raw_, running_bit_offset, 4)
    station_status__v = decode_bit_lookup(station_status__v_raw, master_flags_dict['STATION_STATUS'])
    nmea2000Message.fields.append(NMEA2000Field('station_status__v', 'Station status: V', None, None, station_status__v, station_status__v_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 4

    # 10:station_status__w | Offset: 232, Length: 4, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 232
    station_status__w_raw = decode_int(_data_raw_, running_bit_offset, 4)
    station_status__w = decode_bit_lookup(station_status__w_raw, master_flags_dict['STATION_STATUS'])
    nmea2000Message.fields.append(NMEA2000Field('station_status__w', 'Station status: W', None, None, station_status__w, station_status__w_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 4

    # 11:station_status__x | Offset: 236, Length: 4, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 236
    station_status__x_raw = decode_int(_data_raw_, running_bit_offset, 4)
    station_status__x = decode_bit_lookup(station_status__x_raw, master_flags_dict['STATION_STATUS'])
    nmea2000Message.fields.append(NMEA2000Field('station_status__x', 'Station status: X', None, None, station_status__x, station_status__x_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 4

    # 12:station_status__y | Offset: 240, Length: 4, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 240
    station_status__y_raw = decode_int(_data_raw_, running_bit_offset, 4)
    station_status__y = decode_bit_lookup(station_status__y_raw, master_flags_dict['STATION_STATUS'])
    nmea2000Message.fields.append(NMEA2000Field('station_status__y', 'Station status: Y', None, None, station_status__y, station_status__y_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 4

    # 13:station_status__z | Offset: 244, Length: 4, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 244
    station_status__z_raw = decode_int(_data_raw_, running_bit_offset, 4)
    station_status__z = decode_bit_lookup(station_status__z_raw, master_flags_dict['STATION_STATUS'])
    nmea2000Message.fields.append(NMEA2000Field('station_status__z', 'Station status: Z', None, None, station_status__z, station_status__z_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 4

    # 14:mode | Offset: 248, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 248
    mode_raw = decode_int(_data_raw_, running_bit_offset, 4)
    mode = master_dict['RESIDUAL_MODE'].get(mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('mode', 'Mode', None, None, mode, mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 15:reserved_252 | Offset: 252, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 252
    reserved_252 = reserved_252_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_252', 'Reserved', None, None, reserved_252, reserved_252_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    return nmea2000Message

def encode_pgn_130053(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130053."""
    data_raw = 0
    # group_repetition_interval__gri_ | Offset: 0, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'group_repetition_interval__gri_')
    if field is None:
        raise Exception("Cant encode this message, missing 'Group Repetition Interval (GRI)'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # master_range | Offset: 32, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'master_range')
    if field is None:
        raise Exception("Cant encode this message, missing 'Master Range'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    # v_secondary_range | Offset: 64, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'v_secondary_range')
    if field is None:
        raise Exception("Cant encode this message, missing 'V Secondary Range'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 64
    # w_secondary_range | Offset: 96, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'w_secondary_range')
    if field is None:
        raise Exception("Cant encode this message, missing 'W Secondary Range'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 96
    # x_secondary_range | Offset: 128, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'x_secondary_range')
    if field is None:
        raise Exception("Cant encode this message, missing 'X Secondary Range'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 128
    # y_secondary_range | Offset: 160, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'y_secondary_range')
    if field is None:
        raise Exception("Cant encode this message, missing 'Y Secondary Range'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 160
    # z_secondary_range | Offset: 192, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'z_secondary_range')
    if field is None:
        raise Exception("Cant encode this message, missing 'Z Secondary Range'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 192
    # station_status__master | Offset: 224, Length: 4, Resolution: 1, Field Type: BITLOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'station_status__master')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station status: Master'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 224
    # station_status__v | Offset: 228, Length: 4, Resolution: 1, Field Type: BITLOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'station_status__v')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station status: V'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 228
    # station_status__w | Offset: 232, Length: 4, Resolution: 1, Field Type: BITLOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'station_status__w')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station status: W'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 232
    # station_status__x | Offset: 236, Length: 4, Resolution: 1, Field Type: BITLOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'station_status__x')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station status: X'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 236
    # station_status__y | Offset: 240, Length: 4, Resolution: 1, Field Type: BITLOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'station_status__y')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station status: Y'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 240
    # station_status__z | Offset: 244, Length: 4, Resolution: 1, Field Type: BITLOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'station_status__z')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station status: Z'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 244
    # mode | Offset: 248, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_RESIDUAL_MODE(field.value)
    data_raw |= (field_value & 0xF) << 248
    # reserved_252 | Offset: 252, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_252')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 252
    return data_raw


def is_fast_pgn_130054() -> bool:
    """Return True if PGN 130054 is a fast PGN."""
    return True
def decode_pgn_130054(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130054."""
    nmea2000Message = NMEA2000Message(130054, 'loranCSignalData', 'Loran-C Signal Data')
    running_bit_offset = 0
    # 1:group_repetition_interval__gri_ | Offset: 0, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    group_repetition_interval__gri_ = group_repetition_interval__gri__raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('group_repetition_interval__gri_', 'Group Repetition Interval (GRI)', None, None, group_repetition_interval__gri_, group_repetition_interval__gri__raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:station_identifier | Offset: 32, Length: 8, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    station_identifier = station_identifier_raw = decode_string_fix(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('station_identifier', 'Station identifier', None, None, station_identifier, station_identifier_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 8

    # 3:station_snr | Offset: 40, Length: 16, Signed: True Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    station_snr = station_snr_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('station_snr', 'Station SNR', None, 'dB', station_snr, station_snr_raw, PhysicalQuantities.SIGNAL_TO_NOISE_RATIO, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:station_ecd | Offset: 56, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    station_ecd = station_ecd_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('station_ecd', 'Station ECD', None, None, station_ecd, station_ecd_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 5:station_asf | Offset: 88, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    station_asf = station_asf_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('station_asf', 'Station ASF', None, None, station_asf, station_asf_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_130054(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130054."""
    data_raw = 0
    # group_repetition_interval__gri_ | Offset: 0, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'group_repetition_interval__gri_')
    if field is None:
        raise Exception("Cant encode this message, missing 'Group Repetition Interval (GRI)'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # station_identifier | Offset: 32, Length: 8, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'station_identifier')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station identifier'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFF) << 32
    # station_snr | Offset: 40, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'station_snr')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station SNR'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 40
    
    # station_ecd | Offset: 56, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'station_ecd')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station ECD'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 56
    # station_asf | Offset: 88, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'station_asf')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station ASF'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 88
    return data_raw


def is_fast_pgn_130060() -> bool:
    """Return True if PGN 130060 is a fast PGN."""
    return True
def decode_pgn_130060(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130060."""
    nmea2000Message = NMEA2000Message(130060, 'label', 'Label')
    running_bit_offset = 0
    # 1:hardware_channel_id | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    hardware_channel_id = hardware_channel_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('hardware_channel_id', 'Hardware Channel ID', None, None, hardware_channel_id, hardware_channel_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:pgn | Offset: 8, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    pgn = pgn_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('pgn', 'PGN', None, None, pgn, pgn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    # 3:data_source_instance_field_number | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    data_source_instance_field_number = data_source_instance_field_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_instance_field_number', 'Data Source Instance Field Number', None, None, data_source_instance_field_number, data_source_instance_field_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:data_source_instance_value | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    data_source_instance_value = data_source_instance_value_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_instance_value', 'Data Source Instance Value', None, None, data_source_instance_value, data_source_instance_value_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:secondary_enumeration_field_number | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    secondary_enumeration_field_number = secondary_enumeration_field_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('secondary_enumeration_field_number', 'Secondary Enumeration Field Number', None, None, secondary_enumeration_field_number, secondary_enumeration_field_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:secondary_enumeration_field_value | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    secondary_enumeration_field_value = secondary_enumeration_field_value_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('secondary_enumeration_field_value', 'Secondary Enumeration Field Value', None, None, secondary_enumeration_field_value, secondary_enumeration_field_value_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:parameter_field_number | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    parameter_field_number = parameter_field_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('parameter_field_number', 'Parameter Field Number', None, None, parameter_field_number, parameter_field_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:label | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    label_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    label = label_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('label', 'Label', None, None, label, label_raw, None, FieldTypes.STRING_LAU, False))
    

    return nmea2000Message

def encode_pgn_130060(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130060."""
    data_raw = 0
    # hardware_channel_id | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'hardware_channel_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Hardware Channel ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # pgn | Offset: 8, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pgn')
    if field is None:
        raise Exception("Cant encode this message, missing 'PGN'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 8
    # data_source_instance_field_number | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_instance_field_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Instance Field Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # data_source_instance_value | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_instance_value')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Instance Value'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # secondary_enumeration_field_number | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'secondary_enumeration_field_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Secondary Enumeration Field Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # secondary_enumeration_field_value | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'secondary_enumeration_field_value')
    if field is None:
        raise Exception("Cant encode this message, missing 'Secondary Enumeration Field Value'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    # parameter_field_number | Offset: 64, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'parameter_field_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Parameter Field Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 64
    raise Exception ("PGN 130060 not supporting encoding for now as Label is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130061() -> bool:
    """Return True if PGN 130061 is a fast PGN."""
    return True
def decode_pgn_130061(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130061."""
    nmea2000Message = NMEA2000Message(130061, 'channelSourceConfiguration', 'Channel Source Configuration')
    running_bit_offset = 0
    # 1:data_source_channel_id | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    data_source_channel_id = data_source_channel_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_channel_id', 'Data Source Channel ID', None, None, data_source_channel_id, data_source_channel_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:source_selection_status | Offset: 8, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    source_selection_status = source_selection_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('source_selection_status', 'Source Selection Status', None, None, source_selection_status, source_selection_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 3:reserved_10 | Offset: 10, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 10
    reserved_10 = reserved_10_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_10', 'Reserved', None, None, reserved_10, reserved_10_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 4:name_selection_criteria_mask | Offset: 12, Length: 12, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 12
    name_selection_criteria_mask = name_selection_criteria_mask_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 12))
    nmea2000Message.fields.append(NMEA2000Field('name_selection_criteria_mask', 'NAME Selection Criteria Mask', None, None, name_selection_criteria_mask, name_selection_criteria_mask_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 12

    # 5:source_name | Offset: 24, Length: 64, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    source_name = source_name_raw = decode_number(_data_raw_, running_bit_offset, 64, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('source_name', 'Source NAME', None, None, source_name, source_name_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 64

    # 6:pgn | Offset: 88, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    pgn = pgn_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('pgn', 'PGN', None, None, pgn, pgn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    # 7:data_source_instance_field_number | Offset: 112, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    data_source_instance_field_number = data_source_instance_field_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_instance_field_number', 'Data Source Instance Field Number', None, None, data_source_instance_field_number, data_source_instance_field_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:data_source_instance_value | Offset: 120, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    data_source_instance_value = data_source_instance_value_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('data_source_instance_value', 'Data Source Instance Value', None, None, data_source_instance_value, data_source_instance_value_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:secondary_enumeration_field_number | Offset: 128, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    secondary_enumeration_field_number = secondary_enumeration_field_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('secondary_enumeration_field_number', 'Secondary Enumeration Field Number', None, None, secondary_enumeration_field_number, secondary_enumeration_field_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:secondary_enumeration_field_value | Offset: 136, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 136
    secondary_enumeration_field_value = secondary_enumeration_field_value_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('secondary_enumeration_field_value', 'Secondary Enumeration Field Value', None, None, secondary_enumeration_field_value, secondary_enumeration_field_value_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 11:parameter_field_number | Offset: 144, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    parameter_field_number = parameter_field_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('parameter_field_number', 'Parameter Field Number', None, None, parameter_field_number, parameter_field_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130061(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130061."""
    data_raw = 0
    # data_source_channel_id | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_channel_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Channel ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # source_selection_status | Offset: 8, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'source_selection_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source Selection Status'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 8
    # reserved_10 | Offset: 10, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_10')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 10
    # name_selection_criteria_mask | Offset: 12, Length: 12, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'name_selection_criteria_mask')
    if field is None:
        raise Exception("Cant encode this message, missing 'NAME Selection Criteria Mask'")
    field_value = field.value
    data_raw |= (field_value & 0xFFF) << 12
    # source_name | Offset: 24, Length: 64, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'source_name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source NAME'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFF) << 24
    # pgn | Offset: 88, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pgn')
    if field is None:
        raise Exception("Cant encode this message, missing 'PGN'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 88
    # data_source_instance_field_number | Offset: 112, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_instance_field_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Instance Field Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 112
    # data_source_instance_value | Offset: 120, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'data_source_instance_value')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Source Instance Value'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 120
    # secondary_enumeration_field_number | Offset: 128, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'secondary_enumeration_field_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Secondary Enumeration Field Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 128
    # secondary_enumeration_field_value | Offset: 136, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'secondary_enumeration_field_value')
    if field is None:
        raise Exception("Cant encode this message, missing 'Secondary Enumeration Field Value'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 136
    # parameter_field_number | Offset: 144, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'parameter_field_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Parameter Field Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 144
    return data_raw


def is_fast_pgn_130064() -> bool:
    """Return True if PGN 130064 is a fast PGN."""
    return True
def decode_pgn_130064(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130064."""
    nmea2000Message = NMEA2000Message(130064, 'routeAndWpServiceDatabaseList', 'Route and WP Service - Database List')
    running_bit_offset = 0
    # 1:start_database_id | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    start_database_id = start_database_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('start_database_id', 'Start Database ID', None, None, start_database_id, start_database_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:nitems | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    nitems = nitems_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('nitems', 'nItems', None, None, nitems, nitems_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:number_of_databases_available | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    number_of_databases_available = number_of_databases_available_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_databases_available', 'Number of Databases Available', None, None, number_of_databases_available, number_of_databases_available_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:database_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    database_id = database_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('database_id', 'Database ID', None, None, database_id, database_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:database_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    database_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    database_name = database_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('database_name', 'Database Name', None, None, database_name, database_name_raw, None, FieldTypes.STRING_LAU, False))
    

    # 6:database_timestamp | Offset: , Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    database_timestamp_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    database_timestamp = decode_time(database_timestamp_raw)
    nmea2000Message.fields.append(NMEA2000Field('database_timestamp', 'Database Timestamp', "Seconds since midnight", 's', database_timestamp, database_timestamp_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 7:database_datestamp | Offset: , Length: 16, Signed: False Resolution: 1, Field Type: DATE, Match: , PartOfPrimaryKey: ,
    database_datestamp_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    database_datestamp = decode_date(database_datestamp_raw)
    nmea2000Message.fields.append(NMEA2000Field('database_datestamp', 'Database Datestamp', None, 'd', database_datestamp, database_datestamp_raw, PhysicalQuantities.DATE, FieldTypes.DATE, False))
    running_bit_offset += 16

    # 8:wp_position_resolution | Offset: , Length: 6, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    wp_position_resolution = wp_position_resolution_raw = decode_number(_data_raw_, running_bit_offset, 6, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('wp_position_resolution', 'WP Position Resolution', None, None, wp_position_resolution, wp_position_resolution_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 6

    # 9:reserved_ | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    reserved_ = reserved__raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_', 'Reserved', None, None, reserved_, reserved__raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 10:number_of_routes_in_database | Offset: , Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    number_of_routes_in_database = number_of_routes_in_database_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_routes_in_database', 'Number of Routes in Database', None, None, number_of_routes_in_database, number_of_routes_in_database_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:number_of_wps_in_database | Offset: , Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    number_of_wps_in_database = number_of_wps_in_database_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_wps_in_database', 'Number of WPs in Database', None, None, number_of_wps_in_database, number_of_wps_in_database_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 12:number_of_bytes_in_database | Offset: , Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    number_of_bytes_in_database = number_of_bytes_in_database_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_bytes_in_database', 'Number of Bytes in Database', None, None, number_of_bytes_in_database, number_of_bytes_in_database_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_130064(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130064."""
    data_raw = 0
    # start_database_id | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'start_database_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Start Database ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # nitems | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'nitems')
    if field is None:
        raise Exception("Cant encode this message, missing 'nItems'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # number_of_databases_available | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_databases_available')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of Databases Available'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # database_id | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'database_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Database ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    raise Exception ("PGN 130064 not supporting encoding for now as Database Name is missing BitLength or BitOffset")
    raise Exception ("PGN 130064 not supporting encoding for now as Database Timestamp is missing BitLength or BitOffset")
    raise Exception ("PGN 130064 not supporting encoding for now as Database Datestamp is missing BitLength or BitOffset")
    raise Exception ("PGN 130064 not supporting encoding for now as WP Position Resolution is missing BitLength or BitOffset")
    raise Exception ("PGN 130064 not supporting encoding for now as Reserved is missing BitLength or BitOffset")
    raise Exception ("PGN 130064 not supporting encoding for now as Number of Routes in Database is missing BitLength or BitOffset")
    raise Exception ("PGN 130064 not supporting encoding for now as Number of WPs in Database is missing BitLength or BitOffset")
    raise Exception ("PGN 130064 not supporting encoding for now as Number of Bytes in Database is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130065() -> bool:
    """Return True if PGN 130065 is a fast PGN."""
    return True
def decode_pgn_130065(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130065."""
    nmea2000Message = NMEA2000Message(130065, 'routeAndWpServiceRouteList', 'Route and WP Service - Route List')
    running_bit_offset = 0
    # 1:start_route_id | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    start_route_id = start_route_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('start_route_id', 'Start Route ID', None, None, start_route_id, start_route_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:nitems | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    nitems = nitems_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('nitems', 'nItems', None, None, nitems, nitems_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:number_of_routes_in_database | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    number_of_routes_in_database = number_of_routes_in_database_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_routes_in_database', 'Number of Routes in Database', None, None, number_of_routes_in_database, number_of_routes_in_database_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:database_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    database_id = database_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('database_id', 'Database ID', None, None, database_id, database_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:route_id | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    route_id = route_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('route_id', 'Route ID', None, None, route_id, route_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:route_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    route_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    route_name = route_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('route_name', 'Route Name', None, None, route_name, route_name_raw, None, FieldTypes.STRING_LAU, False))
    

    # 7:reserved_ | Offset: , Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    reserved_ = reserved__raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_', 'Reserved', None, None, reserved_, reserved__raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 8:wp_identification_method | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    wp_identification_method = wp_identification_method_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('wp_identification_method', 'WP Identification Method', None, None, wp_identification_method, wp_identification_method_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 9:route_status | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    route_status = route_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('route_status', 'Route Status', None, None, route_status, route_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    return nmea2000Message

def encode_pgn_130065(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130065."""
    data_raw = 0
    # start_route_id | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'start_route_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Start Route ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # nitems | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'nitems')
    if field is None:
        raise Exception("Cant encode this message, missing 'nItems'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # number_of_routes_in_database | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_routes_in_database')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of Routes in Database'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # database_id | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'database_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Database ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # route_id | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'route_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Route ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    raise Exception ("PGN 130065 not supporting encoding for now as Route Name is missing BitLength or BitOffset")
    raise Exception ("PGN 130065 not supporting encoding for now as Reserved is missing BitLength or BitOffset")
    raise Exception ("PGN 130065 not supporting encoding for now as WP Identification Method is missing BitLength or BitOffset")
    raise Exception ("PGN 130065 not supporting encoding for now as Route Status is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130066() -> bool:
    """Return True if PGN 130066 is a fast PGN."""
    return True
def decode_pgn_130066(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130066."""
    nmea2000Message = NMEA2000Message(130066, 'routeAndWpServiceRouteWpListAttributes', 'Route and WP Service - Route/WP-List Attributes')
    running_bit_offset = 0
    # 1:database_id | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    database_id = database_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('database_id', 'Database ID', None, None, database_id, database_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:route_id | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    route_id = route_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('route_id', 'Route ID', None, None, route_id, route_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:route_wp_list_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    route_wp_list_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    route_wp_list_name = route_wp_list_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('route_wp_list_name', 'Route/WP-List Name', None, None, route_wp_list_name, route_wp_list_name_raw, None, FieldTypes.STRING_LAU, False))
    

    # 4:route_wp_list_timestamp | Offset: , Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    route_wp_list_timestamp_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    route_wp_list_timestamp = decode_time(route_wp_list_timestamp_raw)
    nmea2000Message.fields.append(NMEA2000Field('route_wp_list_timestamp', 'Route/WP-List Timestamp', "Seconds since midnight", 's', route_wp_list_timestamp, route_wp_list_timestamp_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 5:route_wp_list_datestamp | Offset: , Length: 16, Signed: False Resolution: 1, Field Type: DATE, Match: , PartOfPrimaryKey: ,
    route_wp_list_datestamp_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    route_wp_list_datestamp = decode_date(route_wp_list_datestamp_raw)
    nmea2000Message.fields.append(NMEA2000Field('route_wp_list_datestamp', 'Route/WP-List Datestamp', None, 'd', route_wp_list_datestamp, route_wp_list_datestamp_raw, PhysicalQuantities.DATE, FieldTypes.DATE, False))
    running_bit_offset += 16

    # 6:change_at_last_timestamp | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    change_at_last_timestamp = change_at_last_timestamp_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('change_at_last_timestamp', 'Change at Last Timestamp', None, None, change_at_last_timestamp, change_at_last_timestamp_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:number_of_wps_in_the_route_wp_list | Offset: , Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    number_of_wps_in_the_route_wp_list = number_of_wps_in_the_route_wp_list_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_wps_in_the_route_wp_list', 'Number of WPs in the Route/WP-List', None, None, number_of_wps_in_the_route_wp_list, number_of_wps_in_the_route_wp_list_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:critical_supplementary_parameters | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    critical_supplementary_parameters = critical_supplementary_parameters_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('critical_supplementary_parameters', 'Critical supplementary parameters', None, None, critical_supplementary_parameters, critical_supplementary_parameters_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:navigation_method | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    navigation_method = navigation_method_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('navigation_method', 'Navigation Method', None, None, navigation_method, navigation_method_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 10:wp_identification_method | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    wp_identification_method = wp_identification_method_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('wp_identification_method', 'WP Identification Method', None, None, wp_identification_method, wp_identification_method_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 11:route_status | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    route_status = route_status_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('route_status', 'Route Status', None, None, route_status, route_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 12:xte_limit_for_the_route | Offset: , Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    xte_limit_for_the_route = xte_limit_for_the_route_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('xte_limit_for_the_route', 'XTE Limit for the Route', None, None, xte_limit_for_the_route, xte_limit_for_the_route_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 13:reserved_ | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    reserved_ = reserved__raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_', 'Reserved', None, None, reserved_, reserved__raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    return nmea2000Message

def encode_pgn_130066(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130066."""
    data_raw = 0
    # database_id | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'database_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Database ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # route_id | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'route_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Route ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    raise Exception ("PGN 130066 not supporting encoding for now as Route/WP-List Name is missing BitLength or BitOffset")
    raise Exception ("PGN 130066 not supporting encoding for now as Route/WP-List Timestamp is missing BitLength or BitOffset")
    raise Exception ("PGN 130066 not supporting encoding for now as Route/WP-List Datestamp is missing BitLength or BitOffset")
    raise Exception ("PGN 130066 not supporting encoding for now as Change at Last Timestamp is missing BitLength or BitOffset")
    raise Exception ("PGN 130066 not supporting encoding for now as Number of WPs in the Route/WP-List is missing BitLength or BitOffset")
    raise Exception ("PGN 130066 not supporting encoding for now as Critical supplementary parameters is missing BitLength or BitOffset")
    raise Exception ("PGN 130066 not supporting encoding for now as Navigation Method is missing BitLength or BitOffset")
    raise Exception ("PGN 130066 not supporting encoding for now as WP Identification Method is missing BitLength or BitOffset")
    raise Exception ("PGN 130066 not supporting encoding for now as Route Status is missing BitLength or BitOffset")
    raise Exception ("PGN 130066 not supporting encoding for now as XTE Limit for the Route is missing BitLength or BitOffset")
    raise Exception ("PGN 130066 not supporting encoding for now as Reserved is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130067() -> bool:
    """Return True if PGN 130067 is a fast PGN."""
    return True
def decode_pgn_130067(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130067."""
    nmea2000Message = NMEA2000Message(130067, 'routeAndWpServiceRouteWpNamePosition', 'Route and WP Service - Route - WP Name & Position')
    running_bit_offset = 0
    # 1:start_rps_ | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    start_rps_ = start_rps__raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('start_rps_', 'Start RPS#', None, None, start_rps_, start_rps__raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:nitems | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    nitems = nitems_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('nitems', 'nItems', None, None, nitems, nitems_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:number_of_wps_in_the_route_wp_list | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    number_of_wps_in_the_route_wp_list = number_of_wps_in_the_route_wp_list_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_wps_in_the_route_wp_list', 'Number of WPs in the Route/WP-List', None, None, number_of_wps_in_the_route_wp_list, number_of_wps_in_the_route_wp_list_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:database_id | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    database_id = database_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('database_id', 'Database ID', None, None, database_id, database_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:route_id | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    route_id = route_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('route_id', 'Route ID', None, None, route_id, route_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:wp_id | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    wp_id = wp_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('wp_id', 'WP ID', None, None, wp_id, wp_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:wp_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    wp_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    wp_name = wp_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('wp_name', 'WP Name', None, None, wp_name, wp_name_raw, None, FieldTypes.STRING_LAU, False))
    

    # 8:wp_latitude | Offset: , Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    wp_latitude = wp_latitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('wp_latitude', 'WP Latitude', None, 'deg', wp_latitude, wp_latitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 9:wp_longitude | Offset: , Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    wp_longitude = wp_longitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('wp_longitude', 'WP Longitude', None, 'deg', wp_longitude, wp_longitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_130067(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130067."""
    data_raw = 0
    # start_rps_ | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'start_rps_')
    if field is None:
        raise Exception("Cant encode this message, missing 'Start RPS#'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # nitems | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'nitems')
    if field is None:
        raise Exception("Cant encode this message, missing 'nItems'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # number_of_wps_in_the_route_wp_list | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_wps_in_the_route_wp_list')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of WPs in the Route/WP-List'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # database_id | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'database_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Database ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # route_id | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'route_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Route ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # wp_id | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'wp_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'WP ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    raise Exception ("PGN 130067 not supporting encoding for now as WP Name is missing BitLength or BitOffset")
    raise Exception ("PGN 130067 not supporting encoding for now as WP Latitude is missing BitLength or BitOffset")
    raise Exception ("PGN 130067 not supporting encoding for now as WP Longitude is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130068() -> bool:
    """Return True if PGN 130068 is a fast PGN."""
    return True
def decode_pgn_130068(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130068."""
    nmea2000Message = NMEA2000Message(130068, 'routeAndWpServiceRouteWpName', 'Route and WP Service - Route - WP Name')
    running_bit_offset = 0
    # 1:start_rps_ | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    start_rps_ = start_rps__raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('start_rps_', 'Start RPS#', None, None, start_rps_, start_rps__raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:nitems | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    nitems = nitems_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('nitems', 'nItems', None, None, nitems, nitems_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:number_of_wps_in_the_route_wp_list | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    number_of_wps_in_the_route_wp_list = number_of_wps_in_the_route_wp_list_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_wps_in_the_route_wp_list', 'Number of WPs in the Route/WP-List', None, None, number_of_wps_in_the_route_wp_list, number_of_wps_in_the_route_wp_list_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:database_id | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    database_id = database_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('database_id', 'Database ID', None, None, database_id, database_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:route_id | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    route_id = route_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('route_id', 'Route ID', None, None, route_id, route_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:wp_id | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    wp_id = wp_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('wp_id', 'WP ID', None, None, wp_id, wp_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:wp_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    wp_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    wp_name = wp_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('wp_name', 'WP Name', None, None, wp_name, wp_name_raw, None, FieldTypes.STRING_LAU, False))
    

    return nmea2000Message

def encode_pgn_130068(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130068."""
    data_raw = 0
    # start_rps_ | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'start_rps_')
    if field is None:
        raise Exception("Cant encode this message, missing 'Start RPS#'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # nitems | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'nitems')
    if field is None:
        raise Exception("Cant encode this message, missing 'nItems'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # number_of_wps_in_the_route_wp_list | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_wps_in_the_route_wp_list')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of WPs in the Route/WP-List'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # database_id | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'database_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Database ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # route_id | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'route_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Route ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # wp_id | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'wp_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'WP ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    raise Exception ("PGN 130068 not supporting encoding for now as WP Name is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130069() -> bool:
    """Return True if PGN 130069 is a fast PGN."""
    return True
def decode_pgn_130069(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130069."""
    nmea2000Message = NMEA2000Message(130069, 'routeAndWpServiceXteLimitNavigationMethod', 'Route and WP Service - XTE Limit & Navigation Method')
    running_bit_offset = 0
    # 1:start_rps_ | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    start_rps_ = start_rps__raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('start_rps_', 'Start RPS#', None, None, start_rps_, start_rps__raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:nitems | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    nitems = nitems_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('nitems', 'nItems', None, None, nitems, nitems_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:number_of_wps_with_a_specific_xte_limit_or_nav__method | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    number_of_wps_with_a_specific_xte_limit_or_nav__method = number_of_wps_with_a_specific_xte_limit_or_nav__method_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_wps_with_a_specific_xte_limit_or_nav__method', 'Number of WPs with a specific XTE Limit or Nav. Method', None, None, number_of_wps_with_a_specific_xte_limit_or_nav__method, number_of_wps_with_a_specific_xte_limit_or_nav__method_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:database_id | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    database_id = database_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('database_id', 'Database ID', None, None, database_id, database_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:route_id | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    route_id = route_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('route_id', 'Route ID', None, None, route_id, route_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:rps_ | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    rps_ = rps__raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('rps_', 'RPS#', None, None, rps_, rps__raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:xte_limit_in_the_leg_after_wp | Offset: 56, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    xte_limit_in_the_leg_after_wp = xte_limit_in_the_leg_after_wp_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('xte_limit_in_the_leg_after_wp', 'XTE limit in the leg after WP', None, None, xte_limit_in_the_leg_after_wp, xte_limit_in_the_leg_after_wp_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:nav__method_in_the_leg_after_wp | Offset: 72, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    nav__method_in_the_leg_after_wp = nav__method_in_the_leg_after_wp_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('nav__method_in_the_leg_after_wp', 'Nav. Method in the leg after WP', None, None, nav__method_in_the_leg_after_wp, nav__method_in_the_leg_after_wp_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 9:reserved_76 | Offset: 76, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 76
    reserved_76 = reserved_76_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_76', 'Reserved', None, None, reserved_76, reserved_76_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    return nmea2000Message

def encode_pgn_130069(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130069."""
    data_raw = 0
    # start_rps_ | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'start_rps_')
    if field is None:
        raise Exception("Cant encode this message, missing 'Start RPS#'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # nitems | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'nitems')
    if field is None:
        raise Exception("Cant encode this message, missing 'nItems'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # number_of_wps_with_a_specific_xte_limit_or_nav__method | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_wps_with_a_specific_xte_limit_or_nav__method')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of WPs with a specific XTE Limit or Nav. Method'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # database_id | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'database_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Database ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # route_id | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'route_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Route ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # rps_ | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'rps_')
    if field is None:
        raise Exception("Cant encode this message, missing 'RPS#'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # xte_limit_in_the_leg_after_wp | Offset: 56, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'xte_limit_in_the_leg_after_wp')
    if field is None:
        raise Exception("Cant encode this message, missing 'XTE limit in the leg after WP'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 56
    # nav__method_in_the_leg_after_wp | Offset: 72, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'nav__method_in_the_leg_after_wp')
    if field is None:
        raise Exception("Cant encode this message, missing 'Nav. Method in the leg after WP'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 72
    # reserved_76 | Offset: 76, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_76')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 76
    return data_raw


def is_fast_pgn_130070() -> bool:
    """Return True if PGN 130070 is a fast PGN."""
    return True
def decode_pgn_130070(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130070."""
    nmea2000Message = NMEA2000Message(130070, 'routeAndWpServiceWpComment', 'Route and WP Service - WP Comment')
    running_bit_offset = 0
    # 1:start_id | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    start_id = start_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('start_id', 'Start ID', None, None, start_id, start_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:nitems | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    nitems = nitems_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('nitems', 'nItems', None, None, nitems, nitems_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:number_of_wps_with_comments | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    number_of_wps_with_comments = number_of_wps_with_comments_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_wps_with_comments', 'Number of WPs with Comments', None, None, number_of_wps_with_comments, number_of_wps_with_comments_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:database_id | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    database_id = database_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('database_id', 'Database ID', None, None, database_id, database_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:route_id | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    route_id = route_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('route_id', 'Route ID', None, None, route_id, route_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:wp_id___rps_ | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    wp_id___rps_ = wp_id___rps__raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('wp_id___rps_', 'WP ID / RPS#', None, None, wp_id___rps_, wp_id___rps__raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:comment | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    comment_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    comment = comment_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('comment', 'Comment', None, None, comment, comment_raw, None, FieldTypes.STRING_LAU, False))
    

    return nmea2000Message

def encode_pgn_130070(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130070."""
    data_raw = 0
    # start_id | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'start_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Start ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # nitems | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'nitems')
    if field is None:
        raise Exception("Cant encode this message, missing 'nItems'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # number_of_wps_with_comments | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_wps_with_comments')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of WPs with Comments'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # database_id | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'database_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Database ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # route_id | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'route_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Route ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # wp_id___rps_ | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'wp_id___rps_')
    if field is None:
        raise Exception("Cant encode this message, missing 'WP ID / RPS#'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    raise Exception ("PGN 130070 not supporting encoding for now as Comment is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130071() -> bool:
    """Return True if PGN 130071 is a fast PGN."""
    return True
def decode_pgn_130071(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130071."""
    nmea2000Message = NMEA2000Message(130071, 'routeAndWpServiceRouteComment', 'Route and WP Service - Route Comment')
    running_bit_offset = 0
    # 1:start_route_id | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    start_route_id = start_route_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('start_route_id', 'Start Route ID', None, None, start_route_id, start_route_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:nitems | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    nitems = nitems_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('nitems', 'nItems', None, None, nitems, nitems_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:number_of_routes_with_comments | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    number_of_routes_with_comments = number_of_routes_with_comments_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_routes_with_comments', 'Number of Routes with Comments', None, None, number_of_routes_with_comments, number_of_routes_with_comments_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:database_id | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    database_id = database_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('database_id', 'Database ID', None, None, database_id, database_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:route_id | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    route_id = route_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('route_id', 'Route ID', None, None, route_id, route_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:comment | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    comment_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    comment = comment_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('comment', 'Comment', None, None, comment, comment_raw, None, FieldTypes.STRING_LAU, False))
    

    return nmea2000Message

def encode_pgn_130071(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130071."""
    data_raw = 0
    # start_route_id | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'start_route_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Start Route ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # nitems | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'nitems')
    if field is None:
        raise Exception("Cant encode this message, missing 'nItems'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # number_of_routes_with_comments | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_routes_with_comments')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of Routes with Comments'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # database_id | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'database_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Database ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # route_id | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'route_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Route ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    raise Exception ("PGN 130071 not supporting encoding for now as Comment is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130072() -> bool:
    """Return True if PGN 130072 is a fast PGN."""
    return True
def decode_pgn_130072(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130072."""
    nmea2000Message = NMEA2000Message(130072, 'routeAndWpServiceDatabaseComment', 'Route and WP Service - Database Comment')
    running_bit_offset = 0
    # 1:start_database_id | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    start_database_id = start_database_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('start_database_id', 'Start Database ID', None, None, start_database_id, start_database_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:nitems | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    nitems = nitems_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('nitems', 'nItems', None, None, nitems, nitems_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:number_of_databases_with_comments | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    number_of_databases_with_comments = number_of_databases_with_comments_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_databases_with_comments', 'Number of Databases with Comments', None, None, number_of_databases_with_comments, number_of_databases_with_comments_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:database_id | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    database_id = database_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('database_id', 'Database ID', None, None, database_id, database_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:comment | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    comment_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    comment = comment_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('comment', 'Comment', None, None, comment, comment_raw, None, FieldTypes.STRING_LAU, False))
    

    return nmea2000Message

def encode_pgn_130072(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130072."""
    data_raw = 0
    # start_database_id | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'start_database_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Start Database ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # nitems | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'nitems')
    if field is None:
        raise Exception("Cant encode this message, missing 'nItems'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # number_of_databases_with_comments | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_databases_with_comments')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of Databases with Comments'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # database_id | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'database_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Database ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    raise Exception ("PGN 130072 not supporting encoding for now as Comment is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130073() -> bool:
    """Return True if PGN 130073 is a fast PGN."""
    return True
def decode_pgn_130073(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130073."""
    nmea2000Message = NMEA2000Message(130073, 'routeAndWpServiceRadiusOfTurn', 'Route and WP Service - Radius of Turn')
    running_bit_offset = 0
    # 1:start_rps_ | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    start_rps_ = start_rps__raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('start_rps_', 'Start RPS#', None, None, start_rps_, start_rps__raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:nitems | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    nitems = nitems_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('nitems', 'nItems', None, None, nitems, nitems_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:number_of_wps_with_a_specific_radius_of_turn | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    number_of_wps_with_a_specific_radius_of_turn = number_of_wps_with_a_specific_radius_of_turn_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_wps_with_a_specific_radius_of_turn', 'Number of WPs with a specific Radius of Turn', None, None, number_of_wps_with_a_specific_radius_of_turn, number_of_wps_with_a_specific_radius_of_turn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:database_id | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    database_id = database_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('database_id', 'Database ID', None, None, database_id, database_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:route_id | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    route_id = route_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('route_id', 'Route ID', None, None, route_id, route_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:rps_ | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    rps_ = rps__raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('rps_', 'RPS#', None, None, rps_, rps__raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:radius_of_turn | Offset: 56, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    radius_of_turn = radius_of_turn_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('radius_of_turn', 'Radius of Turn', None, None, radius_of_turn, radius_of_turn_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_130073(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130073."""
    data_raw = 0
    # start_rps_ | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'start_rps_')
    if field is None:
        raise Exception("Cant encode this message, missing 'Start RPS#'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # nitems | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'nitems')
    if field is None:
        raise Exception("Cant encode this message, missing 'nItems'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # number_of_wps_with_a_specific_radius_of_turn | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_wps_with_a_specific_radius_of_turn')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of WPs with a specific Radius of Turn'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # database_id | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'database_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Database ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # route_id | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'route_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Route ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # rps_ | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'rps_')
    if field is None:
        raise Exception("Cant encode this message, missing 'RPS#'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # radius_of_turn | Offset: 56, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'radius_of_turn')
    if field is None:
        raise Exception("Cant encode this message, missing 'Radius of Turn'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 56
    return data_raw


def is_fast_pgn_130074() -> bool:
    """Return True if PGN 130074 is a fast PGN."""
    return True
def decode_pgn_130074(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130074."""
    nmea2000Message = NMEA2000Message(130074, 'routeAndWpServiceWpListWpNamePosition', 'Route and WP Service - WP List - WP Name & Position')
    running_bit_offset = 0
    # 1:start_wp_id | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    start_wp_id = start_wp_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('start_wp_id', 'Start WP ID', None, None, start_wp_id, start_wp_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:nitems | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    nitems = nitems_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('nitems', 'nItems', None, None, nitems, nitems_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:number_of_valid_wps_in_the_wp_list | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    number_of_valid_wps_in_the_wp_list = number_of_valid_wps_in_the_wp_list_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_valid_wps_in_the_wp_list', 'Number of valid WPs in the WP-List', None, None, number_of_valid_wps_in_the_wp_list, number_of_valid_wps_in_the_wp_list_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:database_id | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    database_id = database_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('database_id', 'Database ID', None, None, database_id, database_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:reserved_40 | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    reserved_40 = reserved_40_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_40', 'Reserved', None, None, reserved_40, reserved_40_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 6:wp_id | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    wp_id = wp_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('wp_id', 'WP ID', None, None, wp_id, wp_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:wp_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    wp_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    wp_name = wp_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('wp_name', 'WP Name', None, None, wp_name, wp_name_raw, None, FieldTypes.STRING_LAU, False))
    

    # 8:wp_latitude | Offset: , Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    wp_latitude = wp_latitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('wp_latitude', 'WP Latitude', None, 'deg', wp_latitude, wp_latitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 9:wp_longitude | Offset: , Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    wp_longitude = wp_longitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('wp_longitude', 'WP Longitude', None, 'deg', wp_longitude, wp_longitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_130074(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130074."""
    data_raw = 0
    # start_wp_id | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'start_wp_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Start WP ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # nitems | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'nitems')
    if field is None:
        raise Exception("Cant encode this message, missing 'nItems'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # number_of_valid_wps_in_the_wp_list | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_valid_wps_in_the_wp_list')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of valid WPs in the WP-List'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # database_id | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'database_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Database ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # reserved_40 | Offset: 40, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_40')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # wp_id | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'wp_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'WP ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    raise Exception ("PGN 130074 not supporting encoding for now as WP Name is missing BitLength or BitOffset")
    raise Exception ("PGN 130074 not supporting encoding for now as WP Latitude is missing BitLength or BitOffset")
    raise Exception ("PGN 130074 not supporting encoding for now as WP Longitude is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130306() -> bool:
    """Return True if PGN 130306 is a fast PGN."""
    return False
def decode_pgn_130306(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130306."""
    nmea2000Message = NMEA2000Message(130306, 'windData', 'Wind Data')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:wind_speed | Offset: 8, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    wind_speed = wind_speed_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('wind_speed', 'Wind Speed', None, 'm/s', wind_speed, wind_speed_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:wind_angle | Offset: 24, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    wind_angle = wind_angle_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('wind_angle', 'Wind Angle', None, 'rad', wind_angle, wind_angle_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:reference | Offset: 40, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    reference_raw = decode_int(_data_raw_, running_bit_offset, 3)
    reference = master_dict['WIND_REFERENCE'].get(reference_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('reference', 'Reference', None, None, reference, reference_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 5:reserved_43 | Offset: 43, Length: 21, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 43
    reserved_43 = reserved_43_raw = decode_int(_data_raw_, running_bit_offset, 21)
    nmea2000Message.fields.append(NMEA2000Field('reserved_43', 'Reserved', None, None, reserved_43, reserved_43_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 21

    return nmea2000Message

def encode_pgn_130306(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130306."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # wind_speed | Offset: 8, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'wind_speed')
    if field is None:
        raise Exception("Cant encode this message, missing 'Wind Speed'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 8
    
    # wind_angle | Offset: 24, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'wind_angle')
    if field is None:
        raise Exception("Cant encode this message, missing 'Wind Angle'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 24
    
    # reference | Offset: 40, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'reference')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reference'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_WIND_REFERENCE(field.value)
    data_raw |= (field_value & 0x7) << 40
    # reserved_43 | Offset: 43, Length: 21, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_43')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1FFFFF) << 43
    return data_raw


def is_fast_pgn_130310() -> bool:
    """Return True if PGN 130310 is a fast PGN."""
    return False
def decode_pgn_130310(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130310."""
    nmea2000Message = NMEA2000Message(130310, 'environmentalParametersObsolete', 'Environmental Parameters (obsolete)')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:water_temperature | Offset: 8, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    water_temperature = water_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('water_temperature', 'Water Temperature', None, 'K', water_temperature, water_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:outside_ambient_air_temperature | Offset: 24, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    outside_ambient_air_temperature = outside_ambient_air_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('outside_ambient_air_temperature', 'Outside Ambient Air Temperature', None, 'K', outside_ambient_air_temperature, outside_ambient_air_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:atmospheric_pressure | Offset: 40, Length: 16, Signed: False Resolution: 100, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    atmospheric_pressure = atmospheric_pressure_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 100)
    nmea2000Message.fields.append(NMEA2000Field('atmospheric_pressure', 'Atmospheric Pressure', None, 'Pa', atmospheric_pressure, atmospheric_pressure_raw, PhysicalQuantities.PRESSURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130310(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130310."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # water_temperature | Offset: 8, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'water_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Water Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 8
    
    # outside_ambient_air_temperature | Offset: 24, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'outside_ambient_air_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Outside Ambient Air Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 24
    
    # atmospheric_pressure | Offset: 40, Length: 16, Resolution: 100, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'atmospheric_pressure')
    if field is None:
        raise Exception("Cant encode this message, missing 'Atmospheric Pressure'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 100) & 0xFFFF) << 40
    
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_130311() -> bool:
    """Return True if PGN 130311 is a fast PGN."""
    return False
def decode_pgn_130311(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130311."""
    nmea2000Message = NMEA2000Message(130311, 'environmentalParameters', 'Environmental Parameters')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:temperature_source | Offset: 8, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    temperature_source_raw = decode_int(_data_raw_, running_bit_offset, 6)
    temperature_source = master_dict['TEMPERATURE_SOURCE'].get(temperature_source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('temperature_source', 'Temperature Source', None, None, temperature_source, temperature_source_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 3:humidity_source | Offset: 14, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 14
    humidity_source_raw = decode_int(_data_raw_, running_bit_offset, 2)
    humidity_source = master_dict['HUMIDITY_SOURCE'].get(humidity_source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('humidity_source', 'Humidity Source', None, None, humidity_source, humidity_source_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:temperature | Offset: 16, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    temperature = temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('temperature', 'Temperature', None, 'K', temperature, temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:humidity | Offset: 32, Length: 16, Signed: True Resolution: 0.004, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    humidity = humidity_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.004)
    nmea2000Message.fields.append(NMEA2000Field('humidity', 'Humidity', None, '%', humidity, humidity_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:atmospheric_pressure | Offset: 48, Length: 16, Signed: False Resolution: 100, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    atmospheric_pressure = atmospheric_pressure_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 100)
    nmea2000Message.fields.append(NMEA2000Field('atmospheric_pressure', 'Atmospheric Pressure', None, 'Pa', atmospheric_pressure, atmospheric_pressure_raw, PhysicalQuantities.PRESSURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_130311(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130311."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # temperature_source | Offset: 8, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'temperature_source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Temperature Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_TEMPERATURE_SOURCE(field.value)
    data_raw |= (field_value & 0x3F) << 8
    # humidity_source | Offset: 14, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'humidity_source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Humidity Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_HUMIDITY_SOURCE(field.value)
    data_raw |= (field_value & 0x3) << 14
    # temperature | Offset: 16, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 16
    
    # humidity | Offset: 32, Length: 16, Resolution: 0.004, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'humidity')
    if field is None:
        raise Exception("Cant encode this message, missing 'Humidity'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.004) & 0xFFFF) << 32
    
    # atmospheric_pressure | Offset: 48, Length: 16, Resolution: 100, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'atmospheric_pressure')
    if field is None:
        raise Exception("Cant encode this message, missing 'Atmospheric Pressure'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 100) & 0xFFFF) << 48
    
    return data_raw


def is_fast_pgn_130312() -> bool:
    """Return True if PGN 130312 is a fast PGN."""
    return False
def decode_pgn_130312(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130312."""
    nmea2000Message = NMEA2000Message(130312, 'temperature', 'Temperature')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:instance | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 3:source | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    source_raw = decode_int(_data_raw_, running_bit_offset, 8)
    source = master_dict['TEMPERATURE_SOURCE'].get(source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('source', 'Source', None, None, source, source_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 4:actual_temperature | Offset: 24, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    actual_temperature = actual_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('actual_temperature', 'Actual Temperature', None, 'K', actual_temperature, actual_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:set_temperature | Offset: 40, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    set_temperature = set_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('set_temperature', 'Set Temperature', None, 'K', set_temperature, set_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130312(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130312."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # instance | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # source | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_TEMPERATURE_SOURCE(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # actual_temperature | Offset: 24, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'actual_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Actual Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 24
    
    # set_temperature | Offset: 40, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'set_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Set Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 40
    
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_130313() -> bool:
    """Return True if PGN 130313 is a fast PGN."""
    return False
def decode_pgn_130313(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130313."""
    nmea2000Message = NMEA2000Message(130313, 'humidity', 'Humidity')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:instance | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 3:source | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    source_raw = decode_int(_data_raw_, running_bit_offset, 8)
    source = master_dict['HUMIDITY_SOURCE'].get(source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('source', 'Source', None, None, source, source_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 4:actual_humidity | Offset: 24, Length: 16, Signed: True Resolution: 0.004, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    actual_humidity = actual_humidity_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.004)
    nmea2000Message.fields.append(NMEA2000Field('actual_humidity', 'Actual Humidity', None, '%', actual_humidity, actual_humidity_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:set_humidity | Offset: 40, Length: 16, Signed: True Resolution: 0.004, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    set_humidity = set_humidity_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.004)
    nmea2000Message.fields.append(NMEA2000Field('set_humidity', 'Set Humidity', None, '%', set_humidity, set_humidity_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130313(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130313."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # instance | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # source | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_HUMIDITY_SOURCE(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # actual_humidity | Offset: 24, Length: 16, Resolution: 0.004, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'actual_humidity')
    if field is None:
        raise Exception("Cant encode this message, missing 'Actual Humidity'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.004) & 0xFFFF) << 24
    
    # set_humidity | Offset: 40, Length: 16, Resolution: 0.004, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'set_humidity')
    if field is None:
        raise Exception("Cant encode this message, missing 'Set Humidity'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.004) & 0xFFFF) << 40
    
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_130314() -> bool:
    """Return True if PGN 130314 is a fast PGN."""
    return False
def decode_pgn_130314(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130314."""
    nmea2000Message = NMEA2000Message(130314, 'actualPressure', 'Actual Pressure')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:instance | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 3:source | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    source_raw = decode_int(_data_raw_, running_bit_offset, 8)
    source = master_dict['PRESSURE_SOURCE'].get(source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('source', 'Source', None, None, source, source_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 4:pressure | Offset: 24, Length: 32, Signed: True Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    pressure = pressure_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('pressure', 'Pressure', None, 'Pa', pressure, pressure_raw, PhysicalQuantities.PRESSURE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 5:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130314(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130314."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # instance | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # source | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_PRESSURE_SOURCE(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # pressure | Offset: 24, Length: 32, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pressure')
    if field is None:
        raise Exception("Cant encode this message, missing 'Pressure'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFFFFFF) << 24
    
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_130315() -> bool:
    """Return True if PGN 130315 is a fast PGN."""
    return False
def decode_pgn_130315(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130315."""
    nmea2000Message = NMEA2000Message(130315, 'setPressure', 'Set Pressure')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:instance | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 3:source | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    source_raw = decode_int(_data_raw_, running_bit_offset, 8)
    source = master_dict['PRESSURE_SOURCE'].get(source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('source', 'Source', None, None, source, source_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 4:pressure | Offset: 24, Length: 32, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    pressure = pressure_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('pressure', 'Pressure', None, 'Pa', pressure, pressure_raw, PhysicalQuantities.PRESSURE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 5:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130315(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130315."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # instance | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # source | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_PRESSURE_SOURCE(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # pressure | Offset: 24, Length: 32, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pressure')
    if field is None:
        raise Exception("Cant encode this message, missing 'Pressure'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFFFFFF) << 24
    
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_130316() -> bool:
    """Return True if PGN 130316 is a fast PGN."""
    return False
def decode_pgn_130316(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130316."""
    nmea2000Message = NMEA2000Message(130316, 'temperatureExtendedRange', 'Temperature Extended Range')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:instance | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 8
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 3:source | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    source_raw = decode_int(_data_raw_, running_bit_offset, 8)
    source = master_dict['TEMPERATURE_SOURCE'].get(source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('source', 'Source', None, None, source, source_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 4:temperature | Offset: 24, Length: 24, Signed: False Resolution: 0.001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    temperature = temperature_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 0.001)
    nmea2000Message.fields.append(NMEA2000Field('temperature', 'Temperature', None, 'K', temperature, temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    # 5:set_temperature | Offset: 48, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    set_temperature = set_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('set_temperature', 'Set Temperature', None, 'K', set_temperature, set_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_130316(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130316."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # instance | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # source | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_TEMPERATURE_SOURCE(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # temperature | Offset: 24, Length: 24, Resolution: 0.001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFFFF) << 24
    
    # set_temperature | Offset: 48, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'set_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Set Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 48
    
    return data_raw


def is_fast_pgn_130320() -> bool:
    """Return True if PGN 130320 is a fast PGN."""
    return True
def decode_pgn_130320(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130320."""
    nmea2000Message = NMEA2000Message(130320, 'tideStationData', 'Tide Station Data')
    running_bit_offset = 0
    # 1:mode | Offset: 0, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    mode_raw = decode_int(_data_raw_, running_bit_offset, 4)
    mode = master_dict['RESIDUAL_MODE'].get(mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('mode', 'Mode', None, None, mode, mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 2:tide_tendency | Offset: 4, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 4
    tide_tendency_raw = decode_int(_data_raw_, running_bit_offset, 2)
    tide_tendency = master_dict['TIDE'].get(tide_tendency_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('tide_tendency', 'Tide Tendency', None, None, tide_tendency, tide_tendency_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:reserved_6 | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    reserved_6 = reserved_6_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_6', 'Reserved', None, None, reserved_6, reserved_6_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 4:measurement_date | Offset: 8, Length: 16, Signed: False Resolution: 1, Field Type: DATE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    measurement_date_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    measurement_date = decode_date(measurement_date_raw)
    nmea2000Message.fields.append(NMEA2000Field('measurement_date', 'Measurement Date', None, 'd', measurement_date, measurement_date_raw, PhysicalQuantities.DATE, FieldTypes.DATE, False))
    running_bit_offset += 16

    # 5:measurement_time | Offset: 24, Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    measurement_time_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    measurement_time = decode_time(measurement_time_raw)
    nmea2000Message.fields.append(NMEA2000Field('measurement_time', 'Measurement Time', "Seconds since midnight", 's', measurement_time, measurement_time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 6:station_latitude | Offset: 56, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    station_latitude = station_latitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('station_latitude', 'Station Latitude', None, 'deg', station_latitude, station_latitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 7:station_longitude | Offset: 88, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    station_longitude = station_longitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('station_longitude', 'Station Longitude', None, 'deg', station_longitude, station_longitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 8:tide_level | Offset: 120, Length: 16, Signed: True Resolution: 0.001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    tide_level = tide_level_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.001)
    nmea2000Message.fields.append(NMEA2000Field('tide_level', 'Tide Level', "Relative to MLLW", 'm', tide_level, tide_level_raw, PhysicalQuantities.DISTANCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:tide_level_standard_deviation | Offset: 136, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 136
    tide_level_standard_deviation = tide_level_standard_deviation_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('tide_level_standard_deviation', 'Tide Level standard deviation', None, 'm', tide_level_standard_deviation, tide_level_standard_deviation_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 10:station_id | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    station_id_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    station_id = station_id_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('station_id', 'Station ID', None, None, station_id, station_id_raw, None, FieldTypes.STRING_LAU, False))
    

    # 11:station_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    station_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    station_name = station_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('station_name', 'Station Name', None, None, station_name, station_name_raw, None, FieldTypes.STRING_LAU, False))
    

    return nmea2000Message

def encode_pgn_130320(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130320."""
    data_raw = 0
    # mode | Offset: 0, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_RESIDUAL_MODE(field.value)
    data_raw |= (field_value & 0xF) << 0
    # tide_tendency | Offset: 4, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'tide_tendency')
    if field is None:
        raise Exception("Cant encode this message, missing 'Tide Tendency'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_TIDE(field.value)
    data_raw |= (field_value & 0x3) << 4
    # reserved_6 | Offset: 6, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_6')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 6
    # measurement_date | Offset: 8, Length: 16, Resolution: 1, Field Type: DATE
    field = next(f for f in nmea2000Message.fields if f.id == 'measurement_date')
    if field is None:
        raise Exception("Cant encode this message, missing 'Measurement Date'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 8
    # measurement_time | Offset: 24, Length: 32, Resolution: 0.0001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'measurement_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Measurement Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFFFFFF) << 24
    
    # station_latitude | Offset: 56, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'station_latitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station Latitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 56
    
    # station_longitude | Offset: 88, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'station_longitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station Longitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 88
    
    # tide_level | Offset: 120, Length: 16, Resolution: 0.001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'tide_level')
    if field is None:
        raise Exception("Cant encode this message, missing 'Tide Level'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFF) << 120
    
    # tide_level_standard_deviation | Offset: 136, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'tide_level_standard_deviation')
    if field is None:
        raise Exception("Cant encode this message, missing 'Tide Level standard deviation'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 136
    
    raise Exception ("PGN 130320 not supporting encoding for now as Station ID is missing BitLength or BitOffset")
    raise Exception ("PGN 130320 not supporting encoding for now as Station Name is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130321() -> bool:
    """Return True if PGN 130321 is a fast PGN."""
    return True
def decode_pgn_130321(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130321."""
    nmea2000Message = NMEA2000Message(130321, 'salinityStationData', 'Salinity Station Data')
    running_bit_offset = 0
    # 1:mode | Offset: 0, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    mode_raw = decode_int(_data_raw_, running_bit_offset, 4)
    mode = master_dict['RESIDUAL_MODE'].get(mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('mode', 'Mode', None, None, mode, mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 2:reserved_4 | Offset: 4, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 4
    reserved_4 = reserved_4_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_4', 'Reserved', None, None, reserved_4, reserved_4_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 3:measurement_date | Offset: 8, Length: 16, Signed: False Resolution: 1, Field Type: DATE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    measurement_date_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    measurement_date = decode_date(measurement_date_raw)
    nmea2000Message.fields.append(NMEA2000Field('measurement_date', 'Measurement Date', None, 'd', measurement_date, measurement_date_raw, PhysicalQuantities.DATE, FieldTypes.DATE, False))
    running_bit_offset += 16

    # 4:measurement_time | Offset: 24, Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    measurement_time_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    measurement_time = decode_time(measurement_time_raw)
    nmea2000Message.fields.append(NMEA2000Field('measurement_time', 'Measurement Time', "Seconds since midnight", 's', measurement_time, measurement_time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 5:station_latitude | Offset: 56, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    station_latitude = station_latitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('station_latitude', 'Station Latitude', None, 'deg', station_latitude, station_latitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:station_longitude | Offset: 88, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    station_longitude = station_longitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('station_longitude', 'Station Longitude', None, 'deg', station_longitude, station_longitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 7:salinity | Offset: 120, Length: 32, Signed: True Resolution: 1, Field Type: FLOAT, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    salinity = salinity_raw = decode_float(_data_raw_, running_bit_offset, 32)
    nmea2000Message.fields.append(NMEA2000Field('salinity', 'Salinity', None, 'ppt', salinity, salinity_raw, None, FieldTypes.FLOAT, False))
    running_bit_offset += 32

    # 8:water_temperature | Offset: 152, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 152
    water_temperature = water_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('water_temperature', 'Water Temperature', None, 'K', water_temperature, water_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:station_id | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    station_id_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    station_id = station_id_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('station_id', 'Station ID', None, None, station_id, station_id_raw, None, FieldTypes.STRING_LAU, False))
    

    # 10:station_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    station_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    station_name = station_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('station_name', 'Station Name', None, None, station_name, station_name_raw, None, FieldTypes.STRING_LAU, False))
    

    return nmea2000Message

def encode_pgn_130321(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130321."""
    data_raw = 0
    # mode | Offset: 0, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_RESIDUAL_MODE(field.value)
    data_raw |= (field_value & 0xF) << 0
    # reserved_4 | Offset: 4, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_4')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 4
    # measurement_date | Offset: 8, Length: 16, Resolution: 1, Field Type: DATE
    field = next(f for f in nmea2000Message.fields if f.id == 'measurement_date')
    if field is None:
        raise Exception("Cant encode this message, missing 'Measurement Date'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 8
    # measurement_time | Offset: 24, Length: 32, Resolution: 0.0001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'measurement_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Measurement Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFFFFFF) << 24
    
    # station_latitude | Offset: 56, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'station_latitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station Latitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 56
    
    # station_longitude | Offset: 88, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'station_longitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station Longitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 88
    
    # salinity | Offset: 120, Length: 32, Resolution: 1, Field Type: FLOAT
    field = next(f for f in nmea2000Message.fields if f.id == 'salinity')
    if field is None:
        raise Exception("Cant encode this message, missing 'Salinity'")
    field_value = encode_float(field.value)
    data_raw |= (field_value & 0xFFFFFFFF) << 120
    # water_temperature | Offset: 152, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'water_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Water Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 152
    
    raise Exception ("PGN 130321 not supporting encoding for now as Station ID is missing BitLength or BitOffset")
    raise Exception ("PGN 130321 not supporting encoding for now as Station Name is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130322() -> bool:
    """Return True if PGN 130322 is a fast PGN."""
    return True
def decode_pgn_130322(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130322."""
    nmea2000Message = NMEA2000Message(130322, 'currentStationData', 'Current Station Data')
    running_bit_offset = 0
    # 1:mode | Offset: 0, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    mode = mode_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('mode', 'Mode', None, None, mode, mode_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 2:reserved_4 | Offset: 4, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 4
    reserved_4 = reserved_4_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_4', 'Reserved', None, None, reserved_4, reserved_4_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 3:measurement_date | Offset: 8, Length: 16, Signed: False Resolution: 1, Field Type: DATE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    measurement_date_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    measurement_date = decode_date(measurement_date_raw)
    nmea2000Message.fields.append(NMEA2000Field('measurement_date', 'Measurement Date', None, 'd', measurement_date, measurement_date_raw, PhysicalQuantities.DATE, FieldTypes.DATE, False))
    running_bit_offset += 16

    # 4:measurement_time | Offset: 24, Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    measurement_time_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    measurement_time = decode_time(measurement_time_raw)
    nmea2000Message.fields.append(NMEA2000Field('measurement_time', 'Measurement Time', "Seconds since midnight", 's', measurement_time, measurement_time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 5:station_latitude | Offset: 56, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    station_latitude = station_latitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('station_latitude', 'Station Latitude', None, 'deg', station_latitude, station_latitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:station_longitude | Offset: 88, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    station_longitude = station_longitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('station_longitude', 'Station Longitude', None, 'deg', station_longitude, station_longitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 7:measurement_depth | Offset: 120, Length: 32, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    measurement_depth = measurement_depth_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('measurement_depth', 'Measurement Depth', "Depth below transducer", 'm', measurement_depth, measurement_depth_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 8:current_speed | Offset: 152, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 152
    current_speed = current_speed_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('current_speed', 'Current speed', None, 'm/s', current_speed, current_speed_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:current_flow_direction | Offset: 168, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 168
    current_flow_direction = current_flow_direction_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('current_flow_direction', 'Current flow direction', None, 'rad', current_flow_direction, current_flow_direction_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 10:water_temperature | Offset: 184, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 184
    water_temperature = water_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('water_temperature', 'Water Temperature', None, 'K', water_temperature, water_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:station_id | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    station_id_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    station_id = station_id_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('station_id', 'Station ID', None, None, station_id, station_id_raw, None, FieldTypes.STRING_LAU, False))
    

    # 12:station_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    station_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    station_name = station_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('station_name', 'Station Name', None, None, station_name, station_name_raw, None, FieldTypes.STRING_LAU, False))
    

    return nmea2000Message

def encode_pgn_130322(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130322."""
    data_raw = 0
    # mode | Offset: 0, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mode'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 0
    # reserved_4 | Offset: 4, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_4')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 4
    # measurement_date | Offset: 8, Length: 16, Resolution: 1, Field Type: DATE
    field = next(f for f in nmea2000Message.fields if f.id == 'measurement_date')
    if field is None:
        raise Exception("Cant encode this message, missing 'Measurement Date'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 8
    # measurement_time | Offset: 24, Length: 32, Resolution: 0.0001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'measurement_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Measurement Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFFFFFF) << 24
    
    # station_latitude | Offset: 56, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'station_latitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station Latitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 56
    
    # station_longitude | Offset: 88, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'station_longitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station Longitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 88
    
    # measurement_depth | Offset: 120, Length: 32, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'measurement_depth')
    if field is None:
        raise Exception("Cant encode this message, missing 'Measurement Depth'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFFFFFF) << 120
    
    # current_speed | Offset: 152, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'current_speed')
    if field is None:
        raise Exception("Cant encode this message, missing 'Current speed'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 152
    
    # current_flow_direction | Offset: 168, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'current_flow_direction')
    if field is None:
        raise Exception("Cant encode this message, missing 'Current flow direction'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 168
    
    # water_temperature | Offset: 184, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'water_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Water Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 184
    
    raise Exception ("PGN 130322 not supporting encoding for now as Station ID is missing BitLength or BitOffset")
    raise Exception ("PGN 130322 not supporting encoding for now as Station Name is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130323() -> bool:
    """Return True if PGN 130323 is a fast PGN."""
    return True
def decode_pgn_130323(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130323."""
    nmea2000Message = NMEA2000Message(130323, 'meteorologicalStationData', 'Meteorological Station Data')
    running_bit_offset = 0
    # 1:mode | Offset: 0, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    mode = mode_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('mode', 'Mode', None, None, mode, mode_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 2:reserved_4 | Offset: 4, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 4
    reserved_4 = reserved_4_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_4', 'Reserved', None, None, reserved_4, reserved_4_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 3:measurement_date | Offset: 8, Length: 16, Signed: False Resolution: 1, Field Type: DATE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    measurement_date_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    measurement_date = decode_date(measurement_date_raw)
    nmea2000Message.fields.append(NMEA2000Field('measurement_date', 'Measurement Date', None, 'd', measurement_date, measurement_date_raw, PhysicalQuantities.DATE, FieldTypes.DATE, False))
    running_bit_offset += 16

    # 4:measurement_time | Offset: 24, Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    measurement_time_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    measurement_time = decode_time(measurement_time_raw)
    nmea2000Message.fields.append(NMEA2000Field('measurement_time', 'Measurement Time', "Seconds since midnight", 's', measurement_time, measurement_time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 5:station_latitude | Offset: 56, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    station_latitude = station_latitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('station_latitude', 'Station Latitude', None, 'deg', station_latitude, station_latitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:station_longitude | Offset: 88, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    station_longitude = station_longitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('station_longitude', 'Station Longitude', None, 'deg', station_longitude, station_longitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 7:wind_speed | Offset: 120, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    wind_speed = wind_speed_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('wind_speed', 'Wind Speed', None, 'm/s', wind_speed, wind_speed_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:wind_direction | Offset: 136, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 136
    wind_direction = wind_direction_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('wind_direction', 'Wind Direction', None, 'rad', wind_direction, wind_direction_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:wind_reference | Offset: 152, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 152
    wind_reference_raw = decode_int(_data_raw_, running_bit_offset, 3)
    wind_reference = master_dict['WIND_REFERENCE'].get(wind_reference_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('wind_reference', 'Wind Reference', None, None, wind_reference, wind_reference_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 10:reserved_155 | Offset: 155, Length: 5, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 155
    reserved_155 = reserved_155_raw = decode_int(_data_raw_, running_bit_offset, 5)
    nmea2000Message.fields.append(NMEA2000Field('reserved_155', 'Reserved', None, None, reserved_155, reserved_155_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 5

    # 11:wind_gusts | Offset: 160, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 160
    wind_gusts = wind_gusts_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('wind_gusts', 'Wind Gusts', None, 'm/s', wind_gusts, wind_gusts_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 12:atmospheric_pressure | Offset: 176, Length: 16, Signed: False Resolution: 100, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 176
    atmospheric_pressure = atmospheric_pressure_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 100)
    nmea2000Message.fields.append(NMEA2000Field('atmospheric_pressure', 'Atmospheric Pressure', None, 'Pa', atmospheric_pressure, atmospheric_pressure_raw, PhysicalQuantities.PRESSURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 13:ambient_temperature | Offset: 192, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 192
    ambient_temperature = ambient_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('ambient_temperature', 'Ambient Temperature', None, 'K', ambient_temperature, ambient_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 14:station_id | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    station_id_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    station_id = station_id_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('station_id', 'Station ID', None, None, station_id, station_id_raw, None, FieldTypes.STRING_LAU, False))
    

    # 15:station_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    station_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    station_name = station_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('station_name', 'Station Name', None, None, station_name, station_name_raw, None, FieldTypes.STRING_LAU, False))
    

    return nmea2000Message

def encode_pgn_130323(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130323."""
    data_raw = 0
    # mode | Offset: 0, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mode'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 0
    # reserved_4 | Offset: 4, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_4')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 4
    # measurement_date | Offset: 8, Length: 16, Resolution: 1, Field Type: DATE
    field = next(f for f in nmea2000Message.fields if f.id == 'measurement_date')
    if field is None:
        raise Exception("Cant encode this message, missing 'Measurement Date'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 8
    # measurement_time | Offset: 24, Length: 32, Resolution: 0.0001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'measurement_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Measurement Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFFFFFF) << 24
    
    # station_latitude | Offset: 56, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'station_latitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station Latitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 56
    
    # station_longitude | Offset: 88, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'station_longitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station Longitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 88
    
    # wind_speed | Offset: 120, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'wind_speed')
    if field is None:
        raise Exception("Cant encode this message, missing 'Wind Speed'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 120
    
    # wind_direction | Offset: 136, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'wind_direction')
    if field is None:
        raise Exception("Cant encode this message, missing 'Wind Direction'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 136
    
    # wind_reference | Offset: 152, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'wind_reference')
    if field is None:
        raise Exception("Cant encode this message, missing 'Wind Reference'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_WIND_REFERENCE(field.value)
    data_raw |= (field_value & 0x7) << 152
    # reserved_155 | Offset: 155, Length: 5, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_155')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1F) << 155
    # wind_gusts | Offset: 160, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'wind_gusts')
    if field is None:
        raise Exception("Cant encode this message, missing 'Wind Gusts'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 160
    
    # atmospheric_pressure | Offset: 176, Length: 16, Resolution: 100, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'atmospheric_pressure')
    if field is None:
        raise Exception("Cant encode this message, missing 'Atmospheric Pressure'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 100) & 0xFFFF) << 176
    
    # ambient_temperature | Offset: 192, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'ambient_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Ambient Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 192
    
    raise Exception ("PGN 130323 not supporting encoding for now as Station ID is missing BitLength or BitOffset")
    raise Exception ("PGN 130323 not supporting encoding for now as Station Name is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130324() -> bool:
    """Return True if PGN 130324 is a fast PGN."""
    return True
def decode_pgn_130324(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130324."""
    nmea2000Message = NMEA2000Message(130324, 'mooredBuoyStationData', 'Moored Buoy Station Data')
    running_bit_offset = 0
    # 1:mode | Offset: 0, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    mode = mode_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('mode', 'Mode', None, None, mode, mode_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 2:reserved_4 | Offset: 4, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 4
    reserved_4 = reserved_4_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_4', 'Reserved', None, None, reserved_4, reserved_4_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 3:measurement_date | Offset: 8, Length: 16, Signed: False Resolution: 1, Field Type: DATE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    measurement_date_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    measurement_date = decode_date(measurement_date_raw)
    nmea2000Message.fields.append(NMEA2000Field('measurement_date', 'Measurement Date', None, 'd', measurement_date, measurement_date_raw, PhysicalQuantities.DATE, FieldTypes.DATE, False))
    running_bit_offset += 16

    # 4:measurement_time | Offset: 24, Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    measurement_time_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    measurement_time = decode_time(measurement_time_raw)
    nmea2000Message.fields.append(NMEA2000Field('measurement_time', 'Measurement Time', "Seconds since midnight", 's', measurement_time, measurement_time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 5:station_latitude | Offset: 56, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    station_latitude = station_latitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('station_latitude', 'Station Latitude', None, 'deg', station_latitude, station_latitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:station_longitude | Offset: 88, Length: 32, Signed: True Resolution: 1e-07, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    station_longitude = station_longitude_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1e-07)
    nmea2000Message.fields.append(NMEA2000Field('station_longitude', 'Station Longitude', None, 'deg', station_longitude, station_longitude_raw, PhysicalQuantities.GEOGRAPHICAL_COORDINATE, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 7:wind_speed | Offset: 120, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    wind_speed = wind_speed_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('wind_speed', 'Wind Speed', None, 'm/s', wind_speed, wind_speed_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:wind_direction | Offset: 136, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 136
    wind_direction = wind_direction_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('wind_direction', 'Wind Direction', None, 'rad', wind_direction, wind_direction_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:wind_reference | Offset: 152, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 152
    wind_reference_raw = decode_int(_data_raw_, running_bit_offset, 3)
    wind_reference = master_dict['WIND_REFERENCE'].get(wind_reference_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('wind_reference', 'Wind Reference', None, None, wind_reference, wind_reference_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 10:reserved_155 | Offset: 155, Length: 5, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 155
    reserved_155 = reserved_155_raw = decode_int(_data_raw_, running_bit_offset, 5)
    nmea2000Message.fields.append(NMEA2000Field('reserved_155', 'Reserved', None, None, reserved_155, reserved_155_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 5

    # 11:wind_gusts | Offset: 160, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 160
    wind_gusts = wind_gusts_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('wind_gusts', 'Wind Gusts', None, 'm/s', wind_gusts, wind_gusts_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 12:wave_height | Offset: 176, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 176
    wave_height = wave_height_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('wave_height', 'Wave Height', None, None, wave_height, wave_height_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 13:dominant_wave_period | Offset: 192, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 192
    dominant_wave_period = dominant_wave_period_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('dominant_wave_period', 'Dominant Wave Period', None, None, dominant_wave_period, dominant_wave_period_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 14:atmospheric_pressure | Offset: 208, Length: 16, Signed: False Resolution: 100, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 208
    atmospheric_pressure = atmospheric_pressure_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 100)
    nmea2000Message.fields.append(NMEA2000Field('atmospheric_pressure', 'Atmospheric Pressure', None, 'Pa', atmospheric_pressure, atmospheric_pressure_raw, PhysicalQuantities.PRESSURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 15:pressure_tendency_rate | Offset: 224, Length: 16, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 224
    pressure_tendency_rate = pressure_tendency_rate_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('pressure_tendency_rate', 'Pressure Tendency Rate', None, 'Pa/hr', pressure_tendency_rate, pressure_tendency_rate_raw, PhysicalQuantities.PRESSURE_RATE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 16:air_temperature | Offset: 240, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 240
    air_temperature = air_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('air_temperature', 'Air Temperature', None, 'K', air_temperature, air_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 17:water_temperature | Offset: 256, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 256
    water_temperature = water_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('water_temperature', 'Water Temperature', None, 'K', water_temperature, water_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 18:station_id | Offset: 272, Length: 64, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 272
    station_id = station_id_raw = decode_string_fix(_data_raw_, running_bit_offset, 64)
    nmea2000Message.fields.append(NMEA2000Field('station_id', 'Station ID', None, None, station_id, station_id_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 64

    return nmea2000Message

def encode_pgn_130324(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130324."""
    data_raw = 0
    # mode | Offset: 0, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mode'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 0
    # reserved_4 | Offset: 4, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_4')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 4
    # measurement_date | Offset: 8, Length: 16, Resolution: 1, Field Type: DATE
    field = next(f for f in nmea2000Message.fields if f.id == 'measurement_date')
    if field is None:
        raise Exception("Cant encode this message, missing 'Measurement Date'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 8
    # measurement_time | Offset: 24, Length: 32, Resolution: 0.0001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'measurement_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Measurement Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFFFFFF) << 24
    
    # station_latitude | Offset: 56, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'station_latitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station Latitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 56
    
    # station_longitude | Offset: 88, Length: 32, Resolution: 1e-07, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'station_longitude')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station Longitude'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1e-07) & 0xFFFFFFFF) << 88
    
    # wind_speed | Offset: 120, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'wind_speed')
    if field is None:
        raise Exception("Cant encode this message, missing 'Wind Speed'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 120
    
    # wind_direction | Offset: 136, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'wind_direction')
    if field is None:
        raise Exception("Cant encode this message, missing 'Wind Direction'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 136
    
    # wind_reference | Offset: 152, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'wind_reference')
    if field is None:
        raise Exception("Cant encode this message, missing 'Wind Reference'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_WIND_REFERENCE(field.value)
    data_raw |= (field_value & 0x7) << 152
    # reserved_155 | Offset: 155, Length: 5, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_155')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1F) << 155
    # wind_gusts | Offset: 160, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'wind_gusts')
    if field is None:
        raise Exception("Cant encode this message, missing 'Wind Gusts'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 160
    
    # wave_height | Offset: 176, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'wave_height')
    if field is None:
        raise Exception("Cant encode this message, missing 'Wave Height'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 176
    # dominant_wave_period | Offset: 192, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'dominant_wave_period')
    if field is None:
        raise Exception("Cant encode this message, missing 'Dominant Wave Period'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 192
    # atmospheric_pressure | Offset: 208, Length: 16, Resolution: 100, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'atmospheric_pressure')
    if field is None:
        raise Exception("Cant encode this message, missing 'Atmospheric Pressure'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 100) & 0xFFFF) << 208
    
    # pressure_tendency_rate | Offset: 224, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pressure_tendency_rate')
    if field is None:
        raise Exception("Cant encode this message, missing 'Pressure Tendency Rate'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 224
    # air_temperature | Offset: 240, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'air_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Air Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 240
    
    # water_temperature | Offset: 256, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'water_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Water Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 256
    
    # station_id | Offset: 272, Length: 64, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'station_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Station ID'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFF) << 272
    return data_raw


def is_fast_pgn_130330() -> bool:
    """Return True if PGN 130330 is a fast PGN."""
    return True
def decode_pgn_130330(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130330."""
    nmea2000Message = NMEA2000Message(130330, 'lightingSystemSettings', 'Lighting System Settings')
    running_bit_offset = 0
    # 1:global_enable | Offset: 0, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    global_enable = global_enable_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('global_enable', 'Global Enable', None, None, global_enable, global_enable_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 2:default_settings_command | Offset: 2, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 2
    default_settings_command_raw = decode_int(_data_raw_, running_bit_offset, 3)
    default_settings_command = master_dict['LIGHTING_COMMAND'].get(default_settings_command_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('default_settings_command', 'Default Settings/Command', None, None, default_settings_command, default_settings_command_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 3

    # 3:reserved_5 | Offset: 5, Length: 3, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 5
    reserved_5 = reserved_5_raw = decode_int(_data_raw_, running_bit_offset, 3)
    nmea2000Message.fields.append(NMEA2000Field('reserved_5', 'Reserved', None, None, reserved_5, reserved_5_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 3

    # 4:name_of_the_lighting_controller | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    name_of_the_lighting_controller_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    name_of_the_lighting_controller = name_of_the_lighting_controller_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('name_of_the_lighting_controller', 'Name of the lighting controller', None, None, name_of_the_lighting_controller, name_of_the_lighting_controller_raw, None, FieldTypes.STRING_LAU, False))
    

    # 5:max_scenes | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    max_scenes = max_scenes_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('max_scenes', 'Max Scenes', None, None, max_scenes, max_scenes_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:max_scene_configuration_count | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    max_scene_configuration_count = max_scene_configuration_count_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('max_scene_configuration_count', 'Max Scene Configuration Count', None, None, max_scene_configuration_count, max_scene_configuration_count_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:max_zones | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    max_zones = max_zones_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('max_zones', 'Max Zones', None, None, max_zones, max_zones_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:max_color_sequences | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    max_color_sequences = max_color_sequences_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('max_color_sequences', 'Max Color Sequences', None, None, max_color_sequences, max_color_sequences_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:max_color_sequence_color_count | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    max_color_sequence_color_count = max_color_sequence_color_count_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('max_color_sequence_color_count', 'Max Color Sequence Color Count', None, None, max_color_sequence_color_count, max_color_sequence_color_count_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:number_of_programs | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    number_of_programs = number_of_programs_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_programs', 'Number of Programs', None, None, number_of_programs, number_of_programs_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 11:controller_capabilities | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    controller_capabilities = controller_capabilities_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('controller_capabilities', 'Controller Capabilities', None, None, controller_capabilities, controller_capabilities_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 12:identify_device | Offset: , Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    identify_device = identify_device_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('identify_device', 'Identify Device', None, None, identify_device, identify_device_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_130330(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130330."""
    data_raw = 0
    # global_enable | Offset: 0, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'global_enable')
    if field is None:
        raise Exception("Cant encode this message, missing 'Global Enable'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 0
    # default_settings_command | Offset: 2, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'default_settings_command')
    if field is None:
        raise Exception("Cant encode this message, missing 'Default Settings/Command'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_LIGHTING_COMMAND(field.value)
    data_raw |= (field_value & 0x7) << 2
    # reserved_5 | Offset: 5, Length: 3, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_5')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x7) << 5
    raise Exception ("PGN 130330 not supporting encoding for now as Name of the lighting controller is missing BitLength or BitOffset")
    raise Exception ("PGN 130330 not supporting encoding for now as Max Scenes is missing BitLength or BitOffset")
    raise Exception ("PGN 130330 not supporting encoding for now as Max Scene Configuration Count is missing BitLength or BitOffset")
    raise Exception ("PGN 130330 not supporting encoding for now as Max Zones is missing BitLength or BitOffset")
    raise Exception ("PGN 130330 not supporting encoding for now as Max Color Sequences is missing BitLength or BitOffset")
    raise Exception ("PGN 130330 not supporting encoding for now as Max Color Sequence Color Count is missing BitLength or BitOffset")
    raise Exception ("PGN 130330 not supporting encoding for now as Number of Programs is missing BitLength or BitOffset")
    raise Exception ("PGN 130330 not supporting encoding for now as Controller Capabilities is missing BitLength or BitOffset")
    raise Exception ("PGN 130330 not supporting encoding for now as Identify Device is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130560() -> bool:
    """Return True if PGN 130560 is a fast PGN."""
    return False
def decode_pgn_130560(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130560."""
    nmea2000Message = NMEA2000Message(130560, 'payloadMass', 'Payload Mass')
    running_bit_offset = 0
    # 1:sid | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:measurement_status | Offset: 8, Length: 3, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    measurement_status = measurement_status_raw = decode_number(_data_raw_, running_bit_offset, 3, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('measurement_status', 'Measurement Status', None, None, measurement_status, measurement_status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 3

    # 3:reserved_11 | Offset: 11, Length: 5, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 5)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 5

    # 4:measurement_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    measurement_id = measurement_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('measurement_id', 'Measurement ID', None, None, measurement_id, measurement_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:payload_mass | Offset: 24, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    payload_mass = payload_mass_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('payload_mass', 'Payload Mass', None, None, payload_mass, payload_mass_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:reserved_56 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    reserved_56 = reserved_56_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_56', 'Reserved', None, None, reserved_56, reserved_56_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130560(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130560."""
    data_raw = 0
    # sid | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # measurement_status | Offset: 8, Length: 3, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'measurement_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Measurement Status'")
    field_value = field.value
    data_raw |= (field_value & 0x7) << 8
    # reserved_11 | Offset: 11, Length: 5, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x1F) << 11
    # measurement_id | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'measurement_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Measurement ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # payload_mass | Offset: 24, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'payload_mass')
    if field is None:
        raise Exception("Cant encode this message, missing 'Payload Mass'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 24
    # reserved_56 | Offset: 56, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_56')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw


def is_fast_pgn_130561() -> bool:
    """Return True if PGN 130561 is a fast PGN."""
    return True
def decode_pgn_130561(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130561."""
    nmea2000Message = NMEA2000Message(130561, 'lightingZone', 'Lighting Zone')
    running_bit_offset = 0
    # 1:zone_index | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    zone_index = zone_index_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone_index', 'Zone Index', None, None, zone_index, zone_index_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:zone_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    zone_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    zone_name = zone_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('zone_name', 'Zone Name', None, None, zone_name, zone_name_raw, None, FieldTypes.STRING_LAU, False))
    

    # 3:red_component | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    red_component = red_component_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('red_component', 'Red Component', None, None, red_component, red_component_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:green_component | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    green_component = green_component_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('green_component', 'Green Component', None, None, green_component, green_component_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:blue_component | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    blue_component = blue_component_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('blue_component', 'Blue Component', None, None, blue_component, blue_component_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:color_temperature | Offset: , Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    color_temperature = color_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('color_temperature', 'Color Temperature', None, None, color_temperature, color_temperature_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:intensity | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    intensity = intensity_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('intensity', 'Intensity', None, None, intensity, intensity_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:program_id | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    program_id = program_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('program_id', 'Program ID', None, None, program_id, program_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:program_color_sequence_index | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    program_color_sequence_index = program_color_sequence_index_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('program_color_sequence_index', 'Program Color Sequence Index', None, None, program_color_sequence_index, program_color_sequence_index_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:program_intensity | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    program_intensity = program_intensity_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('program_intensity', 'Program Intensity', None, None, program_intensity, program_intensity_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 11:program_rate | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    program_rate = program_rate_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('program_rate', 'Program Rate', None, None, program_rate, program_rate_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 12:program_color_sequence | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    program_color_sequence = program_color_sequence_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('program_color_sequence', 'Program Color Sequence', None, None, program_color_sequence, program_color_sequence_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 13:zone_enabled | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    zone_enabled_raw = decode_int(_data_raw_, running_bit_offset, 2)
    zone_enabled = master_dict['OFF_ON'].get(zone_enabled_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('zone_enabled', 'Zone Enabled', None, None, zone_enabled, zone_enabled_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 14:reserved_ | Offset: , Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    reserved_ = reserved__raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_', 'Reserved', None, None, reserved_, reserved__raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    return nmea2000Message

def encode_pgn_130561(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130561."""
    data_raw = 0
    # zone_index | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zone_index')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone Index'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    raise Exception ("PGN 130561 not supporting encoding for now as Zone Name is missing BitLength or BitOffset")
    raise Exception ("PGN 130561 not supporting encoding for now as Red Component is missing BitLength or BitOffset")
    raise Exception ("PGN 130561 not supporting encoding for now as Green Component is missing BitLength or BitOffset")
    raise Exception ("PGN 130561 not supporting encoding for now as Blue Component is missing BitLength or BitOffset")
    raise Exception ("PGN 130561 not supporting encoding for now as Color Temperature is missing BitLength or BitOffset")
    raise Exception ("PGN 130561 not supporting encoding for now as Intensity is missing BitLength or BitOffset")
    raise Exception ("PGN 130561 not supporting encoding for now as Program ID is missing BitLength or BitOffset")
    raise Exception ("PGN 130561 not supporting encoding for now as Program Color Sequence Index is missing BitLength or BitOffset")
    raise Exception ("PGN 130561 not supporting encoding for now as Program Intensity is missing BitLength or BitOffset")
    raise Exception ("PGN 130561 not supporting encoding for now as Program Rate is missing BitLength or BitOffset")
    raise Exception ("PGN 130561 not supporting encoding for now as Program Color Sequence is missing BitLength or BitOffset")
    raise Exception ("PGN 130561 not supporting encoding for now as Zone Enabled is missing BitLength or BitOffset")
    raise Exception ("PGN 130561 not supporting encoding for now as Reserved is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130562() -> bool:
    """Return True if PGN 130562 is a fast PGN."""
    return True
def decode_pgn_130562(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130562."""
    nmea2000Message = NMEA2000Message(130562, 'lightingScene', 'Lighting Scene')
    running_bit_offset = 0
    # 1:scene_index | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    scene_index = scene_index_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('scene_index', 'Scene Index', None, None, scene_index, scene_index_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:zone_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    zone_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    zone_name = zone_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('zone_name', 'Zone Name', None, None, zone_name, zone_name_raw, None, FieldTypes.STRING_LAU, False))
    

    # 3:control | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    control = control_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:configuration_count | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    configuration_count = configuration_count_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('configuration_count', 'Configuration Count', None, None, configuration_count, configuration_count_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:configuration_index | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    configuration_index = configuration_index_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('configuration_index', 'Configuration Index', None, None, configuration_index, configuration_index_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:zone_index | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    zone_index = zone_index_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone_index', 'Zone Index', None, None, zone_index, zone_index_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:devices_id | Offset: , Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    devices_id = devices_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('devices_id', 'Devices ID', None, None, devices_id, devices_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 8:program_index | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    program_index = program_index_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('program_index', 'Program Index', None, None, program_index, program_index_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:program_color_sequence_index | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    program_color_sequence_index = program_color_sequence_index_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('program_color_sequence_index', 'Program Color Sequence Index', None, None, program_color_sequence_index, program_color_sequence_index_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:program_intensity | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    program_intensity = program_intensity_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('program_intensity', 'Program Intensity', None, None, program_intensity, program_intensity_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 11:program_rate | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    program_rate = program_rate_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('program_rate', 'Program Rate', None, None, program_rate, program_rate_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 12:program_color_sequence_rate | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    program_color_sequence_rate = program_color_sequence_rate_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('program_color_sequence_rate', 'Program Color Sequence Rate', None, None, program_color_sequence_rate, program_color_sequence_rate_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130562(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130562."""
    data_raw = 0
    # scene_index | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'scene_index')
    if field is None:
        raise Exception("Cant encode this message, missing 'Scene Index'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    raise Exception ("PGN 130562 not supporting encoding for now as Zone Name is missing BitLength or BitOffset")
    raise Exception ("PGN 130562 not supporting encoding for now as Control is missing BitLength or BitOffset")
    raise Exception ("PGN 130562 not supporting encoding for now as Configuration Count is missing BitLength or BitOffset")
    raise Exception ("PGN 130562 not supporting encoding for now as Configuration Index is missing BitLength or BitOffset")
    raise Exception ("PGN 130562 not supporting encoding for now as Zone Index is missing BitLength or BitOffset")
    raise Exception ("PGN 130562 not supporting encoding for now as Devices ID is missing BitLength or BitOffset")
    raise Exception ("PGN 130562 not supporting encoding for now as Program Index is missing BitLength or BitOffset")
    raise Exception ("PGN 130562 not supporting encoding for now as Program Color Sequence Index is missing BitLength or BitOffset")
    raise Exception ("PGN 130562 not supporting encoding for now as Program Intensity is missing BitLength or BitOffset")
    raise Exception ("PGN 130562 not supporting encoding for now as Program Rate is missing BitLength or BitOffset")
    raise Exception ("PGN 130562 not supporting encoding for now as Program Color Sequence Rate is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130563() -> bool:
    """Return True if PGN 130563 is a fast PGN."""
    return True
def decode_pgn_130563(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130563."""
    nmea2000Message = NMEA2000Message(130563, 'lightingDevice', 'Lighting Device')
    running_bit_offset = 0
    # 1:device_id | Offset: 0, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    device_id = device_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('device_id', 'Device ID', None, None, device_id, device_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 2:device_capabilities | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    device_capabilities = device_capabilities_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('device_capabilities', 'Device Capabilities', None, None, device_capabilities, device_capabilities_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:color_capabilities | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    color_capabilities = color_capabilities_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('color_capabilities', 'Color Capabilities', None, None, color_capabilities, color_capabilities_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:zone_index | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    zone_index = zone_index_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone_index', 'Zone Index', None, None, zone_index, zone_index_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:name_of_lighting_device | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    name_of_lighting_device_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    name_of_lighting_device = name_of_lighting_device_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('name_of_lighting_device', 'Name of Lighting Device', None, None, name_of_lighting_device, name_of_lighting_device_raw, None, FieldTypes.STRING_LAU, False))
    

    # 6:status | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    status = status_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('status', 'Status', None, None, status, status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:red_component | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    red_component = red_component_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('red_component', 'Red Component', None, None, red_component, red_component_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:green_component | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    green_component = green_component_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('green_component', 'Green Component', None, None, green_component, green_component_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:blue_component | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    blue_component = blue_component_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('blue_component', 'Blue Component', None, None, blue_component, blue_component_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:color_temperature | Offset: , Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    color_temperature = color_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('color_temperature', 'Color Temperature', None, None, color_temperature, color_temperature_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:intensity | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    intensity = intensity_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('intensity', 'Intensity', None, None, intensity, intensity_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 12:program_id | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    program_id = program_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('program_id', 'Program ID', None, None, program_id, program_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 13:program_color_sequence_index | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    program_color_sequence_index = program_color_sequence_index_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('program_color_sequence_index', 'Program Color Sequence Index', None, None, program_color_sequence_index, program_color_sequence_index_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 14:program_intensity | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    program_intensity = program_intensity_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('program_intensity', 'Program Intensity', None, None, program_intensity, program_intensity_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 15:program_rate | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    program_rate = program_rate_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('program_rate', 'Program Rate', None, None, program_rate, program_rate_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 16:program_color_sequence_rate | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    program_color_sequence_rate = program_color_sequence_rate_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('program_color_sequence_rate', 'Program Color Sequence Rate', None, None, program_color_sequence_rate, program_color_sequence_rate_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 17:enabled | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    enabled_raw = decode_int(_data_raw_, running_bit_offset, 2)
    enabled = master_dict['OFF_ON'].get(enabled_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('enabled', 'Enabled', None, None, enabled, enabled_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 18:reserved_ | Offset: , Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    reserved_ = reserved__raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_', 'Reserved', None, None, reserved_, reserved__raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    return nmea2000Message

def encode_pgn_130563(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130563."""
    data_raw = 0
    # device_id | Offset: 0, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'device_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Device ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 0
    # device_capabilities | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'device_capabilities')
    if field is None:
        raise Exception("Cant encode this message, missing 'Device Capabilities'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # color_capabilities | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'color_capabilities')
    if field is None:
        raise Exception("Cant encode this message, missing 'Color Capabilities'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # zone_index | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zone_index')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone Index'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    raise Exception ("PGN 130563 not supporting encoding for now as Name of Lighting Device is missing BitLength or BitOffset")
    raise Exception ("PGN 130563 not supporting encoding for now as Status is missing BitLength or BitOffset")
    raise Exception ("PGN 130563 not supporting encoding for now as Red Component is missing BitLength or BitOffset")
    raise Exception ("PGN 130563 not supporting encoding for now as Green Component is missing BitLength or BitOffset")
    raise Exception ("PGN 130563 not supporting encoding for now as Blue Component is missing BitLength or BitOffset")
    raise Exception ("PGN 130563 not supporting encoding for now as Color Temperature is missing BitLength or BitOffset")
    raise Exception ("PGN 130563 not supporting encoding for now as Intensity is missing BitLength or BitOffset")
    raise Exception ("PGN 130563 not supporting encoding for now as Program ID is missing BitLength or BitOffset")
    raise Exception ("PGN 130563 not supporting encoding for now as Program Color Sequence Index is missing BitLength or BitOffset")
    raise Exception ("PGN 130563 not supporting encoding for now as Program Intensity is missing BitLength or BitOffset")
    raise Exception ("PGN 130563 not supporting encoding for now as Program Rate is missing BitLength or BitOffset")
    raise Exception ("PGN 130563 not supporting encoding for now as Program Color Sequence Rate is missing BitLength or BitOffset")
    raise Exception ("PGN 130563 not supporting encoding for now as Enabled is missing BitLength or BitOffset")
    raise Exception ("PGN 130563 not supporting encoding for now as Reserved is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130564() -> bool:
    """Return True if PGN 130564 is a fast PGN."""
    return True
def decode_pgn_130564(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130564."""
    nmea2000Message = NMEA2000Message(130564, 'lightingDeviceEnumeration', 'Lighting Device Enumeration')
    running_bit_offset = 0
    # 1:index_of_first_device | Offset: 0, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    index_of_first_device = index_of_first_device_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('index_of_first_device', 'Index of First Device', None, None, index_of_first_device, index_of_first_device_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:total_number_of_devices | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    total_number_of_devices = total_number_of_devices_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('total_number_of_devices', 'Total Number of Devices', None, None, total_number_of_devices, total_number_of_devices_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:number_of_devices | Offset: 32, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    number_of_devices = number_of_devices_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_devices', 'Number of Devices', None, None, number_of_devices, number_of_devices_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:device_id | Offset: 48, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    device_id = device_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('device_id', 'Device ID', None, None, device_id, device_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 5:status | Offset: 80, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    status = status_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('status', 'Status', None, None, status, status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130564(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130564."""
    data_raw = 0
    # index_of_first_device | Offset: 0, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'index_of_first_device')
    if field is None:
        raise Exception("Cant encode this message, missing 'Index of First Device'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 0
    # total_number_of_devices | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'total_number_of_devices')
    if field is None:
        raise Exception("Cant encode this message, missing 'Total Number of Devices'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # number_of_devices | Offset: 32, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_devices')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of Devices'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 32
    # device_id | Offset: 48, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'device_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Device ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 48
    # status | Offset: 80, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Status'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 80
    return data_raw


def is_fast_pgn_130565() -> bool:
    """Return True if PGN 130565 is a fast PGN."""
    return True
def decode_pgn_130565(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130565."""
    nmea2000Message = NMEA2000Message(130565, 'lightingColorSequence', 'Lighting Color Sequence')
    running_bit_offset = 0
    # 1:sequence_index | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    sequence_index = sequence_index_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sequence_index', 'Sequence Index', None, None, sequence_index, sequence_index_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:color_count | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    color_count = color_count_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('color_count', 'Color Count', None, None, color_count, color_count_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:color_index | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    color_index = color_index_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('color_index', 'Color Index', None, None, color_index, color_index_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:red_component | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    red_component = red_component_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('red_component', 'Red Component', None, None, red_component, red_component_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:green_component | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    green_component = green_component_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('green_component', 'Green Component', None, None, green_component, green_component_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:blue_component | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    blue_component = blue_component_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('blue_component', 'Blue Component', None, None, blue_component, blue_component_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:color_temperature | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    color_temperature = color_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('color_temperature', 'Color Temperature', None, None, color_temperature, color_temperature_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:intensity | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    intensity = intensity_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('intensity', 'Intensity', None, None, intensity, intensity_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130565(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130565."""
    data_raw = 0
    # sequence_index | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sequence_index')
    if field is None:
        raise Exception("Cant encode this message, missing 'Sequence Index'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # color_count | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'color_count')
    if field is None:
        raise Exception("Cant encode this message, missing 'Color Count'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # color_index | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'color_index')
    if field is None:
        raise Exception("Cant encode this message, missing 'Color Index'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # red_component | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'red_component')
    if field is None:
        raise Exception("Cant encode this message, missing 'Red Component'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # green_component | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'green_component')
    if field is None:
        raise Exception("Cant encode this message, missing 'Green Component'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # blue_component | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'blue_component')
    if field is None:
        raise Exception("Cant encode this message, missing 'Blue Component'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # color_temperature | Offset: 48, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'color_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Color Temperature'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    # intensity | Offset: 64, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'intensity')
    if field is None:
        raise Exception("Cant encode this message, missing 'Intensity'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 64
    return data_raw


def is_fast_pgn_130566() -> bool:
    """Return True if PGN 130566 is a fast PGN."""
    return True
def decode_pgn_130566(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130566."""
    nmea2000Message = NMEA2000Message(130566, 'lightingProgram', 'Lighting Program')
    running_bit_offset = 0
    # 1:program_id | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    program_id = program_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('program_id', 'Program ID', None, None, program_id, program_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:name_of_program | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    name_of_program_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    name_of_program = name_of_program_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('name_of_program', 'Name of Program', None, None, name_of_program, name_of_program_raw, None, FieldTypes.STRING_LAU, False))
    

    # 3:description | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    description_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    description = description_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('description', 'Description', None, None, description, description_raw, None, FieldTypes.STRING_LAU, False))
    

    # 4:program_capabilities | Offset: , Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    program_capabilities = program_capabilities_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('program_capabilities', 'Program Capabilities', None, None, program_capabilities, program_capabilities_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 5:reserved_ | Offset: , Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    reserved_ = reserved__raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_', 'Reserved', None, None, reserved_, reserved__raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    return nmea2000Message

def encode_pgn_130566(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130566."""
    data_raw = 0
    # program_id | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'program_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Program ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    raise Exception ("PGN 130566 not supporting encoding for now as Name of Program is missing BitLength or BitOffset")
    raise Exception ("PGN 130566 not supporting encoding for now as Description is missing BitLength or BitOffset")
    raise Exception ("PGN 130566 not supporting encoding for now as Program Capabilities is missing BitLength or BitOffset")
    raise Exception ("PGN 130566 not supporting encoding for now as Reserved is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130567() -> bool:
    """Return True if PGN 130567 is a fast PGN."""
    return True
def decode_pgn_130567(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130567."""
    nmea2000Message = NMEA2000Message(130567, 'watermakerInputSettingAndStatus', 'Watermaker Input Setting and Status')
    running_bit_offset = 0
    # 1:watermaker_operating_state | Offset: 0, Length: 6, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    watermaker_operating_state_raw = decode_int(_data_raw_, running_bit_offset, 6)
    watermaker_operating_state = master_dict['WATERMAKER_STATE'].get(watermaker_operating_state_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('watermaker_operating_state', 'Watermaker Operating State', None, None, watermaker_operating_state, watermaker_operating_state_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 6

    # 2:production_start_stop | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    production_start_stop_raw = decode_int(_data_raw_, running_bit_offset, 2)
    production_start_stop = master_dict['YES_NO'].get(production_start_stop_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('production_start_stop', 'Production Start/Stop', None, None, production_start_stop, production_start_stop_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:rinse_start_stop | Offset: 8, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    rinse_start_stop_raw = decode_int(_data_raw_, running_bit_offset, 2)
    rinse_start_stop = master_dict['YES_NO'].get(rinse_start_stop_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('rinse_start_stop', 'Rinse Start/Stop', None, None, rinse_start_stop, rinse_start_stop_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:low_pressure_pump_status | Offset: 10, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 10
    low_pressure_pump_status_raw = decode_int(_data_raw_, running_bit_offset, 2)
    low_pressure_pump_status = master_dict['YES_NO'].get(low_pressure_pump_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('low_pressure_pump_status', 'Low Pressure Pump Status', None, None, low_pressure_pump_status, low_pressure_pump_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 5:high_pressure_pump_status | Offset: 12, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 12
    high_pressure_pump_status_raw = decode_int(_data_raw_, running_bit_offset, 2)
    high_pressure_pump_status = master_dict['YES_NO'].get(high_pressure_pump_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('high_pressure_pump_status', 'High Pressure Pump Status', None, None, high_pressure_pump_status, high_pressure_pump_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 6:emergency_stop | Offset: 14, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 14
    emergency_stop_raw = decode_int(_data_raw_, running_bit_offset, 2)
    emergency_stop = master_dict['YES_NO'].get(emergency_stop_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('emergency_stop', 'Emergency Stop', None, None, emergency_stop, emergency_stop_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 7:product_solenoid_valve_status | Offset: 16, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    product_solenoid_valve_status_raw = decode_int(_data_raw_, running_bit_offset, 2)
    product_solenoid_valve_status = master_dict['OK_WARNING'].get(product_solenoid_valve_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('product_solenoid_valve_status', 'Product Solenoid Valve Status', None, None, product_solenoid_valve_status, product_solenoid_valve_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 8:flush_mode_status | Offset: 18, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 18
    flush_mode_status_raw = decode_int(_data_raw_, running_bit_offset, 2)
    flush_mode_status = master_dict['YES_NO'].get(flush_mode_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('flush_mode_status', 'Flush Mode Status', None, None, flush_mode_status, flush_mode_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 9:salinity_status | Offset: 20, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 20
    salinity_status_raw = decode_int(_data_raw_, running_bit_offset, 2)
    salinity_status = master_dict['OK_WARNING'].get(salinity_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('salinity_status', 'Salinity Status', None, None, salinity_status, salinity_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 10:sensor_status | Offset: 22, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 22
    sensor_status_raw = decode_int(_data_raw_, running_bit_offset, 2)
    sensor_status = master_dict['OK_WARNING'].get(sensor_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('sensor_status', 'Sensor Status', None, None, sensor_status, sensor_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 11:oil_change_indicator_status | Offset: 24, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    oil_change_indicator_status_raw = decode_int(_data_raw_, running_bit_offset, 2)
    oil_change_indicator_status = master_dict['OK_WARNING'].get(oil_change_indicator_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('oil_change_indicator_status', 'Oil Change Indicator Status', None, None, oil_change_indicator_status, oil_change_indicator_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 12:filter_status | Offset: 26, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 26
    filter_status_raw = decode_int(_data_raw_, running_bit_offset, 2)
    filter_status = master_dict['OK_WARNING'].get(filter_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('filter_status', 'Filter Status', None, None, filter_status, filter_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 13:system_status | Offset: 28, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 28
    system_status_raw = decode_int(_data_raw_, running_bit_offset, 2)
    system_status = master_dict['OK_WARNING'].get(system_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('system_status', 'System Status', None, None, system_status, system_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 14:reserved_30 | Offset: 30, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 30
    reserved_30 = reserved_30_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_30', 'Reserved', None, None, reserved_30, reserved_30_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 15:salinity | Offset: 32, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    salinity = salinity_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('salinity', 'Salinity', None, 'ppm', salinity, salinity_raw, PhysicalQuantities.CONCENTRATION, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 16:product_water_temperature | Offset: 48, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    product_water_temperature = product_water_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('product_water_temperature', 'Product Water Temperature', None, 'K', product_water_temperature, product_water_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 17:pre_filter_pressure | Offset: 64, Length: 16, Signed: False Resolution: 100, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    pre_filter_pressure = pre_filter_pressure_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 100)
    nmea2000Message.fields.append(NMEA2000Field('pre_filter_pressure', 'Pre-filter Pressure', None, 'Pa', pre_filter_pressure, pre_filter_pressure_raw, PhysicalQuantities.PRESSURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 18:post_filter_pressure | Offset: 80, Length: 16, Signed: False Resolution: 100, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    post_filter_pressure = post_filter_pressure_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 100)
    nmea2000Message.fields.append(NMEA2000Field('post_filter_pressure', 'Post-filter Pressure', None, 'Pa', post_filter_pressure, post_filter_pressure_raw, PhysicalQuantities.PRESSURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 19:feed_pressure | Offset: 96, Length: 16, Signed: True Resolution: 1000, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 96
    feed_pressure = feed_pressure_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 1000)
    nmea2000Message.fields.append(NMEA2000Field('feed_pressure', 'Feed Pressure', None, 'Pa', feed_pressure, feed_pressure_raw, PhysicalQuantities.PRESSURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 20:system_high_pressure | Offset: 112, Length: 16, Signed: False Resolution: 1000, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    system_high_pressure = system_high_pressure_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1000)
    nmea2000Message.fields.append(NMEA2000Field('system_high_pressure', 'System High Pressure', None, 'Pa', system_high_pressure, system_high_pressure_raw, PhysicalQuantities.PRESSURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 21:product_water_flow | Offset: 128, Length: 16, Signed: True Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    product_water_flow = product_water_flow_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('product_water_flow', 'Product Water Flow', None, 'L/h', product_water_flow, product_water_flow_raw, PhysicalQuantities.VOLUMETRIC_FLOW, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 22:brine_water_flow | Offset: 144, Length: 16, Signed: True Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    brine_water_flow = brine_water_flow_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('brine_water_flow', 'Brine Water Flow', None, 'L/h', brine_water_flow, brine_water_flow_raw, PhysicalQuantities.VOLUMETRIC_FLOW, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 23:run_time | Offset: 160, Length: 32, Signed: False Resolution: 1, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 160
    run_time_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    run_time = decode_time(run_time_raw)
    nmea2000Message.fields.append(NMEA2000Field('run_time', 'Run Time', None, 's', run_time, run_time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_130567(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130567."""
    data_raw = 0
    # watermaker_operating_state | Offset: 0, Length: 6, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'watermaker_operating_state')
    if field is None:
        raise Exception("Cant encode this message, missing 'Watermaker Operating State'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_WATERMAKER_STATE(field.value)
    data_raw |= (field_value & 0x3F) << 0
    # production_start_stop | Offset: 6, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'production_start_stop')
    if field is None:
        raise Exception("Cant encode this message, missing 'Production Start/Stop'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 6
    # rinse_start_stop | Offset: 8, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'rinse_start_stop')
    if field is None:
        raise Exception("Cant encode this message, missing 'Rinse Start/Stop'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 8
    # low_pressure_pump_status | Offset: 10, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'low_pressure_pump_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Low Pressure Pump Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 10
    # high_pressure_pump_status | Offset: 12, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'high_pressure_pump_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'High Pressure Pump Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 12
    # emergency_stop | Offset: 14, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'emergency_stop')
    if field is None:
        raise Exception("Cant encode this message, missing 'Emergency Stop'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 14
    # product_solenoid_valve_status | Offset: 16, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'product_solenoid_valve_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Product Solenoid Valve Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OK_WARNING(field.value)
    data_raw |= (field_value & 0x3) << 16
    # flush_mode_status | Offset: 18, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'flush_mode_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Flush Mode Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 18
    # salinity_status | Offset: 20, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'salinity_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Salinity Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OK_WARNING(field.value)
    data_raw |= (field_value & 0x3) << 20
    # sensor_status | Offset: 22, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'sensor_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Sensor Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OK_WARNING(field.value)
    data_raw |= (field_value & 0x3) << 22
    # oil_change_indicator_status | Offset: 24, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'oil_change_indicator_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Oil Change Indicator Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OK_WARNING(field.value)
    data_raw |= (field_value & 0x3) << 24
    # filter_status | Offset: 26, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'filter_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Filter Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OK_WARNING(field.value)
    data_raw |= (field_value & 0x3) << 26
    # system_status | Offset: 28, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'system_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'System Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OK_WARNING(field.value)
    data_raw |= (field_value & 0x3) << 28
    # reserved_30 | Offset: 30, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_30')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 30
    # salinity | Offset: 32, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'salinity')
    if field is None:
        raise Exception("Cant encode this message, missing 'Salinity'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 32
    # product_water_temperature | Offset: 48, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'product_water_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Product Water Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 48
    
    # pre_filter_pressure | Offset: 64, Length: 16, Resolution: 100, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pre_filter_pressure')
    if field is None:
        raise Exception("Cant encode this message, missing 'Pre-filter Pressure'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 100) & 0xFFFF) << 64
    
    # post_filter_pressure | Offset: 80, Length: 16, Resolution: 100, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'post_filter_pressure')
    if field is None:
        raise Exception("Cant encode this message, missing 'Post-filter Pressure'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 100) & 0xFFFF) << 80
    
    # feed_pressure | Offset: 96, Length: 16, Resolution: 1000, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'feed_pressure')
    if field is None:
        raise Exception("Cant encode this message, missing 'Feed Pressure'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1000) & 0xFFFF) << 96
    
    # system_high_pressure | Offset: 112, Length: 16, Resolution: 1000, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'system_high_pressure')
    if field is None:
        raise Exception("Cant encode this message, missing 'System High Pressure'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 1000) & 0xFFFF) << 112
    
    # product_water_flow | Offset: 128, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'product_water_flow')
    if field is None:
        raise Exception("Cant encode this message, missing 'Product Water Flow'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 128
    
    # brine_water_flow | Offset: 144, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'brine_water_flow')
    if field is None:
        raise Exception("Cant encode this message, missing 'Brine Water Flow'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 144
    
    # run_time | Offset: 160, Length: 32, Resolution: 1, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'run_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Run Time'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 160
    return data_raw


def is_fast_pgn_130569() -> bool:
    """Return True if PGN 130569 is a fast PGN."""
    return True
def decode_pgn_130569(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130569."""
    nmea2000Message = NMEA2000Message(130569, 'currentStatusAndFile', 'Current Status and File')
    running_bit_offset = 0
    # 1:zone | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    zone_raw = decode_int(_data_raw_, running_bit_offset, 8)
    zone = master_dict['ENTERTAINMENT_ZONE'].get(zone_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('zone', 'Zone', None, None, zone, zone_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:source | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    source_raw = decode_int(_data_raw_, running_bit_offset, 8)
    source = master_dict['ENTERTAINMENT_SOURCE'].get(source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('source', 'Source', None, None, source, source_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 3:number | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    number = number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number', 'Number', "Source number per type", None, number, number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:id | Offset: 24, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    id = id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('id', 'ID', "Unique file ID", None, id, id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 5:play_status | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    play_status_raw = decode_int(_data_raw_, running_bit_offset, 8)
    play_status = master_dict['ENTERTAINMENT_PLAY_STATUS'].get(play_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('play_status', 'Play status', None, None, play_status, play_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 6:elapsed_track_time | Offset: 64, Length: 16, Signed: False Resolution: 1, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    elapsed_track_time_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    elapsed_track_time = decode_time(elapsed_track_time_raw)
    nmea2000Message.fields.append(NMEA2000Field('elapsed_track_time', 'Elapsed Track Time', None, 's', elapsed_track_time, elapsed_track_time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    # 7:track_time | Offset: 80, Length: 16, Signed: False Resolution: 1, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    track_time_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    track_time = decode_time(track_time_raw)
    nmea2000Message.fields.append(NMEA2000Field('track_time', 'Track Time', None, 's', track_time, track_time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 16

    # 8:repeat_status | Offset: 96, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 96
    repeat_status_raw = decode_int(_data_raw_, running_bit_offset, 4)
    repeat_status = master_dict['ENTERTAINMENT_REPEAT_STATUS'].get(repeat_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_status', 'Repeat Status', None, None, repeat_status, repeat_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 9:shuffle_status | Offset: 100, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 100
    shuffle_status_raw = decode_int(_data_raw_, running_bit_offset, 4)
    shuffle_status = master_dict['ENTERTAINMENT_SHUFFLE_STATUS'].get(shuffle_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('shuffle_status', 'Shuffle Status', None, None, shuffle_status, shuffle_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 10:save_favorite_number | Offset: 104, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 104
    save_favorite_number = save_favorite_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('save_favorite_number', 'Save Favorite Number', "Used to command AV to save current station as favorite", None, save_favorite_number, save_favorite_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 11:play_favorite_number | Offset: 112, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    play_favorite_number = play_favorite_number_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('play_favorite_number', 'Play Favorite Number', "Used to command AV to play indicated favorite station", None, play_favorite_number, play_favorite_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 12:thumbs_up_down | Offset: 128, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 128
    thumbs_up_down_raw = decode_int(_data_raw_, running_bit_offset, 8)
    thumbs_up_down = master_dict['ENTERTAINMENT_LIKE_STATUS'].get(thumbs_up_down_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('thumbs_up_down', 'Thumbs Up/Down', None, None, thumbs_up_down, thumbs_up_down_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 13:signal_strength | Offset: 136, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 136
    signal_strength = signal_strength_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('signal_strength', 'Signal Strength', None, '%', signal_strength, signal_strength_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 14:radio_frequency | Offset: 144, Length: 32, Signed: False Resolution: 10, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    radio_frequency = radio_frequency_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 10)
    nmea2000Message.fields.append(NMEA2000Field('radio_frequency', 'Radio Frequency', None, 'Hz', radio_frequency, radio_frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 15:hd_frequency_multicast | Offset: 176, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 176
    hd_frequency_multicast = hd_frequency_multicast_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('hd_frequency_multicast', 'HD Frequency Multicast', "Digital sub channel", None, hd_frequency_multicast, hd_frequency_multicast_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 16:delete_favorite_number | Offset: 184, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 184
    delete_favorite_number = delete_favorite_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('delete_favorite_number', 'Delete Favorite Number', "Used to command AV to delete current station as favorite", None, delete_favorite_number, delete_favorite_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 17:total_number_of_tracks | Offset: 192, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 192
    total_number_of_tracks = total_number_of_tracks_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('total_number_of_tracks', 'Total Number of Tracks', None, None, total_number_of_tracks, total_number_of_tracks_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_130569(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130569."""
    data_raw = 0
    # zone | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'zone')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_ZONE(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # source | Offset: 8, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_SOURCE(field.value)
    data_raw |= (field_value & 0xFF) << 8
    # number | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # id | Offset: 24, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'id')
    if field is None:
        raise Exception("Cant encode this message, missing 'ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 24
    # play_status | Offset: 56, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'play_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Play status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_PLAY_STATUS(field.value)
    data_raw |= (field_value & 0xFF) << 56
    # elapsed_track_time | Offset: 64, Length: 16, Resolution: 1, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'elapsed_track_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Elapsed Track Time'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 64
    # track_time | Offset: 80, Length: 16, Resolution: 1, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'track_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Track Time'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 80
    # repeat_status | Offset: 96, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_REPEAT_STATUS(field.value)
    data_raw |= (field_value & 0xF) << 96
    # shuffle_status | Offset: 100, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'shuffle_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Shuffle Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_SHUFFLE_STATUS(field.value)
    data_raw |= (field_value & 0xF) << 100
    # save_favorite_number | Offset: 104, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'save_favorite_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Save Favorite Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 104
    # play_favorite_number | Offset: 112, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'play_favorite_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Play Favorite Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 112
    # thumbs_up_down | Offset: 128, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'thumbs_up_down')
    if field is None:
        raise Exception("Cant encode this message, missing 'Thumbs Up/Down'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_LIKE_STATUS(field.value)
    data_raw |= (field_value & 0xFF) << 128
    # signal_strength | Offset: 136, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'signal_strength')
    if field is None:
        raise Exception("Cant encode this message, missing 'Signal Strength'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 136
    # radio_frequency | Offset: 144, Length: 32, Resolution: 10, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'radio_frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'Radio Frequency'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 10) & 0xFFFFFFFF) << 144
    
    # hd_frequency_multicast | Offset: 176, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'hd_frequency_multicast')
    if field is None:
        raise Exception("Cant encode this message, missing 'HD Frequency Multicast'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 176
    # delete_favorite_number | Offset: 184, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'delete_favorite_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Delete Favorite Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 184
    # total_number_of_tracks | Offset: 192, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'total_number_of_tracks')
    if field is None:
        raise Exception("Cant encode this message, missing 'Total Number of Tracks'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 192
    return data_raw


def is_fast_pgn_130570() -> bool:
    """Return True if PGN 130570 is a fast PGN."""
    return True
def decode_pgn_130570(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130570."""
    nmea2000Message = NMEA2000Message(130570, 'libraryDataFile', 'Library Data File')
    running_bit_offset = 0
    # 1:source | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    source_raw = decode_int(_data_raw_, running_bit_offset, 8)
    source = master_dict['ENTERTAINMENT_SOURCE'].get(source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('source', 'Source', None, None, source, source_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:number | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    number = number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number', 'Number', "Source number per type", None, number, number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:id | Offset: 16, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    id = id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('id', 'ID', "Unique file ID", None, id, id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 4:type | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    type_raw = decode_int(_data_raw_, running_bit_offset, 8)
    type = master_dict['ENTERTAINMENT_TYPE'].get(type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('type', 'Type', None, None, type, type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    name = name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('name', 'Name', None, None, name, name_raw, None, FieldTypes.STRING_LAU, False))
    

    # 6:track | Offset: , Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    track = track_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('track', 'Track', None, None, track, track_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:station | Offset: , Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    station = station_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('station', 'Station', None, None, station, station_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:favorite | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    favorite = favorite_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('favorite', 'Favorite', None, None, favorite, favorite_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:radio_frequency | Offset: , Length: 32, Signed: False Resolution: 10, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    radio_frequency = radio_frequency_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 10)
    nmea2000Message.fields.append(NMEA2000Field('radio_frequency', 'Radio Frequency', None, 'Hz', radio_frequency, radio_frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 10:hd_frequency | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    hd_frequency = hd_frequency_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('hd_frequency', 'HD Frequency', None, None, hd_frequency, hd_frequency_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 11:zone | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    zone_raw = decode_int(_data_raw_, running_bit_offset, 8)
    zone = master_dict['ENTERTAINMENT_ZONE'].get(zone_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('zone', 'Zone', None, None, zone, zone_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 12:in_play_queue | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    in_play_queue_raw = decode_int(_data_raw_, running_bit_offset, 2)
    in_play_queue = master_dict['YES_NO'].get(in_play_queue_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('in_play_queue', 'In play queue', None, None, in_play_queue, in_play_queue_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 13:locked | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    locked_raw = decode_int(_data_raw_, running_bit_offset, 2)
    locked = master_dict['YES_NO'].get(locked_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('locked', 'Locked', None, None, locked, locked_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 14:reserved_ | Offset: , Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    reserved_ = reserved__raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_', 'Reserved', None, None, reserved_, reserved__raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 15:artist_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    artist_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    artist_name = artist_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('artist_name', 'Artist Name', None, None, artist_name, artist_name_raw, None, FieldTypes.STRING_LAU, False))
    

    # 16:album_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    album_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    album_name = album_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('album_name', 'Album Name', None, None, album_name, album_name_raw, None, FieldTypes.STRING_LAU, False))
    

    # 17:station_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    station_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    station_name = station_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('station_name', 'Station Name', None, None, station_name, station_name_raw, None, FieldTypes.STRING_LAU, False))
    

    return nmea2000Message

def encode_pgn_130570(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130570."""
    data_raw = 0
    # source | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_SOURCE(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # number | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # id | Offset: 16, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'id')
    if field is None:
        raise Exception("Cant encode this message, missing 'ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 16
    # type | Offset: 48, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_TYPE(field.value)
    data_raw |= (field_value & 0xFF) << 48
    raise Exception ("PGN 130570 not supporting encoding for now as Name is missing BitLength or BitOffset")
    raise Exception ("PGN 130570 not supporting encoding for now as Track is missing BitLength or BitOffset")
    raise Exception ("PGN 130570 not supporting encoding for now as Station is missing BitLength or BitOffset")
    raise Exception ("PGN 130570 not supporting encoding for now as Favorite is missing BitLength or BitOffset")
    raise Exception ("PGN 130570 not supporting encoding for now as Radio Frequency is missing BitLength or BitOffset")
    raise Exception ("PGN 130570 not supporting encoding for now as HD Frequency is missing BitLength or BitOffset")
    raise Exception ("PGN 130570 not supporting encoding for now as Zone is missing BitLength or BitOffset")
    raise Exception ("PGN 130570 not supporting encoding for now as In play queue is missing BitLength or BitOffset")
    raise Exception ("PGN 130570 not supporting encoding for now as Locked is missing BitLength or BitOffset")
    raise Exception ("PGN 130570 not supporting encoding for now as Reserved is missing BitLength or BitOffset")
    raise Exception ("PGN 130570 not supporting encoding for now as Artist Name is missing BitLength or BitOffset")
    raise Exception ("PGN 130570 not supporting encoding for now as Album Name is missing BitLength or BitOffset")
    raise Exception ("PGN 130570 not supporting encoding for now as Station Name is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130571() -> bool:
    """Return True if PGN 130571 is a fast PGN."""
    return True
def decode_pgn_130571(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130571."""
    nmea2000Message = NMEA2000Message(130571, 'libraryDataGroup', 'Library Data Group')
    running_bit_offset = 0
    # 1:source | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    source_raw = decode_int(_data_raw_, running_bit_offset, 8)
    source = master_dict['ENTERTAINMENT_SOURCE'].get(source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('source', 'Source', None, None, source, source_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:number | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    number = number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number', 'Number', "Source number per type", None, number, number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:type | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    type_raw = decode_int(_data_raw_, running_bit_offset, 8)
    type = master_dict['ENTERTAINMENT_TYPE'].get(type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('type', 'Type', None, None, type, type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 4:zone | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    zone_raw = decode_int(_data_raw_, running_bit_offset, 8)
    zone = master_dict['ENTERTAINMENT_ZONE'].get(zone_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('zone', 'Zone', None, None, zone, zone_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:group_id | Offset: 32, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    group_id = group_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('group_id', 'Group ID', "Unique group ID", None, group_id, group_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:id_offset | Offset: 64, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    id_offset = id_offset_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('id_offset', 'ID offset', "First ID in this PGN", None, id_offset, id_offset_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:id_count | Offset: 80, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    id_count = id_count_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('id_count', 'ID count', "Number of IDs in this PGN", None, id_count, id_count_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:total_id_count | Offset: 96, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 96
    total_id_count = total_id_count_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('total_id_count', 'Total ID count', "Total IDs in group", None, total_id_count, total_id_count_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:id_type | Offset: 112, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    id_type_raw = decode_int(_data_raw_, running_bit_offset, 8)
    id_type = master_dict['ENTERTAINMENT_ID_TYPE'].get(id_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('id_type', 'ID type', None, None, id_type, id_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 10:id | Offset: 120, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    id = id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('id', 'ID', None, None, id, id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 11:name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    name = name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('name', 'Name', None, None, name, name_raw, None, FieldTypes.STRING_LAU, False))
    

    # 12:artist | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    artist_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    artist = artist_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('artist', 'Artist', None, None, artist, artist_raw, None, FieldTypes.STRING_LAU, False))
    

    return nmea2000Message

def encode_pgn_130571(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130571."""
    data_raw = 0
    # source | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_SOURCE(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # number | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # type | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_TYPE(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # zone | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'zone')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_ZONE(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # group_id | Offset: 32, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'group_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Group ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    # id_offset | Offset: 64, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'id_offset')
    if field is None:
        raise Exception("Cant encode this message, missing 'ID offset'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 64
    # id_count | Offset: 80, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'id_count')
    if field is None:
        raise Exception("Cant encode this message, missing 'ID count'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 80
    # total_id_count | Offset: 96, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'total_id_count')
    if field is None:
        raise Exception("Cant encode this message, missing 'Total ID count'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 96
    # id_type | Offset: 112, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'id_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'ID type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_ID_TYPE(field.value)
    data_raw |= (field_value & 0xFF) << 112
    # id | Offset: 120, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'id')
    if field is None:
        raise Exception("Cant encode this message, missing 'ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 120
    raise Exception ("PGN 130571 not supporting encoding for now as Name is missing BitLength or BitOffset")
    raise Exception ("PGN 130571 not supporting encoding for now as Artist is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130572() -> bool:
    """Return True if PGN 130572 is a fast PGN."""
    return True
def decode_pgn_130572(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130572."""
    nmea2000Message = NMEA2000Message(130572, 'libraryDataSearch', 'Library Data Search')
    running_bit_offset = 0
    # 1:source | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    source_raw = decode_int(_data_raw_, running_bit_offset, 8)
    source = master_dict['ENTERTAINMENT_SOURCE'].get(source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('source', 'Source', None, None, source, source_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:number | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    number = number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number', 'Number', "Source number per type", None, number, number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:group_id | Offset: 16, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    group_id = group_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('group_id', 'Group ID', "Unique group ID", None, group_id, group_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 4:group_type_1 | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    group_type_1_raw = decode_int(_data_raw_, running_bit_offset, 8)
    group_type_1 = master_dict['ENTERTAINMENT_GROUP'].get(group_type_1_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('group_type_1', 'Group type 1', None, None, group_type_1, group_type_1_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:group_name_1 | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    group_name_1_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    group_name_1 = group_name_1_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('group_name_1', 'Group name 1', None, None, group_name_1, group_name_1_raw, None, FieldTypes.STRING_LAU, False))
    

    # 6:group_type_2 | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    group_type_2_raw = decode_int(_data_raw_, running_bit_offset, 8)
    group_type_2 = master_dict['ENTERTAINMENT_GROUP'].get(group_type_2_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('group_type_2', 'Group type 2', None, None, group_type_2, group_type_2_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:group_name_2 | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    group_name_2_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    group_name_2 = group_name_2_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('group_name_2', 'Group name 2', None, None, group_name_2, group_name_2_raw, None, FieldTypes.STRING_LAU, False))
    

    # 8:group_type_3 | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    group_type_3_raw = decode_int(_data_raw_, running_bit_offset, 8)
    group_type_3 = master_dict['ENTERTAINMENT_GROUP'].get(group_type_3_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('group_type_3', 'Group type 3', None, None, group_type_3, group_type_3_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 9:group_name_3 | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    group_name_3_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    group_name_3 = group_name_3_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('group_name_3', 'Group name 3', None, None, group_name_3, group_name_3_raw, None, FieldTypes.STRING_LAU, False))
    

    return nmea2000Message

def encode_pgn_130572(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130572."""
    data_raw = 0
    # source | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_SOURCE(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # number | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # group_id | Offset: 16, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'group_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Group ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 16
    # group_type_1 | Offset: 48, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'group_type_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Group type 1'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_GROUP(field.value)
    data_raw |= (field_value & 0xFF) << 48
    raise Exception ("PGN 130572 not supporting encoding for now as Group name 1 is missing BitLength or BitOffset")
    raise Exception ("PGN 130572 not supporting encoding for now as Group type 2 is missing BitLength or BitOffset")
    raise Exception ("PGN 130572 not supporting encoding for now as Group name 2 is missing BitLength or BitOffset")
    raise Exception ("PGN 130572 not supporting encoding for now as Group type 3 is missing BitLength or BitOffset")
    raise Exception ("PGN 130572 not supporting encoding for now as Group name 3 is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130573() -> bool:
    """Return True if PGN 130573 is a fast PGN."""
    return True
def decode_pgn_130573(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130573."""
    nmea2000Message = NMEA2000Message(130573, 'supportedSourceData', 'Supported Source Data')
    running_bit_offset = 0
    # 1:id_offset | Offset: 0, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    id_offset = id_offset_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('id_offset', 'ID offset', "First ID in this PGN", None, id_offset, id_offset_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:id_count | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    id_count = id_count_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('id_count', 'ID count', "Number of IDs in this PGN", None, id_count, id_count_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:total_id_count | Offset: 32, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    total_id_count = total_id_count_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('total_id_count', 'Total ID count', "Total IDs in group", None, total_id_count, total_id_count_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:id | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    id = id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('id', 'ID', "Source ID", None, id, id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:source | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    source_raw = decode_int(_data_raw_, running_bit_offset, 8)
    source = master_dict['ENTERTAINMENT_SOURCE'].get(source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('source', 'Source', None, None, source, source_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 6:number | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    number = number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number', 'Number', "Source number per type", None, number, number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    name = name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('name', 'Name', None, None, name, name_raw, None, FieldTypes.STRING_LAU, False))
    

    # 8:play_support | Offset: , Length: 32, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    play_support_raw = decode_int(_data_raw_, running_bit_offset, 32)
    play_support = decode_bit_lookup(play_support_raw, master_flags_dict['ENTERTAINMENT_PLAY_STATUS_BITFIELD'])
    nmea2000Message.fields.append(NMEA2000Field('play_support', 'Play support', None, None, play_support, play_support_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 32

    # 9:browse_support | Offset: , Length: 16, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    browse_support_raw = decode_int(_data_raw_, running_bit_offset, 16)
    browse_support = decode_bit_lookup(browse_support_raw, master_flags_dict['ENTERTAINMENT_GROUP_BITFIELD'])
    nmea2000Message.fields.append(NMEA2000Field('browse_support', 'Browse support', None, None, browse_support, browse_support_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 16

    # 10:thumbs_support | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    thumbs_support_raw = decode_int(_data_raw_, running_bit_offset, 2)
    thumbs_support = master_dict['YES_NO'].get(thumbs_support_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('thumbs_support', 'Thumbs support', None, None, thumbs_support, thumbs_support_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 11:connected | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    connected_raw = decode_int(_data_raw_, running_bit_offset, 2)
    connected = master_dict['YES_NO'].get(connected_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('connected', 'Connected', None, None, connected, connected_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 12:repeat_support | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    repeat_support_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_support = decode_bit_lookup(repeat_support_raw, master_flags_dict['ENTERTAINMENT_REPEAT_BITFIELD'])
    nmea2000Message.fields.append(NMEA2000Field('repeat_support', 'Repeat support', None, None, repeat_support, repeat_support_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 2

    # 13:shuffle_support | Offset: , Length: 2, Signed: False Resolution: 1, Field Type: BITLOOKUP, Match: , PartOfPrimaryKey: ,
    shuffle_support_raw = decode_int(_data_raw_, running_bit_offset, 2)
    shuffle_support = decode_bit_lookup(shuffle_support_raw, master_flags_dict['ENTERTAINMENT_SHUFFLE_BITFIELD'])
    nmea2000Message.fields.append(NMEA2000Field('shuffle_support', 'Shuffle support', None, None, shuffle_support, shuffle_support_raw, None, FieldTypes.BITLOOKUP, False))
    running_bit_offset += 2

    return nmea2000Message

def encode_pgn_130573(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130573."""
    data_raw = 0
    # id_offset | Offset: 0, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'id_offset')
    if field is None:
        raise Exception("Cant encode this message, missing 'ID offset'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 0
    # id_count | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'id_count')
    if field is None:
        raise Exception("Cant encode this message, missing 'ID count'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # total_id_count | Offset: 32, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'total_id_count')
    if field is None:
        raise Exception("Cant encode this message, missing 'Total ID count'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 32
    # id | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'id')
    if field is None:
        raise Exception("Cant encode this message, missing 'ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # source | Offset: 56, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_SOURCE(field.value)
    data_raw |= (field_value & 0xFF) << 56
    # number | Offset: 64, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 64
    raise Exception ("PGN 130573 not supporting encoding for now as Name is missing BitLength or BitOffset")
    raise Exception ("PGN 130573 not supporting encoding for now as Play support is missing BitLength or BitOffset")
    raise Exception ("PGN 130573 not supporting encoding for now as Browse support is missing BitLength or BitOffset")
    raise Exception ("PGN 130573 not supporting encoding for now as Thumbs support is missing BitLength or BitOffset")
    raise Exception ("PGN 130573 not supporting encoding for now as Connected is missing BitLength or BitOffset")
    raise Exception ("PGN 130573 not supporting encoding for now as Repeat support is missing BitLength or BitOffset")
    raise Exception ("PGN 130573 not supporting encoding for now as Shuffle support is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130574() -> bool:
    """Return True if PGN 130574 is a fast PGN."""
    return True
def decode_pgn_130574(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130574."""
    nmea2000Message = NMEA2000Message(130574, 'supportedZoneData', 'Supported Zone Data')
    running_bit_offset = 0
    # 1:first_zone_id | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    first_zone_id = first_zone_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('first_zone_id', 'First zone ID', "First Zone in this PGN", None, first_zone_id, first_zone_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:zone_count | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    zone_count = zone_count_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone_count', 'Zone count', "Number of Zones in this PGN", None, zone_count, zone_count_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:total_zone_count | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    total_zone_count = total_zone_count_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('total_zone_count', 'Total zone count', "Total Zones supported by this device", None, total_zone_count, total_zone_count_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:zone_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    zone_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    zone_id = master_dict['ENTERTAINMENT_ZONE'].get(zone_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('zone_id', 'Zone ID', None, None, zone_id, zone_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    name = name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('name', 'Name', None, None, name, name_raw, None, FieldTypes.STRING_LAU, False))
    

    return nmea2000Message

def encode_pgn_130574(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130574."""
    data_raw = 0
    # first_zone_id | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'first_zone_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'First zone ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # zone_count | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zone_count')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone count'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # total_zone_count | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'total_zone_count')
    if field is None:
        raise Exception("Cant encode this message, missing 'Total zone count'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # zone_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'zone_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_ZONE(field.value)
    data_raw |= (field_value & 0xFF) << 24
    raise Exception ("PGN 130574 not supporting encoding for now as Name is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130576() -> bool:
    """Return True if PGN 130576 is a fast PGN."""
    return False
def decode_pgn_130576(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130576."""
    nmea2000Message = NMEA2000Message(130576, 'smallCraftStatus', 'Small Craft Status')
    running_bit_offset = 0
    # 1:port_trim_tab | Offset: 0, Length: 8, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    port_trim_tab = port_trim_tab_raw = decode_number(_data_raw_, running_bit_offset, 8, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('port_trim_tab', 'Port trim tab', None, '%', port_trim_tab, port_trim_tab_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:starboard_trim_tab | Offset: 8, Length: 8, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    starboard_trim_tab = starboard_trim_tab_raw = decode_number(_data_raw_, running_bit_offset, 8, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('starboard_trim_tab', 'Starboard trim tab', None, '%', starboard_trim_tab, starboard_trim_tab_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:reserved_16 | Offset: 16, Length: 48, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 48)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 48

    return nmea2000Message

def encode_pgn_130576(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130576."""
    data_raw = 0
    # port_trim_tab | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'port_trim_tab')
    if field is None:
        raise Exception("Cant encode this message, missing 'Port trim tab'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # starboard_trim_tab | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'starboard_trim_tab')
    if field is None:
        raise Exception("Cant encode this message, missing 'Starboard trim tab'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # reserved_16 | Offset: 16, Length: 48, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFF) << 16
    return data_raw


def is_fast_pgn_130577() -> bool:
    """Return True if PGN 130577 is a fast PGN."""
    return True
def decode_pgn_130577(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130577."""
    nmea2000Message = NMEA2000Message(130577, 'directionData', 'Direction Data')
    running_bit_offset = 0
    # 1:data_mode | Offset: 0, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    data_mode_raw = decode_int(_data_raw_, running_bit_offset, 4)
    data_mode = master_dict['RESIDUAL_MODE'].get(data_mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('data_mode', 'Data Mode', None, None, data_mode, data_mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 2:cog_reference | Offset: 4, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 4
    cog_reference_raw = decode_int(_data_raw_, running_bit_offset, 2)
    cog_reference = master_dict['DIRECTION_REFERENCE'].get(cog_reference_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('cog_reference', 'COG Reference', None, None, cog_reference, cog_reference_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:reserved_6 | Offset: 6, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 6
    reserved_6 = reserved_6_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_6', 'Reserved', None, None, reserved_6, reserved_6_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 4:sid | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:cog | Offset: 16, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    cog = cog_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('cog', 'COG', None, 'rad', cog, cog_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:sog | Offset: 32, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    sog = sog_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('sog', 'SOG', None, 'm/s', sog, sog_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:heading | Offset: 48, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    heading = heading_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('heading', 'Heading', None, 'rad', heading, heading_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:speed_through_water | Offset: 64, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    speed_through_water = speed_through_water_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('speed_through_water', 'Speed through Water', None, 'm/s', speed_through_water, speed_through_water_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:set | Offset: 80, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    set = set_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('set', 'Set', None, 'rad', set, set_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 10:drift | Offset: 96, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 96
    drift = drift_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('drift', 'Drift', None, 'm/s', drift, drift_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_130577(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130577."""
    data_raw = 0
    # data_mode | Offset: 0, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'data_mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_RESIDUAL_MODE(field.value)
    data_raw |= (field_value & 0xF) << 0
    # cog_reference | Offset: 4, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'cog_reference')
    if field is None:
        raise Exception("Cant encode this message, missing 'COG Reference'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_DIRECTION_REFERENCE(field.value)
    data_raw |= (field_value & 0x3) << 4
    # reserved_6 | Offset: 6, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_6')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 6
    # sid | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # cog | Offset: 16, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'cog')
    if field is None:
        raise Exception("Cant encode this message, missing 'COG'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 16
    
    # sog | Offset: 32, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sog')
    if field is None:
        raise Exception("Cant encode this message, missing 'SOG'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 32
    
    # heading | Offset: 48, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'heading')
    if field is None:
        raise Exception("Cant encode this message, missing 'Heading'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 48
    
    # speed_through_water | Offset: 64, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'speed_through_water')
    if field is None:
        raise Exception("Cant encode this message, missing 'Speed through Water'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 64
    
    # set | Offset: 80, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'set')
    if field is None:
        raise Exception("Cant encode this message, missing 'Set'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 80
    
    # drift | Offset: 96, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'drift')
    if field is None:
        raise Exception("Cant encode this message, missing 'Drift'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 96
    
    return data_raw


def is_fast_pgn_130578() -> bool:
    """Return True if PGN 130578 is a fast PGN."""
    return True
def decode_pgn_130578(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130578."""
    nmea2000Message = NMEA2000Message(130578, 'vesselSpeedComponents', 'Vessel Speed Components')
    running_bit_offset = 0
    # 1:longitudinal_speed__water_referenced | Offset: 0, Length: 16, Signed: True Resolution: 0.001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    longitudinal_speed__water_referenced = longitudinal_speed__water_referenced_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.001)
    nmea2000Message.fields.append(NMEA2000Field('longitudinal_speed__water_referenced', 'Longitudinal Speed, Water-referenced', None, 'm/s', longitudinal_speed__water_referenced, longitudinal_speed__water_referenced_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 2:transverse_speed__water_referenced | Offset: 16, Length: 16, Signed: True Resolution: 0.001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    transverse_speed__water_referenced = transverse_speed__water_referenced_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.001)
    nmea2000Message.fields.append(NMEA2000Field('transverse_speed__water_referenced', 'Transverse Speed, Water-referenced', None, 'm/s', transverse_speed__water_referenced, transverse_speed__water_referenced_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 3:longitudinal_speed__ground_referenced | Offset: 32, Length: 16, Signed: True Resolution: 0.001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    longitudinal_speed__ground_referenced = longitudinal_speed__ground_referenced_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.001)
    nmea2000Message.fields.append(NMEA2000Field('longitudinal_speed__ground_referenced', 'Longitudinal Speed, Ground-referenced', None, 'm/s', longitudinal_speed__ground_referenced, longitudinal_speed__ground_referenced_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 4:transverse_speed__ground_referenced | Offset: 48, Length: 16, Signed: True Resolution: 0.001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    transverse_speed__ground_referenced = transverse_speed__ground_referenced_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.001)
    nmea2000Message.fields.append(NMEA2000Field('transverse_speed__ground_referenced', 'Transverse Speed, Ground-referenced', None, 'm/s', transverse_speed__ground_referenced, transverse_speed__ground_referenced_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:stern_speed__water_referenced | Offset: 64, Length: 16, Signed: True Resolution: 0.001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    stern_speed__water_referenced = stern_speed__water_referenced_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.001)
    nmea2000Message.fields.append(NMEA2000Field('stern_speed__water_referenced', 'Stern Speed, Water-referenced', None, 'm/s', stern_speed__water_referenced, stern_speed__water_referenced_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:stern_speed__ground_referenced | Offset: 80, Length: 16, Signed: True Resolution: 0.001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    stern_speed__ground_referenced = stern_speed__ground_referenced_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.001)
    nmea2000Message.fields.append(NMEA2000Field('stern_speed__ground_referenced', 'Stern Speed, Ground-referenced', None, 'm/s', stern_speed__ground_referenced, stern_speed__ground_referenced_raw, PhysicalQuantities.SPEED, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_130578(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130578."""
    data_raw = 0
    # longitudinal_speed__water_referenced | Offset: 0, Length: 16, Resolution: 0.001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'longitudinal_speed__water_referenced')
    if field is None:
        raise Exception("Cant encode this message, missing 'Longitudinal Speed, Water-referenced'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFF) << 0
    
    # transverse_speed__water_referenced | Offset: 16, Length: 16, Resolution: 0.001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'transverse_speed__water_referenced')
    if field is None:
        raise Exception("Cant encode this message, missing 'Transverse Speed, Water-referenced'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFF) << 16
    
    # longitudinal_speed__ground_referenced | Offset: 32, Length: 16, Resolution: 0.001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'longitudinal_speed__ground_referenced')
    if field is None:
        raise Exception("Cant encode this message, missing 'Longitudinal Speed, Ground-referenced'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFF) << 32
    
    # transverse_speed__ground_referenced | Offset: 48, Length: 16, Resolution: 0.001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'transverse_speed__ground_referenced')
    if field is None:
        raise Exception("Cant encode this message, missing 'Transverse Speed, Ground-referenced'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFF) << 48
    
    # stern_speed__water_referenced | Offset: 64, Length: 16, Resolution: 0.001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'stern_speed__water_referenced')
    if field is None:
        raise Exception("Cant encode this message, missing 'Stern Speed, Water-referenced'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFF) << 64
    
    # stern_speed__ground_referenced | Offset: 80, Length: 16, Resolution: 0.001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'stern_speed__ground_referenced')
    if field is None:
        raise Exception("Cant encode this message, missing 'Stern Speed, Ground-referenced'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFF) << 80
    
    return data_raw


def is_fast_pgn_130579() -> bool:
    """Return True if PGN 130579 is a fast PGN."""
    return False
def decode_pgn_130579(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130579."""
    nmea2000Message = NMEA2000Message(130579, 'systemConfiguration', 'System Configuration')
    running_bit_offset = 0
    # 1:power | Offset: 0, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    power_raw = decode_int(_data_raw_, running_bit_offset, 2)
    power = master_dict['YES_NO'].get(power_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('power', 'Power', None, None, power, power_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 2:default_settings | Offset: 2, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 2
    default_settings_raw = decode_int(_data_raw_, running_bit_offset, 2)
    default_settings = master_dict['ENTERTAINMENT_DEFAULT_SETTINGS'].get(default_settings_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('default_settings', 'Default Settings', None, None, default_settings, default_settings_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:tuner_regions | Offset: 4, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 4
    tuner_regions_raw = decode_int(_data_raw_, running_bit_offset, 4)
    tuner_regions = master_dict['ENTERTAINMENT_REGIONS'].get(tuner_regions_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('tuner_regions', 'Tuner regions', None, None, tuner_regions, tuner_regions_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 4:max_favorites | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    max_favorites = max_favorites_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('max_favorites', 'Max favorites', None, None, max_favorites, max_favorites_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:video_protocols | Offset: 16, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    video_protocols_raw = decode_int(_data_raw_, running_bit_offset, 4)
    video_protocols = master_dict['VIDEO_PROTOCOLS'].get(video_protocols_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('video_protocols', 'Video protocols', None, None, video_protocols, video_protocols_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 6:reserved_20 | Offset: 20, Length: 44, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 20
    reserved_20 = reserved_20_raw = decode_int(_data_raw_, running_bit_offset, 44)
    nmea2000Message.fields.append(NMEA2000Field('reserved_20', 'Reserved', None, None, reserved_20, reserved_20_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 44

    return nmea2000Message

def encode_pgn_130579(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130579."""
    data_raw = 0
    # power | Offset: 0, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 0
    # default_settings | Offset: 2, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'default_settings')
    if field is None:
        raise Exception("Cant encode this message, missing 'Default Settings'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_DEFAULT_SETTINGS(field.value)
    data_raw |= (field_value & 0x3) << 2
    # tuner_regions | Offset: 4, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'tuner_regions')
    if field is None:
        raise Exception("Cant encode this message, missing 'Tuner regions'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_REGIONS(field.value)
    data_raw |= (field_value & 0xF) << 4
    # max_favorites | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'max_favorites')
    if field is None:
        raise Exception("Cant encode this message, missing 'Max favorites'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # video_protocols | Offset: 16, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'video_protocols')
    if field is None:
        raise Exception("Cant encode this message, missing 'Video protocols'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_VIDEO_PROTOCOLS(field.value)
    data_raw |= (field_value & 0xF) << 16
    # reserved_20 | Offset: 20, Length: 44, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_20')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFF) << 20
    return data_raw


def is_fast_pgn_130580() -> bool:
    """Return True if PGN 130580 is a fast PGN."""
    return True
def decode_pgn_130580(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130580."""
    nmea2000Message = NMEA2000Message(130580, 'systemConfigurationDeprecated', 'System Configuration (deprecated)')
    running_bit_offset = 0
    # 1:power | Offset: 0, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    power_raw = decode_int(_data_raw_, running_bit_offset, 2)
    power = master_dict['YES_NO'].get(power_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('power', 'Power', None, None, power, power_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 2:default_settings | Offset: 2, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 2
    default_settings_raw = decode_int(_data_raw_, running_bit_offset, 2)
    default_settings = master_dict['ENTERTAINMENT_DEFAULT_SETTINGS'].get(default_settings_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('default_settings', 'Default Settings', None, None, default_settings, default_settings_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 3:tuner_regions | Offset: 4, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 4
    tuner_regions_raw = decode_int(_data_raw_, running_bit_offset, 4)
    tuner_regions = master_dict['ENTERTAINMENT_REGIONS'].get(tuner_regions_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('tuner_regions', 'Tuner regions', None, None, tuner_regions, tuner_regions_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 4:max_favorites | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    max_favorites = max_favorites_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('max_favorites', 'Max favorites', None, None, max_favorites, max_favorites_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130580(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130580."""
    data_raw = 0
    # power | Offset: 0, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'power')
    if field is None:
        raise Exception("Cant encode this message, missing 'Power'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 0
    # default_settings | Offset: 2, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'default_settings')
    if field is None:
        raise Exception("Cant encode this message, missing 'Default Settings'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_DEFAULT_SETTINGS(field.value)
    data_raw |= (field_value & 0x3) << 2
    # tuner_regions | Offset: 4, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'tuner_regions')
    if field is None:
        raise Exception("Cant encode this message, missing 'Tuner regions'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_REGIONS(field.value)
    data_raw |= (field_value & 0xF) << 4
    # max_favorites | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'max_favorites')
    if field is None:
        raise Exception("Cant encode this message, missing 'Max favorites'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    return data_raw


def is_fast_pgn_130581() -> bool:
    """Return True if PGN 130581 is a fast PGN."""
    return True
def decode_pgn_130581(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130581."""
    nmea2000Message = NMEA2000Message(130581, 'zoneConfigurationDeprecated', 'Zone Configuration (deprecated)')
    running_bit_offset = 0
    # 1:first_zone_id | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    first_zone_id = first_zone_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('first_zone_id', 'First zone ID', "First Zone in this PGN", None, first_zone_id, first_zone_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:zone_count | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    zone_count = zone_count_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone_count', 'Zone count', "Number of Zones in this PGN", None, zone_count, zone_count_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:total_zone_count | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    total_zone_count = total_zone_count_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('total_zone_count', 'Total zone count', "Total Zones supported by this device", None, total_zone_count, total_zone_count_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:zone_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    zone_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    zone_id = master_dict['ENTERTAINMENT_ZONE'].get(zone_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('zone_id', 'Zone ID', None, None, zone_id, zone_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:zone_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    zone_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    zone_name = zone_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('zone_name', 'Zone name', None, None, zone_name, zone_name_raw, None, FieldTypes.STRING_LAU, False))
    

    return nmea2000Message

def encode_pgn_130581(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130581."""
    data_raw = 0
    # first_zone_id | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'first_zone_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'First zone ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # zone_count | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zone_count')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone count'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # total_zone_count | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'total_zone_count')
    if field is None:
        raise Exception("Cant encode this message, missing 'Total zone count'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # zone_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'zone_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_ZONE(field.value)
    data_raw |= (field_value & 0xFF) << 24
    raise Exception ("PGN 130581 not supporting encoding for now as Zone name is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130582() -> bool:
    """Return True if PGN 130582 is a fast PGN."""
    return False
def decode_pgn_130582(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130582."""
    nmea2000Message = NMEA2000Message(130582, 'zoneVolume', 'Zone Volume')
    running_bit_offset = 0
    # 1:zone_id | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    zone_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    zone_id = master_dict['ENTERTAINMENT_ZONE'].get(zone_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('zone_id', 'Zone ID', None, None, zone_id, zone_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:volume | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    volume = volume_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('volume', 'Volume', None, '%', volume, volume_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:volume_change | Offset: 16, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    volume_change_raw = decode_int(_data_raw_, running_bit_offset, 2)
    volume_change = master_dict['ENTERTAINMENT_VOLUME_CONTROL'].get(volume_change_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('volume_change', 'Volume change', "Write only", None, volume_change, volume_change_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:mute | Offset: 18, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 18
    mute_raw = decode_int(_data_raw_, running_bit_offset, 2)
    mute = master_dict['YES_NO'].get(mute_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('mute', 'Mute', None, None, mute, mute_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 5:reserved_20 | Offset: 20, Length: 4, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 20
    reserved_20 = reserved_20_raw = decode_int(_data_raw_, running_bit_offset, 4)
    nmea2000Message.fields.append(NMEA2000Field('reserved_20', 'Reserved', None, None, reserved_20, reserved_20_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 4

    # 6:channel | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    channel_raw = decode_int(_data_raw_, running_bit_offset, 8)
    channel = master_dict['ENTERTAINMENT_CHANNEL'].get(channel_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('channel', 'Channel', None, None, channel, channel_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:reserved_32 | Offset: 32, Length: 32, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    reserved_32 = reserved_32_raw = decode_int(_data_raw_, running_bit_offset, 32)
    nmea2000Message.fields.append(NMEA2000Field('reserved_32', 'Reserved', None, None, reserved_32, reserved_32_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_130582(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130582."""
    data_raw = 0
    # zone_id | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'zone_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_ZONE(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # volume | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'volume')
    if field is None:
        raise Exception("Cant encode this message, missing 'Volume'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # volume_change | Offset: 16, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'volume_change')
    if field is None:
        raise Exception("Cant encode this message, missing 'Volume change'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_VOLUME_CONTROL(field.value)
    data_raw |= (field_value & 0x3) << 16
    # mute | Offset: 18, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'mute')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mute'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 18
    # reserved_20 | Offset: 20, Length: 4, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_20')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 20
    # channel | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'channel')
    if field is None:
        raise Exception("Cant encode this message, missing 'Channel'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_CHANNEL(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # reserved_32 | Offset: 32, Length: 32, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_32')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 32
    return data_raw


def is_fast_pgn_130583() -> bool:
    """Return True if PGN 130583 is a fast PGN."""
    return True
def decode_pgn_130583(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130583."""
    nmea2000Message = NMEA2000Message(130583, 'availableAudioEqPresets', 'Available Audio EQ presets')
    running_bit_offset = 0
    # 1:first_preset | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    first_preset = first_preset_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('first_preset', 'First preset', "First preset in this PGN", None, first_preset, first_preset_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:preset_count | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    preset_count = preset_count_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('preset_count', 'Preset count', None, None, preset_count, preset_count_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:total_preset_count | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    total_preset_count = total_preset_count_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('total_preset_count', 'Total preset count', None, None, total_preset_count, total_preset_count_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:preset_type | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    preset_type_raw = decode_int(_data_raw_, running_bit_offset, 8)
    preset_type = master_dict['ENTERTAINMENT_EQ'].get(preset_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('preset_type', 'Preset type', None, None, preset_type, preset_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:preset_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    preset_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    preset_name = preset_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('preset_name', 'Preset name', None, None, preset_name, preset_name_raw, None, FieldTypes.STRING_LAU, False))
    

    return nmea2000Message

def encode_pgn_130583(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130583."""
    data_raw = 0
    # first_preset | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'first_preset')
    if field is None:
        raise Exception("Cant encode this message, missing 'First preset'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # preset_count | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'preset_count')
    if field is None:
        raise Exception("Cant encode this message, missing 'Preset count'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # total_preset_count | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'total_preset_count')
    if field is None:
        raise Exception("Cant encode this message, missing 'Total preset count'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # preset_type | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'preset_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Preset type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_EQ(field.value)
    data_raw |= (field_value & 0xFF) << 24
    raise Exception ("PGN 130583 not supporting encoding for now as Preset name is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130584() -> bool:
    """Return True if PGN 130584 is a fast PGN."""
    return True
def decode_pgn_130584(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130584."""
    nmea2000Message = NMEA2000Message(130584, 'availableBluetoothAddresses', 'Available Bluetooth addresses')
    running_bit_offset = 0
    # 1:first_address | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    first_address = first_address_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('first_address', 'First address', "First address in this PGN", None, first_address, first_address_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:address_count | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    address_count = address_count_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('address_count', 'Address count', None, None, address_count, address_count_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:total_address_count | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    total_address_count = total_address_count_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('total_address_count', 'Total address count', None, None, total_address_count, total_address_count_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:bluetooth_address | Offset: 24, Length: 48, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    bluetooth_address = bluetooth_address_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 48))
    nmea2000Message.fields.append(NMEA2000Field('bluetooth_address', 'Bluetooth address', None, None, bluetooth_address, bluetooth_address_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 48

    # 5:status | Offset: 72, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    status_raw = decode_int(_data_raw_, running_bit_offset, 8)
    status = master_dict['BLUETOOTH_STATUS'].get(status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('status', 'Status', None, None, status, status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 6:device_name | Offset: , Length: , Signed: False Resolution: , Field Type: STRING_LAU, Match: , PartOfPrimaryKey: ,
    device_name_raw, bits_to_skip = decode_string_lau(_data_raw_, running_bit_offset)
    device_name = device_name_raw
    running_bit_offset += bits_to_skip
    nmea2000Message.fields.append(NMEA2000Field('device_name', 'Device name', None, None, device_name, device_name_raw, None, FieldTypes.STRING_LAU, False))
    

    # 7:signal_strength | Offset: , Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    signal_strength = signal_strength_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('signal_strength', 'Signal strength', None, '%', signal_strength, signal_strength_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130584(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130584."""
    data_raw = 0
    # first_address | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'first_address')
    if field is None:
        raise Exception("Cant encode this message, missing 'First address'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # address_count | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'address_count')
    if field is None:
        raise Exception("Cant encode this message, missing 'Address count'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # total_address_count | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'total_address_count')
    if field is None:
        raise Exception("Cant encode this message, missing 'Total address count'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # bluetooth_address | Offset: 24, Length: 48, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'bluetooth_address')
    if field is None:
        raise Exception("Cant encode this message, missing 'Bluetooth address'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFF) << 24
    # status | Offset: 72, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_BLUETOOTH_STATUS(field.value)
    data_raw |= (field_value & 0xFF) << 72
    raise Exception ("PGN 130584 not supporting encoding for now as Device name is missing BitLength or BitOffset")
    raise Exception ("PGN 130584 not supporting encoding for now as Signal strength is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130585() -> bool:
    """Return True if PGN 130585 is a fast PGN."""
    return False
def decode_pgn_130585(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130585."""
    nmea2000Message = NMEA2000Message(130585, 'bluetoothSourceStatus', 'Bluetooth source status')
    running_bit_offset = 0
    # 1:source_number | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    source_number = source_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('source_number', 'Source number', None, None, source_number, source_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 2:status | Offset: 8, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    status_raw = decode_int(_data_raw_, running_bit_offset, 4)
    status = master_dict['BLUETOOTH_SOURCE_STATUS'].get(status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('status', 'Status', None, None, status, status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 3:forget_device | Offset: 12, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 12
    forget_device_raw = decode_int(_data_raw_, running_bit_offset, 2)
    forget_device = master_dict['YES_NO'].get(forget_device_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('forget_device', 'Forget device', None, None, forget_device, forget_device_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 4:discovering | Offset: 14, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 14
    discovering_raw = decode_int(_data_raw_, running_bit_offset, 2)
    discovering = master_dict['YES_NO'].get(discovering_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('discovering', 'Discovering', None, None, discovering, discovering_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 5:bluetooth_address | Offset: 16, Length: 48, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    bluetooth_address = bluetooth_address_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 48))
    nmea2000Message.fields.append(NMEA2000Field('bluetooth_address', 'Bluetooth address', None, None, bluetooth_address, bluetooth_address_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 48

    return nmea2000Message

def encode_pgn_130585(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130585."""
    data_raw = 0
    # source_number | Offset: 0, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'source_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 0
    # status | Offset: 8, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_BLUETOOTH_SOURCE_STATUS(field.value)
    data_raw |= (field_value & 0xF) << 8
    # forget_device | Offset: 12, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'forget_device')
    if field is None:
        raise Exception("Cant encode this message, missing 'Forget device'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 12
    # discovering | Offset: 14, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'discovering')
    if field is None:
        raise Exception("Cant encode this message, missing 'Discovering'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 14
    # bluetooth_address | Offset: 16, Length: 48, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'bluetooth_address')
    if field is None:
        raise Exception("Cant encode this message, missing 'Bluetooth address'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFF) << 16
    return data_raw


def is_fast_pgn_130586() -> bool:
    """Return True if PGN 130586 is a fast PGN."""
    return True
def decode_pgn_130586(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130586."""
    nmea2000Message = NMEA2000Message(130586, 'zoneConfiguration', 'Zone Configuration')
    running_bit_offset = 0
    # 1:zone_id | Offset: 0, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    zone_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    zone_id = master_dict['ENTERTAINMENT_ZONE'].get(zone_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('zone_id', 'Zone ID', None, None, zone_id, zone_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 2:volume_limit | Offset: 8, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 8
    volume_limit = volume_limit_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('volume_limit', 'Volume limit', None, '%', volume_limit, volume_limit_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 3:fade | Offset: 16, Length: 8, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    fade = fade_raw = decode_number(_data_raw_, running_bit_offset, 8, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('fade', 'Fade', None, '%', fade, fade_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 4:balance | Offset: 24, Length: 8, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    balance = balance_raw = decode_number(_data_raw_, running_bit_offset, 8, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('balance', 'Balance', None, '%', balance, balance_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:sub_volume | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    sub_volume = sub_volume_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sub_volume', 'Sub volume', None, '%', sub_volume, sub_volume_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:eq___treble | Offset: 40, Length: 8, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    eq___treble = eq___treble_raw = decode_number(_data_raw_, running_bit_offset, 8, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('eq___treble', 'EQ - Treble', None, '%', eq___treble, eq___treble_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:eq___mid_range | Offset: 48, Length: 8, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    eq___mid_range = eq___mid_range_raw = decode_number(_data_raw_, running_bit_offset, 8, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('eq___mid_range', 'EQ - Mid range', None, '%', eq___mid_range, eq___mid_range_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:eq___bass | Offset: 56, Length: 8, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    eq___bass = eq___bass_raw = decode_number(_data_raw_, running_bit_offset, 8, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('eq___bass', 'EQ - Bass', None, '%', eq___bass, eq___bass_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:preset_type | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    preset_type_raw = decode_int(_data_raw_, running_bit_offset, 8)
    preset_type = master_dict['ENTERTAINMENT_EQ'].get(preset_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('preset_type', 'Preset type', None, None, preset_type, preset_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 10:audio_filter | Offset: 72, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    audio_filter_raw = decode_int(_data_raw_, running_bit_offset, 8)
    audio_filter = master_dict['ENTERTAINMENT_FILTER'].get(audio_filter_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('audio_filter', 'Audio filter', None, None, audio_filter, audio_filter_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 11:high_pass_filter_frequency | Offset: 80, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    high_pass_filter_frequency = high_pass_filter_frequency_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('high_pass_filter_frequency', 'High pass filter frequency', None, 'Hz', high_pass_filter_frequency, high_pass_filter_frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 12:low_pass_filter_frequency | Offset: 96, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 96
    low_pass_filter_frequency = low_pass_filter_frequency_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('low_pass_filter_frequency', 'Low pass filter frequency', None, 'Hz', low_pass_filter_frequency, low_pass_filter_frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 13:channel | Offset: 112, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    channel_raw = decode_int(_data_raw_, running_bit_offset, 8)
    channel = master_dict['ENTERTAINMENT_CHANNEL'].get(channel_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('channel', 'Channel', None, None, channel, channel_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130586(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130586."""
    data_raw = 0
    # zone_id | Offset: 0, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'zone_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_ZONE(field.value)
    data_raw |= (field_value & 0xFF) << 0
    # volume_limit | Offset: 8, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'volume_limit')
    if field is None:
        raise Exception("Cant encode this message, missing 'Volume limit'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 8
    # fade | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'fade')
    if field is None:
        raise Exception("Cant encode this message, missing 'Fade'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # balance | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'balance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Balance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # sub_volume | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sub_volume')
    if field is None:
        raise Exception("Cant encode this message, missing 'Sub volume'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # eq___treble | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'eq___treble')
    if field is None:
        raise Exception("Cant encode this message, missing 'EQ - Treble'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # eq___mid_range | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'eq___mid_range')
    if field is None:
        raise Exception("Cant encode this message, missing 'EQ - Mid range'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # eq___bass | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'eq___bass')
    if field is None:
        raise Exception("Cant encode this message, missing 'EQ - Bass'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    # preset_type | Offset: 64, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'preset_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Preset type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_EQ(field.value)
    data_raw |= (field_value & 0xFF) << 64
    # audio_filter | Offset: 72, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'audio_filter')
    if field is None:
        raise Exception("Cant encode this message, missing 'Audio filter'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_FILTER(field.value)
    data_raw |= (field_value & 0xFF) << 72
    # high_pass_filter_frequency | Offset: 80, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'high_pass_filter_frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'High pass filter frequency'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 80
    # low_pass_filter_frequency | Offset: 96, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'low_pass_filter_frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'Low pass filter frequency'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 96
    # channel | Offset: 112, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'channel')
    if field is None:
        raise Exception("Cant encode this message, missing 'Channel'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_CHANNEL(field.value)
    data_raw |= (field_value & 0xFF) << 112
    return data_raw


def is_fast_pgn_130816() -> bool:
    """Return True if PGN 130816 is a fast PGN."""
    return True
# Complex PGN. number of matches: 20
def decode_pgn_130816(data_raw: int) -> NMEA2000Message:
    # sonichubInit2 | Description: SonicHub: Init #2
    if (
        (((data_raw >> 0) & 0x7FF) == 275) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 1)
        ):
        return decode_pgn_130816_sonichubInit2(data_raw)
    
    # sonichubAmRadio | Description: SonicHub: AM Radio
    if (
        (((data_raw >> 0) & 0x7FF) == 275) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 4)
        ):
        return decode_pgn_130816_sonichubAmRadio(data_raw)
    
    # sonichubZoneInfo | Description: SonicHub: Zone info
    if (
        (((data_raw >> 0) & 0x7FF) == 275) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 5)
        ):
        return decode_pgn_130816_sonichubZoneInfo(data_raw)
    
    # sonichubSource | Description: SonicHub: Source
    if (
        (((data_raw >> 0) & 0x7FF) == 275) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 6)
        ):
        return decode_pgn_130816_sonichubSource(data_raw)
    
    # sonichubSourceList | Description: SonicHub: Source List
    if (
        (((data_raw >> 0) & 0x7FF) == 275) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 8)
        ):
        return decode_pgn_130816_sonichubSourceList(data_raw)
    
    # sonichubControl | Description: SonicHub: Control
    if (
        (((data_raw >> 0) & 0x7FF) == 275) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 9)
        ):
        return decode_pgn_130816_sonichubControl(data_raw)
    
    # sonichubFmRadio | Description: SonicHub: FM Radio
    if (
        (((data_raw >> 0) & 0x7FF) == 275) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 12)
        ):
        return decode_pgn_130816_sonichubFmRadio(data_raw)
    
    # sonichubPlaylist | Description: SonicHub: Playlist
    if (
        (((data_raw >> 0) & 0x7FF) == 275) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 13)
        ):
        return decode_pgn_130816_sonichubPlaylist(data_raw)
    
    # sonichubTrack | Description: SonicHub: Track
    if (
        (((data_raw >> 0) & 0x7FF) == 275) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 14)
        ):
        return decode_pgn_130816_sonichubTrack(data_raw)
    
    # sonichubArtist | Description: SonicHub: Artist
    if (
        (((data_raw >> 0) & 0x7FF) == 275) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 15)
        ):
        return decode_pgn_130816_sonichubArtist(data_raw)
    
    # sonichubAlbum | Description: SonicHub: Album
    if (
        (((data_raw >> 0) & 0x7FF) == 275) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 16)
        ):
        return decode_pgn_130816_sonichubAlbum(data_raw)
    
    # sonichubMenuItem | Description: SonicHub: Menu Item
    if (
        (((data_raw >> 0) & 0x7FF) == 275) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 19)
        ):
        return decode_pgn_130816_sonichubMenuItem(data_raw)
    
    # sonichubZones | Description: SonicHub: Zones
    if (
        (((data_raw >> 0) & 0x7FF) == 275) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 20)
        ):
        return decode_pgn_130816_sonichubZones(data_raw)
    
    # sonichubMaxVolume | Description: SonicHub: Max Volume
    if (
        (((data_raw >> 0) & 0x7FF) == 275) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 23)
        ):
        return decode_pgn_130816_sonichubMaxVolume(data_raw)
    
    # sonichubVolume | Description: SonicHub: Volume
    if (
        (((data_raw >> 0) & 0x7FF) == 275) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 24)
        ):
        return decode_pgn_130816_sonichubVolume(data_raw)
    
    # sonichubInit1 | Description: SonicHub: Init #1
    if (
        (((data_raw >> 0) & 0x7FF) == 275) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 25)
        ):
        return decode_pgn_130816_sonichubInit1(data_raw)
    
    # sonichubPosition | Description: SonicHub: Position
    if (
        (((data_raw >> 0) & 0x7FF) == 275) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 48)
        ):
        return decode_pgn_130816_sonichubPosition(data_raw)
    
    # sonichubInit3 | Description: SonicHub: Init #3
    if (
        (((data_raw >> 0) & 0x7FF) == 275) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 50)
        ):
        return decode_pgn_130816_sonichubInit3(data_raw)
    
    # simradTextMessage | Description: Simrad: Text Message
    if (
        (((data_raw >> 0) & 0x7FF) == 1857) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 24) & 0xFF) == 50)
        ):
        return decode_pgn_130816_simradTextMessage(data_raw)
    
    return decode_pgn_130816_0x1ff000x1ffffManufacturerSpecificFastPacketNonAddressed(data_raw)
    
def decode_pgn_130816_0x1ff000x1ffffManufacturerSpecificFastPacketNonAddressed(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130816."""
    nmea2000Message = NMEA2000Message(130816, '0x1ff000x1ffffManufacturerSpecificFastPacketNonAddressed', '0x1FF00-0x1FFFF: Manufacturer Specific fast-packet non-addressed')
    running_bit_offset = 0
    # 1:data | Offset: 0, Length: 1784, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 0
    data = data_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 1784))
    nmea2000Message.fields.append(NMEA2000Field('data', 'Data', None, None, data, data_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 1784

    return nmea2000Message

def encode_pgn_130816_0x1ff000x1ffffManufacturerSpecificFastPacketNonAddressed(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130816."""
    data_raw = 0
    # data | Offset: 0, Length: 1784, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'data')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data'")
    # Skipping fields longer than 256
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 0
    return data_raw

def decode_pgn_130816_sonichubInit2(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130816."""
    nmea2000Message = NMEA2000Message(130816, 'sonichubInit2', 'SonicHub: Init #2')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:proprietary_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1, PartOfPrimaryKey: True,
    running_bit_offset = 24
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SONICHUB_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Init #2", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 6:control | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    control_raw = decode_int(_data_raw_, running_bit_offset, 8)
    control = master_dict['SONICHUB_CONTROL'].get(control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:a | Offset: 40, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:b | Offset: 56, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_130816_sonichubInit2(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130816."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # proprietary_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # control | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_CONTROL(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # a | Offset: 40, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 40
    # b | Offset: 56, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 56
    return data_raw

def decode_pgn_130816_sonichubAmRadio(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130816."""
    nmea2000Message = NMEA2000Message(130816, 'sonichubAmRadio', 'SonicHub: AM Radio')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:proprietary_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 24
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SONICHUB_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "AM Radio", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 6:control | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    control_raw = decode_int(_data_raw_, running_bit_offset, 8)
    control = master_dict['SONICHUB_CONTROL'].get(control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:item | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    item_raw = decode_int(_data_raw_, running_bit_offset, 8)
    item = master_dict['SONICHUB_TUNING'].get(item_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('item', 'Item', None, None, item, item_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 8:frequency | Offset: 48, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    frequency = frequency_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('frequency', 'Frequency', None, 'Hz', frequency, frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 9:noise_level | Offset: 80, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    noise_level = noise_level_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('noise_level', 'Noise level', None, None, noise_level, noise_level_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 10:signal_level | Offset: 82, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 82
    signal_level = signal_level_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('signal_level', 'Signal level', None, None, signal_level, signal_level_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 11:reserved_86 | Offset: 86, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 86
    reserved_86 = reserved_86_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_86', 'Reserved', None, None, reserved_86, reserved_86_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 12:text | Offset: 88, Length: 256, Signed: False Resolution: , Field Type: STRING_LZ, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    text = text_raw = decode_string_lz(_data_raw_, running_bit_offset, 256)
    nmea2000Message.fields.append(NMEA2000Field('text', 'Text', None, None, text, text_raw, None, FieldTypes.STRING_LZ, False))
    running_bit_offset += 256

    return nmea2000Message

def encode_pgn_130816_sonichubAmRadio(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130816."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # proprietary_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # control | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_CONTROL(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # item | Offset: 40, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'item')
    if field is None:
        raise Exception("Cant encode this message, missing 'Item'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_TUNING(field.value)
    data_raw |= (field_value & 0xFF) << 40
    # frequency | Offset: 48, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'Frequency'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 48
    # noise_level | Offset: 80, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'noise_level')
    if field is None:
        raise Exception("Cant encode this message, missing 'Noise level'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 80
    # signal_level | Offset: 82, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'signal_level')
    if field is None:
        raise Exception("Cant encode this message, missing 'Signal level'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 82
    # reserved_86 | Offset: 86, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_86')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 86
    # text | Offset: 88, Length: 256, Resolution: , Field Type: STRING_LZ
    field = next(f for f in nmea2000Message.fields if f.id == 'text')
    if field is None:
        raise Exception("Cant encode this message, missing 'Text'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 88
    return data_raw

def decode_pgn_130816_sonichubZoneInfo(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130816."""
    nmea2000Message = NMEA2000Message(130816, 'sonichubZoneInfo', 'SonicHub: Zone info')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:proprietary_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 5, PartOfPrimaryKey: True,
    running_bit_offset = 24
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SONICHUB_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Zone Info", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 6:control | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    control_raw = decode_int(_data_raw_, running_bit_offset, 8)
    control = master_dict['SONICHUB_CONTROL'].get(control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:zone | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    zone = zone_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone', 'Zone', None, None, zone, zone_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130816_sonichubZoneInfo(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130816."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # proprietary_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # control | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_CONTROL(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # zone | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zone')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    return data_raw

def decode_pgn_130816_sonichubSource(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130816."""
    nmea2000Message = NMEA2000Message(130816, 'sonichubSource', 'SonicHub: Source')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:proprietary_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 6, PartOfPrimaryKey: True,
    running_bit_offset = 24
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SONICHUB_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Source", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 6:control | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    control_raw = decode_int(_data_raw_, running_bit_offset, 8)
    control = master_dict['SONICHUB_CONTROL'].get(control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:source | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    source_raw = decode_int(_data_raw_, running_bit_offset, 8)
    source = master_dict['SONICHUB_SOURCE'].get(source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('source', 'Source', None, None, source, source_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130816_sonichubSource(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130816."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # proprietary_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # control | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_CONTROL(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # source | Offset: 40, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_SOURCE(field.value)
    data_raw |= (field_value & 0xFF) << 40
    return data_raw

def decode_pgn_130816_sonichubSourceList(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130816."""
    nmea2000Message = NMEA2000Message(130816, 'sonichubSourceList', 'SonicHub: Source List')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:proprietary_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 8, PartOfPrimaryKey: True,
    running_bit_offset = 24
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SONICHUB_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Source List", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 6:control | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    control_raw = decode_int(_data_raw_, running_bit_offset, 8)
    control = master_dict['SONICHUB_CONTROL'].get(control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:source_id | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    source_id = source_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('source_id', 'Source ID', None, None, source_id, source_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:a | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:text | Offset: 56, Length: 256, Signed: False Resolution: , Field Type: STRING_LZ, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    text = text_raw = decode_string_lz(_data_raw_, running_bit_offset, 256)
    nmea2000Message.fields.append(NMEA2000Field('text', 'Text', None, None, text, text_raw, None, FieldTypes.STRING_LZ, False))
    running_bit_offset += 256

    return nmea2000Message

def encode_pgn_130816_sonichubSourceList(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130816."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # proprietary_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # control | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_CONTROL(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # source_id | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'source_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # a | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # text | Offset: 56, Length: 256, Resolution: , Field Type: STRING_LZ
    field = next(f for f in nmea2000Message.fields if f.id == 'text')
    if field is None:
        raise Exception("Cant encode this message, missing 'Text'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 56
    return data_raw

def decode_pgn_130816_sonichubControl(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130816."""
    nmea2000Message = NMEA2000Message(130816, 'sonichubControl', 'SonicHub: Control')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:proprietary_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 9, PartOfPrimaryKey: True,
    running_bit_offset = 24
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SONICHUB_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Control", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 6:control | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    control_raw = decode_int(_data_raw_, running_bit_offset, 8)
    control = master_dict['SONICHUB_CONTROL'].get(control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:item | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    item_raw = decode_int(_data_raw_, running_bit_offset, 8)
    item = master_dict['FUSION_MUTE_COMMAND'].get(item_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('item', 'Item', None, None, item, item_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130816_sonichubControl(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130816."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # proprietary_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # control | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_CONTROL(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # item | Offset: 40, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'item')
    if field is None:
        raise Exception("Cant encode this message, missing 'Item'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MUTE_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 40
    return data_raw

def decode_pgn_130816_sonichubFmRadio(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130816."""
    nmea2000Message = NMEA2000Message(130816, 'sonichubFmRadio', 'SonicHub: FM Radio')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:proprietary_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 12, PartOfPrimaryKey: True,
    running_bit_offset = 24
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SONICHUB_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "FM Radio", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 6:control | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    control_raw = decode_int(_data_raw_, running_bit_offset, 8)
    control = master_dict['SONICHUB_CONTROL'].get(control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:item | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    item_raw = decode_int(_data_raw_, running_bit_offset, 8)
    item = master_dict['SONICHUB_TUNING'].get(item_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('item', 'Item', None, None, item, item_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 8:frequency | Offset: 48, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    frequency = frequency_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('frequency', 'Frequency', None, 'Hz', frequency, frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 9:noise_level | Offset: 80, Length: 2, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    noise_level = noise_level_raw = decode_number(_data_raw_, running_bit_offset, 2, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('noise_level', 'Noise level', None, None, noise_level, noise_level_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 2

    # 10:signal_level | Offset: 82, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 82
    signal_level = signal_level_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('signal_level', 'Signal level', None, None, signal_level, signal_level_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 11:reserved_86 | Offset: 86, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 86
    reserved_86 = reserved_86_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_86', 'Reserved', None, None, reserved_86, reserved_86_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 12:text | Offset: 88, Length: 256, Signed: False Resolution: , Field Type: STRING_LZ, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    text = text_raw = decode_string_lz(_data_raw_, running_bit_offset, 256)
    nmea2000Message.fields.append(NMEA2000Field('text', 'Text', None, None, text, text_raw, None, FieldTypes.STRING_LZ, False))
    running_bit_offset += 256

    return nmea2000Message

def encode_pgn_130816_sonichubFmRadio(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130816."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # proprietary_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # control | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_CONTROL(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # item | Offset: 40, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'item')
    if field is None:
        raise Exception("Cant encode this message, missing 'Item'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_TUNING(field.value)
    data_raw |= (field_value & 0xFF) << 40
    # frequency | Offset: 48, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'Frequency'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 48
    # noise_level | Offset: 80, Length: 2, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'noise_level')
    if field is None:
        raise Exception("Cant encode this message, missing 'Noise level'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 80
    # signal_level | Offset: 82, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'signal_level')
    if field is None:
        raise Exception("Cant encode this message, missing 'Signal level'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 82
    # reserved_86 | Offset: 86, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_86')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 86
    # text | Offset: 88, Length: 256, Resolution: , Field Type: STRING_LZ
    field = next(f for f in nmea2000Message.fields if f.id == 'text')
    if field is None:
        raise Exception("Cant encode this message, missing 'Text'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 88
    return data_raw

def decode_pgn_130816_sonichubPlaylist(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130816."""
    nmea2000Message = NMEA2000Message(130816, 'sonichubPlaylist', 'SonicHub: Playlist')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:proprietary_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 13, PartOfPrimaryKey: True,
    running_bit_offset = 24
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SONICHUB_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Playlist", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 6:control | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    control_raw = decode_int(_data_raw_, running_bit_offset, 8)
    control = master_dict['SONICHUB_CONTROL'].get(control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:item | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    item_raw = decode_int(_data_raw_, running_bit_offset, 8)
    item = master_dict['SONICHUB_PLAYLIST'].get(item_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('item', 'Item', None, None, item, item_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 8:a | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:current_track | Offset: 56, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    current_track = current_track_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('current_track', 'Current Track', None, None, current_track, current_track_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 10:tracks | Offset: 88, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    tracks = tracks_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('tracks', 'Tracks', None, None, tracks, tracks_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 11:length | Offset: 120, Length: 32, Signed: False Resolution: 0.001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    length_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.001)
    length = decode_time(length_raw)
    nmea2000Message.fields.append(NMEA2000Field('length', 'Length', None, 's', length, length_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 12:position_in_track | Offset: 152, Length: 32, Signed: False Resolution: 0.001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 152
    position_in_track_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.001)
    position_in_track = decode_time(position_in_track_raw)
    nmea2000Message.fields.append(NMEA2000Field('position_in_track', 'Position in track', None, 's', position_in_track, position_in_track_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_130816_sonichubPlaylist(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130816."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # proprietary_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # control | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_CONTROL(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # item | Offset: 40, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'item')
    if field is None:
        raise Exception("Cant encode this message, missing 'Item'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_PLAYLIST(field.value)
    data_raw |= (field_value & 0xFF) << 40
    # a | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # current_track | Offset: 56, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'current_track')
    if field is None:
        raise Exception("Cant encode this message, missing 'Current Track'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 56
    # tracks | Offset: 88, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'tracks')
    if field is None:
        raise Exception("Cant encode this message, missing 'Tracks'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 88
    # length | Offset: 120, Length: 32, Resolution: 0.001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'length')
    if field is None:
        raise Exception("Cant encode this message, missing 'Length'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFFFFFF) << 120
    
    # position_in_track | Offset: 152, Length: 32, Resolution: 0.001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'position_in_track')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position in track'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFFFFFF) << 152
    
    return data_raw

def decode_pgn_130816_sonichubTrack(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130816."""
    nmea2000Message = NMEA2000Message(130816, 'sonichubTrack', 'SonicHub: Track')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:proprietary_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 14, PartOfPrimaryKey: True,
    running_bit_offset = 24
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SONICHUB_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Track", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 6:control | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    control_raw = decode_int(_data_raw_, running_bit_offset, 8)
    control = master_dict['SONICHUB_CONTROL'].get(control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:item | Offset: 40, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    item = item_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('item', 'Item', None, None, item, item_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 8:text | Offset: 72, Length: 256, Signed: False Resolution: , Field Type: STRING_LZ, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    text = text_raw = decode_string_lz(_data_raw_, running_bit_offset, 256)
    nmea2000Message.fields.append(NMEA2000Field('text', 'Text', None, None, text, text_raw, None, FieldTypes.STRING_LZ, False))
    running_bit_offset += 256

    return nmea2000Message

def encode_pgn_130816_sonichubTrack(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130816."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # proprietary_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # control | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_CONTROL(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # item | Offset: 40, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'item')
    if field is None:
        raise Exception("Cant encode this message, missing 'Item'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 40
    # text | Offset: 72, Length: 256, Resolution: , Field Type: STRING_LZ
    field = next(f for f in nmea2000Message.fields if f.id == 'text')
    if field is None:
        raise Exception("Cant encode this message, missing 'Text'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 72
    return data_raw

def decode_pgn_130816_sonichubArtist(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130816."""
    nmea2000Message = NMEA2000Message(130816, 'sonichubArtist', 'SonicHub: Artist')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:proprietary_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 15, PartOfPrimaryKey: True,
    running_bit_offset = 24
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SONICHUB_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Artist", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 6:control | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    control_raw = decode_int(_data_raw_, running_bit_offset, 8)
    control = master_dict['SONICHUB_CONTROL'].get(control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:item | Offset: 40, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    item = item_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('item', 'Item', None, None, item, item_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 8:text | Offset: 72, Length: 256, Signed: False Resolution: , Field Type: STRING_LZ, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    text = text_raw = decode_string_lz(_data_raw_, running_bit_offset, 256)
    nmea2000Message.fields.append(NMEA2000Field('text', 'Text', None, None, text, text_raw, None, FieldTypes.STRING_LZ, False))
    running_bit_offset += 256

    return nmea2000Message

def encode_pgn_130816_sonichubArtist(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130816."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # proprietary_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # control | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_CONTROL(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # item | Offset: 40, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'item')
    if field is None:
        raise Exception("Cant encode this message, missing 'Item'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 40
    # text | Offset: 72, Length: 256, Resolution: , Field Type: STRING_LZ
    field = next(f for f in nmea2000Message.fields if f.id == 'text')
    if field is None:
        raise Exception("Cant encode this message, missing 'Text'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 72
    return data_raw

def decode_pgn_130816_sonichubAlbum(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130816."""
    nmea2000Message = NMEA2000Message(130816, 'sonichubAlbum', 'SonicHub: Album')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:proprietary_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 16, PartOfPrimaryKey: True,
    running_bit_offset = 24
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SONICHUB_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Album", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 6:control | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    control_raw = decode_int(_data_raw_, running_bit_offset, 8)
    control = master_dict['SONICHUB_CONTROL'].get(control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:item | Offset: 40, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    item = item_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('item', 'Item', None, None, item, item_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 8:text | Offset: 72, Length: 256, Signed: False Resolution: , Field Type: STRING_LZ, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    text = text_raw = decode_string_lz(_data_raw_, running_bit_offset, 256)
    nmea2000Message.fields.append(NMEA2000Field('text', 'Text', None, None, text, text_raw, None, FieldTypes.STRING_LZ, False))
    running_bit_offset += 256

    return nmea2000Message

def encode_pgn_130816_sonichubAlbum(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130816."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # proprietary_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # control | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_CONTROL(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # item | Offset: 40, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'item')
    if field is None:
        raise Exception("Cant encode this message, missing 'Item'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 40
    # text | Offset: 72, Length: 256, Resolution: , Field Type: STRING_LZ
    field = next(f for f in nmea2000Message.fields if f.id == 'text')
    if field is None:
        raise Exception("Cant encode this message, missing 'Text'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 72
    return data_raw

def decode_pgn_130816_sonichubMenuItem(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130816."""
    nmea2000Message = NMEA2000Message(130816, 'sonichubMenuItem', 'SonicHub: Menu Item')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:proprietary_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 19, PartOfPrimaryKey: True,
    running_bit_offset = 24
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SONICHUB_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Menu Item", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 6:control | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    control_raw = decode_int(_data_raw_, running_bit_offset, 8)
    control = master_dict['SONICHUB_CONTROL'].get(control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:item | Offset: 40, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    item = item_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('item', 'Item', None, None, item, item_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 8:c | Offset: 72, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:d | Offset: 80, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    d = d_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('d', 'D', None, None, d, d_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:e | Offset: 88, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    e = e_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('e', 'E', None, None, e, e_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 11:text | Offset: 96, Length: 256, Signed: False Resolution: , Field Type: STRING_LZ, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 96
    text = text_raw = decode_string_lz(_data_raw_, running_bit_offset, 256)
    nmea2000Message.fields.append(NMEA2000Field('text', 'Text', None, None, text, text_raw, None, FieldTypes.STRING_LZ, False))
    running_bit_offset += 256

    return nmea2000Message

def encode_pgn_130816_sonichubMenuItem(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130816."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # proprietary_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # control | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_CONTROL(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # item | Offset: 40, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'item')
    if field is None:
        raise Exception("Cant encode this message, missing 'Item'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 40
    # c | Offset: 72, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 72
    # d | Offset: 80, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'd')
    if field is None:
        raise Exception("Cant encode this message, missing 'D'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 80
    # e | Offset: 88, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'e')
    if field is None:
        raise Exception("Cant encode this message, missing 'E'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 88
    # text | Offset: 96, Length: 256, Resolution: , Field Type: STRING_LZ
    field = next(f for f in nmea2000Message.fields if f.id == 'text')
    if field is None:
        raise Exception("Cant encode this message, missing 'Text'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 96
    return data_raw

def decode_pgn_130816_sonichubZones(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130816."""
    nmea2000Message = NMEA2000Message(130816, 'sonichubZones', 'SonicHub: Zones')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:proprietary_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 20, PartOfPrimaryKey: True,
    running_bit_offset = 24
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SONICHUB_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Zones", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 6:control | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    control_raw = decode_int(_data_raw_, running_bit_offset, 8)
    control = master_dict['SONICHUB_CONTROL'].get(control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:zones | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    zones = zones_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zones', 'Zones', None, None, zones, zones_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130816_sonichubZones(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130816."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # proprietary_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # control | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_CONTROL(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # zones | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zones')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zones'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    return data_raw

def decode_pgn_130816_sonichubMaxVolume(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130816."""
    nmea2000Message = NMEA2000Message(130816, 'sonichubMaxVolume', 'SonicHub: Max Volume')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:proprietary_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 23, PartOfPrimaryKey: True,
    running_bit_offset = 24
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SONICHUB_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Max Volume", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 6:control | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    control_raw = decode_int(_data_raw_, running_bit_offset, 8)
    control = master_dict['SONICHUB_CONTROL'].get(control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:zone | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    zone = zone_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone', 'Zone', None, None, zone, zone_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:level | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    level = level_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('level', 'Level', None, None, level, level_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130816_sonichubMaxVolume(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130816."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # proprietary_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # control | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_CONTROL(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # zone | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zone')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # level | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'level')
    if field is None:
        raise Exception("Cant encode this message, missing 'Level'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    return data_raw

def decode_pgn_130816_sonichubVolume(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130816."""
    nmea2000Message = NMEA2000Message(130816, 'sonichubVolume', 'SonicHub: Volume')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:proprietary_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 24, PartOfPrimaryKey: True,
    running_bit_offset = 24
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SONICHUB_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Volume", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 6:control | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    control_raw = decode_int(_data_raw_, running_bit_offset, 8)
    control = master_dict['SONICHUB_CONTROL'].get(control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:zone | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    zone = zone_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone', 'Zone', None, None, zone, zone_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:level | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    level = level_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('level', 'Level', None, None, level, level_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130816_sonichubVolume(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130816."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # proprietary_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # control | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_CONTROL(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # zone | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zone')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # level | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'level')
    if field is None:
        raise Exception("Cant encode this message, missing 'Level'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    return data_raw

def decode_pgn_130816_sonichubInit1(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130816."""
    nmea2000Message = NMEA2000Message(130816, 'sonichubInit1', 'SonicHub: Init #1')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:proprietary_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 25, PartOfPrimaryKey: True,
    running_bit_offset = 24
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SONICHUB_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Init #1", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 6:control | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    control_raw = decode_int(_data_raw_, running_bit_offset, 8)
    control = master_dict['SONICHUB_CONTROL'].get(control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130816_sonichubInit1(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130816."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # proprietary_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # control | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_CONTROL(field.value)
    data_raw |= (field_value & 0xFF) << 32
    return data_raw

def decode_pgn_130816_sonichubPosition(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130816."""
    nmea2000Message = NMEA2000Message(130816, 'sonichubPosition', 'SonicHub: Position')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:proprietary_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 48, PartOfPrimaryKey: True,
    running_bit_offset = 24
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SONICHUB_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Position", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 6:control | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    control_raw = decode_int(_data_raw_, running_bit_offset, 8)
    control = master_dict['SONICHUB_CONTROL'].get(control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:position | Offset: 40, Length: 32, Signed: False Resolution: 0.001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    position_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.001)
    position = decode_time(position_raw)
    nmea2000Message.fields.append(NMEA2000Field('position', 'Position', None, 's', position, position_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_130816_sonichubPosition(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130816."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # proprietary_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # control | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_CONTROL(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # position | Offset: 40, Length: 32, Resolution: 0.001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'position')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFFFFFF) << 40
    
    return data_raw

def decode_pgn_130816_sonichubInit3(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130816."""
    nmea2000Message = NMEA2000Message(130816, 'sonichubInit3', 'SonicHub: Init #3')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:proprietary_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 50, PartOfPrimaryKey: True,
    running_bit_offset = 24
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SONICHUB_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Init #3", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 6:control | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    control_raw = decode_int(_data_raw_, running_bit_offset, 8)
    control = master_dict['SONICHUB_CONTROL'].get(control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:a | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:b | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130816_sonichubInit3(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130816."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # proprietary_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # control | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SONICHUB_CONTROL(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # a | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # b | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    return data_raw

def decode_pgn_130816_simradTextMessage(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130816."""
    nmea2000Message = NMEA2000Message(130816, 'simradTextMessage', 'Simrad: Text Message')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:proprietary_id | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 50, PartOfPrimaryKey: True,
    running_bit_offset = 24
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SIMNET_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Text", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 8

    # 6:a | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:b | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:c | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:sid | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:prio | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    prio = prio_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('prio', 'Prio', None, None, prio, prio_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 11:text | Offset: 72, Length: 256, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    text = text_raw = decode_string_fix(_data_raw_, running_bit_offset, 256)
    nmea2000Message.fields.append(NMEA2000Field('text', 'Text', None, None, text, text_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 256

    return nmea2000Message

def encode_pgn_130816_simradTextMessage(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130816."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # proprietary_id | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # a | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # b | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # c | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # sid | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    # prio | Offset: 64, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'prio')
    if field is None:
        raise Exception("Cant encode this message, missing 'Prio'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 64
    # text | Offset: 72, Length: 256, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'text')
    if field is None:
        raise Exception("Cant encode this message, missing 'Text'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 72
    return data_raw


def is_fast_pgn_130817() -> bool:
    """Return True if PGN 130817 is a fast PGN."""
    return True
# Complex PGN. number of matches: 2
def decode_pgn_130817(data_raw: int) -> NMEA2000Message:
    # navicoProductInformation | Description: Navico: Product Information
    if (
        (((data_raw >> 0) & 0x7FF) == 275) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_130817_navicoProductInformation(data_raw)
    
    # lowranceProductInformation | Description: Lowrance: Product Information
    if (
        (((data_raw >> 0) & 0x7FF) == 140) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_130817_lowranceProductInformation(data_raw)
    
    
    raise Exception("No matching sub-PGN found")
    
def decode_pgn_130817_navicoProductInformation(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130817."""
    nmea2000Message = NMEA2000Message(130817, 'navicoProductInformation', 'Navico: Product Information')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:product_code | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 16
    product_code = product_code_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('product_code', 'Product Code', None, None, product_code, product_code_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 16

    # 5:model | Offset: 32, Length: 256, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    model = model_raw = decode_string_fix(_data_raw_, running_bit_offset, 256)
    nmea2000Message.fields.append(NMEA2000Field('model', 'Model', None, None, model, model_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 256

    # 6:a | Offset: 288, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 288
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:b | Offset: 296, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 296
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:c | Offset: 304, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 304
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:firmware_version | Offset: 312, Length: 80, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 312
    firmware_version = firmware_version_raw = decode_string_fix(_data_raw_, running_bit_offset, 80)
    nmea2000Message.fields.append(NMEA2000Field('firmware_version', 'Firmware version', None, None, firmware_version, firmware_version_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 80

    # 10:firmware_date | Offset: 392, Length: 256, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 392
    firmware_date = firmware_date_raw = decode_string_fix(_data_raw_, running_bit_offset, 256)
    nmea2000Message.fields.append(NMEA2000Field('firmware_date', 'Firmware date', None, None, firmware_date, firmware_date_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 256

    # 11:firmware_time | Offset: 648, Length: 256, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 648
    firmware_time = firmware_time_raw = decode_string_fix(_data_raw_, running_bit_offset, 256)
    nmea2000Message.fields.append(NMEA2000Field('firmware_time', 'Firmware time', None, None, firmware_time, firmware_time_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 256

    return nmea2000Message

def encode_pgn_130817_navicoProductInformation(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130817."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # product_code | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'product_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Product Code'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # model | Offset: 32, Length: 256, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'model')
    if field is None:
        raise Exception("Cant encode this message, missing 'Model'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 32
    # a | Offset: 288, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 288
    # b | Offset: 296, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 296
    # c | Offset: 304, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 304
    # firmware_version | Offset: 312, Length: 80, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'firmware_version')
    if field is None:
        raise Exception("Cant encode this message, missing 'Firmware version'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFF) << 312
    # firmware_date | Offset: 392, Length: 256, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'firmware_date')
    if field is None:
        raise Exception("Cant encode this message, missing 'Firmware date'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 392
    # firmware_time | Offset: 648, Length: 256, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'firmware_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Firmware time'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 648
    return data_raw

def decode_pgn_130817_lowranceProductInformation(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130817."""
    nmea2000Message = NMEA2000Message(130817, 'lowranceProductInformation', 'Lowrance: Product Information')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 140, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Lowrance", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:product_code | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 16
    product_code = product_code_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('product_code', 'Product Code', None, None, product_code, product_code_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 16

    # 5:model | Offset: 32, Length: 256, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    model = model_raw = decode_string_fix(_data_raw_, running_bit_offset, 256)
    nmea2000Message.fields.append(NMEA2000Field('model', 'Model', None, None, model, model_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 256

    # 6:a | Offset: 288, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 288
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:b | Offset: 296, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 296
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:c | Offset: 304, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 304
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:firmware_version | Offset: 312, Length: 80, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 312
    firmware_version = firmware_version_raw = decode_string_fix(_data_raw_, running_bit_offset, 80)
    nmea2000Message.fields.append(NMEA2000Field('firmware_version', 'Firmware version', None, None, firmware_version, firmware_version_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 80

    # 10:firmware_date | Offset: 392, Length: 256, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 392
    firmware_date = firmware_date_raw = decode_string_fix(_data_raw_, running_bit_offset, 256)
    nmea2000Message.fields.append(NMEA2000Field('firmware_date', 'Firmware date', None, None, firmware_date, firmware_date_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 256

    # 11:firmware_time | Offset: 648, Length: 256, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 648
    firmware_time = firmware_time_raw = decode_string_fix(_data_raw_, running_bit_offset, 256)
    nmea2000Message.fields.append(NMEA2000Field('firmware_time', 'Firmware time', None, None, firmware_time, firmware_time_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 256

    return nmea2000Message

def encode_pgn_130817_lowranceProductInformation(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130817."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # product_code | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'product_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Product Code'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # model | Offset: 32, Length: 256, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'model')
    if field is None:
        raise Exception("Cant encode this message, missing 'Model'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 32
    # a | Offset: 288, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 288
    # b | Offset: 296, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 296
    # c | Offset: 304, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 304
    # firmware_version | Offset: 312, Length: 80, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'firmware_version')
    if field is None:
        raise Exception("Cant encode this message, missing 'Firmware version'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFF) << 312
    # firmware_date | Offset: 392, Length: 256, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'firmware_date')
    if field is None:
        raise Exception("Cant encode this message, missing 'Firmware date'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 392
    # firmware_time | Offset: 648, Length: 256, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'firmware_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Firmware time'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 648
    return data_raw


def is_fast_pgn_130818() -> bool:
    """Return True if PGN 130818 is a fast PGN."""
    return True
def decode_pgn_130818(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130818."""
    nmea2000Message = NMEA2000Message(130818, 'simnetReprogramData', 'Simnet: Reprogram Data')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:version | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    version = version_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('version', 'Version', None, None, version, version_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:sequence | Offset: 32, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    sequence = sequence_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sequence', 'Sequence', None, None, sequence, sequence_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:data | Offset: 48, Length: 1736, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    data = data_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 1736))
    nmea2000Message.fields.append(NMEA2000Field('data', 'Data', None, None, data, data_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 1736

    return nmea2000Message

def encode_pgn_130818(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130818."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # version | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'version')
    if field is None:
        raise Exception("Cant encode this message, missing 'Version'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # sequence | Offset: 32, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sequence')
    if field is None:
        raise Exception("Cant encode this message, missing 'Sequence'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 32
    # data | Offset: 48, Length: 1736, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'data')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data'")
    # Skipping fields longer than 256
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 48
    return data_raw


def is_fast_pgn_130819() -> bool:
    """Return True if PGN 130819 is a fast PGN."""
    return True
def decode_pgn_130819(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130819."""
    nmea2000Message = NMEA2000Message(130819, 'simnetRequestReprogram', 'Simnet: Request Reprogram')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    return nmea2000Message

def encode_pgn_130819(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130819."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    return data_raw


def is_fast_pgn_130820() -> bool:
    """Return True if PGN 130820 is a fast PGN."""
    return True
# Complex PGN. number of matches: 25
def decode_pgn_130820(data_raw: int) -> NMEA2000Message:
    # simnetReprogramStatus | Description: Simnet: Reprogram Status
    if (
        (((data_raw >> 0) & 0x7FF) == 1857) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_130820_simnetReprogramStatus(data_raw)
    
    # furunoUnknown130820 | Description: Furuno: Unknown 130820
    if (
        (((data_raw >> 0) & 0x7FF) == 1855) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_130820_furunoUnknown130820(data_raw)
    
    # fusionSourceName | Description: Fusion: Source Name
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 2)
        ):
        return decode_pgn_130820_fusionSourceName(data_raw)
    
    # fusionTrackInfo | Description: Fusion: Track Info
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 4)
        ):
        return decode_pgn_130820_fusionTrackInfo(data_raw)
    
    # fusionTrack | Description: Fusion: Track
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 5)
        ):
        return decode_pgn_130820_fusionTrack(data_raw)
    
    # fusionArtist | Description: Fusion: Artist
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 6)
        ):
        return decode_pgn_130820_fusionArtist(data_raw)
    
    # fusionAlbum | Description: Fusion: Album
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 7)
        ):
        return decode_pgn_130820_fusionAlbum(data_raw)
    
    # fusionUnitName | Description: Fusion: Unit Name
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 33)
        ):
        return decode_pgn_130820_fusionUnitName(data_raw)
    
    # fusionZoneName | Description: Fusion: Zone Name
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 45)
        ):
        return decode_pgn_130820_fusionZoneName(data_raw)
    
    # fusionPlayProgress | Description: Fusion: Play Progress
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 9)
        ):
        return decode_pgn_130820_fusionPlayProgress(data_raw)
    
    # fusionAmFmStation | Description: Fusion: AM/FM Station
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 11)
        ):
        return decode_pgn_130820_fusionAmFmStation(data_raw)
    
    # fusionVhf | Description: Fusion: VHF
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 12)
        ):
        return decode_pgn_130820_fusionVhf(data_raw)
    
    # fusionSquelch | Description: Fusion: Squelch
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 13)
        ):
        return decode_pgn_130820_fusionSquelch(data_raw)
    
    # fusionScan | Description: Fusion: Scan
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 14)
        ):
        return decode_pgn_130820_fusionScan(data_raw)
    
    # fusionMenuItem | Description: Fusion: Menu Item
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 17)
        ):
        return decode_pgn_130820_fusionMenuItem(data_raw)
    
    # fusionReplay | Description: Fusion: Replay
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 20)
        ):
        return decode_pgn_130820_fusionReplay(data_raw)
    
    # fusionMute | Description: Fusion: Mute
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 23)
        ):
        return decode_pgn_130820_fusionMute(data_raw)
    
    # fusionSubVolume | Description: Fusion: Sub Volume
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 26)
        ):
        return decode_pgn_130820_fusionSubVolume(data_raw)
    
    # fusionTone | Description: Fusion: Tone
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 27)
        ):
        return decode_pgn_130820_fusionTone(data_raw)
    
    # fusionVolume | Description: Fusion: Volume
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 29)
        ):
        return decode_pgn_130820_fusionVolume(data_raw)
    
    # fusionPowerState | Description: Fusion: Power State
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 32)
        ):
        return decode_pgn_130820_fusionPowerState(data_raw)
    
    # fusionSiriusxmChannel | Description: Fusion: SiriusXM Channel
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 36)
        ):
        return decode_pgn_130820_fusionSiriusxmChannel(data_raw)
    
    # fusionSiriusxmTitle | Description: Fusion: SiriusXM Title
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 37)
        ):
        return decode_pgn_130820_fusionSiriusxmTitle(data_raw)
    
    # fusionSiriusxmArtist | Description: Fusion: SiriusXM Artist
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 38)
        ):
        return decode_pgn_130820_fusionSiriusxmArtist(data_raw)
    
    # fusionSiriusxmGenre | Description: Fusion: SiriusXM Genre
    if (
        (((data_raw >> 0) & 0x7FF) == 419) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 40)
        ):
        return decode_pgn_130820_fusionSiriusxmGenre(data_raw)
    
    
    raise Exception("No matching sub-PGN found")
    
def decode_pgn_130820_simnetReprogramStatus(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'simnetReprogramStatus', 'Simnet: Reprogram Status')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:reserved_16 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    reserved_16 = reserved_16_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_16', 'Reserved', None, None, reserved_16, reserved_16_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 5:status | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    status = status_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('status', 'Status', None, None, status, status_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:reserved_32 | Offset: 32, Length: 24, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    reserved_32 = reserved_32_raw = decode_int(_data_raw_, running_bit_offset, 24)
    nmea2000Message.fields.append(NMEA2000Field('reserved_32', 'Reserved', None, None, reserved_32, reserved_32_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 24

    return nmea2000Message

def encode_pgn_130820_simnetReprogramStatus(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # reserved_16 | Offset: 16, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_16')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # status | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Status'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # reserved_32 | Offset: 32, Length: 24, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_32')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 32
    return data_raw

def decode_pgn_130820_furunoUnknown130820(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'furunoUnknown130820', 'Furuno: Unknown 130820')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1855, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Furuno", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:a | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:b | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:c | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:d | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    d = d_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('d', 'D', None, None, d, d_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:e | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    e = e_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('e', 'E', None, None, e, e_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130820_furunoUnknown130820(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # a | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # b | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # c | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # d | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'd')
    if field is None:
        raise Exception("Cant encode this message, missing 'D'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # e | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'e')
    if field is None:
        raise Exception("Cant encode this message, missing 'E'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    return data_raw

def decode_pgn_130820_fusionSourceName(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionSourceName', 'Fusion: Source Name')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 2, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "Source", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:source_id | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    source_id = source_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('source_id', 'Source ID', None, None, source_id, source_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:current_source_id | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    current_source_id = current_source_id_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('current_source_id', 'Current Source ID', None, None, current_source_id, current_source_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:d | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    d = d_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('d', 'D', None, None, d, d_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:e | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    e = e_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('e', 'E', None, None, e, e_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:source | Offset: 64, Length: 40, Signed: False Resolution: , Field Type: STRING_LZ, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    source = source_raw = decode_string_lz(_data_raw_, running_bit_offset, 40)
    nmea2000Message.fields.append(NMEA2000Field('source', 'Source', None, None, source, source_raw, None, FieldTypes.STRING_LZ, False))
    running_bit_offset += 40

    return nmea2000Message

def encode_pgn_130820_fusionSourceName(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # source_id | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'source_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # current_source_id | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'current_source_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Current Source ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # d | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'd')
    if field is None:
        raise Exception("Cant encode this message, missing 'D'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # e | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'e')
    if field is None:
        raise Exception("Cant encode this message, missing 'E'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    # source | Offset: 64, Length: 40, Resolution: , Field Type: STRING_LZ
    field = next(f for f in nmea2000Message.fields if f.id == 'source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFF) << 64
    return data_raw

def decode_pgn_130820_fusionTrackInfo(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionTrackInfo', 'Fusion: Track Info')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "Track Info", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:transport | Offset: 40, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    transport_raw = decode_int(_data_raw_, running_bit_offset, 4)
    transport = master_dict['ENTERTAINMENT_PLAY_STATUS'].get(transport_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('transport', 'Transport', None, None, transport, transport_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 7:x | Offset: 44, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 44
    x = x_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('x', 'X', None, None, x, x_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 8:b | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:track__ | Offset: 56, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    track__ = track___raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('track__', 'Track #', None, None, track__, track___raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 10:c | Offset: 72, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:track_count | Offset: 88, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    track_count = track_count_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('track_count', 'Track Count', None, None, track_count, track_count_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 12:e | Offset: 104, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 104
    e = e_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('e', 'E', None, None, e, e_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 13:length | Offset: 120, Length: 24, Signed: False Resolution: 0.001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    length_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 0.001)
    length = decode_time(length_raw)
    nmea2000Message.fields.append(NMEA2000Field('length', 'Length', None, 's', length, length_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 24

    # 14:position_in_track | Offset: 144, Length: 24, Signed: False Resolution: 0.001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    position_in_track_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 0.001)
    position_in_track = decode_time(position_in_track_raw)
    nmea2000Message.fields.append(NMEA2000Field('position_in_track', 'Position in track', None, 's', position_in_track, position_in_track_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 24

    # 15:h | Offset: 168, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 168
    h = h_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('h', 'H', None, None, h, h_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_130820_fusionTrackInfo(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 24
    # transport | Offset: 40, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'transport')
    if field is None:
        raise Exception("Cant encode this message, missing 'Transport'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_ENTERTAINMENT_PLAY_STATUS(field.value)
    data_raw |= (field_value & 0xF) << 40
    # x | Offset: 44, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'x')
    if field is None:
        raise Exception("Cant encode this message, missing 'X'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 44
    # b | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # track__ | Offset: 56, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'track__')
    if field is None:
        raise Exception("Cant encode this message, missing 'Track #'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 56
    # c | Offset: 72, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 72
    # track_count | Offset: 88, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'track_count')
    if field is None:
        raise Exception("Cant encode this message, missing 'Track Count'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 88
    # e | Offset: 104, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'e')
    if field is None:
        raise Exception("Cant encode this message, missing 'E'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 104
    # length | Offset: 120, Length: 24, Resolution: 0.001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'length')
    if field is None:
        raise Exception("Cant encode this message, missing 'Length'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFFFF) << 120
    
    # position_in_track | Offset: 144, Length: 24, Resolution: 0.001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'position_in_track')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position in track'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFFFF) << 144
    
    # h | Offset: 168, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'h')
    if field is None:
        raise Exception("Cant encode this message, missing 'H'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 168
    return data_raw

def decode_pgn_130820_fusionTrack(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionTrack', 'Fusion: Track')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 5, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "Track Title", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:b | Offset: 32, Length: 40, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 40, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 40

    # 7:track | Offset: 72, Length: 80, Signed: False Resolution: , Field Type: STRING_LZ, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    track = track_raw = decode_string_lz(_data_raw_, running_bit_offset, 80)
    nmea2000Message.fields.append(NMEA2000Field('track', 'Track', None, None, track, track_raw, None, FieldTypes.STRING_LZ, False))
    running_bit_offset += 80

    return nmea2000Message

def encode_pgn_130820_fusionTrack(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # b | Offset: 32, Length: 40, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFF) << 32
    # track | Offset: 72, Length: 80, Resolution: , Field Type: STRING_LZ
    field = next(f for f in nmea2000Message.fields if f.id == 'track')
    if field is None:
        raise Exception("Cant encode this message, missing 'Track'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFF) << 72
    return data_raw

def decode_pgn_130820_fusionArtist(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionArtist', 'Fusion: Artist')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 6, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "Track Artist", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:b | Offset: 32, Length: 40, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 40, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 40

    # 7:artist | Offset: 72, Length: 80, Signed: False Resolution: , Field Type: STRING_LZ, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    artist = artist_raw = decode_string_lz(_data_raw_, running_bit_offset, 80)
    nmea2000Message.fields.append(NMEA2000Field('artist', 'Artist', None, None, artist, artist_raw, None, FieldTypes.STRING_LZ, False))
    running_bit_offset += 80

    return nmea2000Message

def encode_pgn_130820_fusionArtist(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # b | Offset: 32, Length: 40, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFF) << 32
    # artist | Offset: 72, Length: 80, Resolution: , Field Type: STRING_LZ
    field = next(f for f in nmea2000Message.fields if f.id == 'artist')
    if field is None:
        raise Exception("Cant encode this message, missing 'Artist'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFF) << 72
    return data_raw

def decode_pgn_130820_fusionAlbum(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionAlbum', 'Fusion: Album')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 7, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "Track Album", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:b | Offset: 32, Length: 40, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 40, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 40

    # 7:album | Offset: 72, Length: 80, Signed: False Resolution: , Field Type: STRING_LZ, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    album = album_raw = decode_string_lz(_data_raw_, running_bit_offset, 80)
    nmea2000Message.fields.append(NMEA2000Field('album', 'Album', None, None, album, album_raw, None, FieldTypes.STRING_LZ, False))
    running_bit_offset += 80

    return nmea2000Message

def encode_pgn_130820_fusionAlbum(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # b | Offset: 32, Length: 40, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFF) << 32
    # album | Offset: 72, Length: 80, Resolution: , Field Type: STRING_LZ
    field = next(f for f in nmea2000Message.fields if f.id == 'album')
    if field is None:
        raise Exception("Cant encode this message, missing 'Album'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFF) << 72
    return data_raw

def decode_pgn_130820_fusionUnitName(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionUnitName', 'Fusion: Unit Name')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 33, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "Unit Name", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:name | Offset: 32, Length: 112, Signed: False Resolution: , Field Type: STRING_LZ, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    name = name_raw = decode_string_lz(_data_raw_, running_bit_offset, 112)
    nmea2000Message.fields.append(NMEA2000Field('name', 'Name', None, None, name, name_raw, None, FieldTypes.STRING_LZ, False))
    running_bit_offset += 112

    return nmea2000Message

def encode_pgn_130820_fusionUnitName(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # name | Offset: 32, Length: 112, Resolution: , Field Type: STRING_LZ
    field = next(f for f in nmea2000Message.fields if f.id == 'name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Name'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 32
    return data_raw

def decode_pgn_130820_fusionZoneName(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionZoneName', 'Fusion: Zone Name')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 45, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "Zone Name", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:number | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    number = number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number', 'Number', None, None, number, number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:name | Offset: 40, Length: 104, Signed: False Resolution: , Field Type: STRING_LZ, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    name = name_raw = decode_string_lz(_data_raw_, running_bit_offset, 104)
    nmea2000Message.fields.append(NMEA2000Field('name', 'Name', None, None, name, name_raw, None, FieldTypes.STRING_LZ, False))
    running_bit_offset += 104

    return nmea2000Message

def encode_pgn_130820_fusionZoneName(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # number | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # name | Offset: 40, Length: 104, Resolution: , Field Type: STRING_LZ
    field = next(f for f in nmea2000Message.fields if f.id == 'name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Name'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFF) << 40
    return data_raw

def decode_pgn_130820_fusionPlayProgress(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionPlayProgress', 'Fusion: Play Progress')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 9, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "Track Progress", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:b | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:progress | Offset: 40, Length: 24, Signed: False Resolution: 0.001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    progress_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 0.001)
    progress = decode_time(progress_raw)
    nmea2000Message.fields.append(NMEA2000Field('progress', 'Progress', None, 's', progress, progress_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 24

    return nmea2000Message

def encode_pgn_130820_fusionPlayProgress(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # b | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # progress | Offset: 40, Length: 24, Resolution: 0.001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'progress')
    if field is None:
        raise Exception("Cant encode this message, missing 'Progress'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.001) & 0xFFFFFF) << 40
    
    return data_raw

def decode_pgn_130820_fusionAmFmStation(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionAmFmStation', 'Fusion: AM/FM Station')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 11, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "AM/FM Station", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:am_fm | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    am_fm_raw = decode_int(_data_raw_, running_bit_offset, 8)
    am_fm = master_dict['FUSION_RADIO_SOURCE'].get(am_fm_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('am_fm', 'AM/FM', None, None, am_fm, am_fm_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:b | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:frequency | Offset: 48, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    frequency = frequency_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('frequency', 'Frequency', None, 'Hz', frequency, frequency_raw, PhysicalQuantities.FREQUENCY, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 9:c | Offset: 80, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:track | Offset: 88, Length: 80, Signed: False Resolution: , Field Type: STRING_LZ, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    track = track_raw = decode_string_lz(_data_raw_, running_bit_offset, 80)
    nmea2000Message.fields.append(NMEA2000Field('track', 'Track', None, None, track, track_raw, None, FieldTypes.STRING_LZ, False))
    running_bit_offset += 80

    return nmea2000Message

def encode_pgn_130820_fusionAmFmStation(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # am_fm | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'am_fm')
    if field is None:
        raise Exception("Cant encode this message, missing 'AM/FM'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_RADIO_SOURCE(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # b | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # frequency | Offset: 48, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'frequency')
    if field is None:
        raise Exception("Cant encode this message, missing 'Frequency'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 48
    # c | Offset: 80, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 80
    # track | Offset: 88, Length: 80, Resolution: , Field Type: STRING_LZ
    field = next(f for f in nmea2000Message.fields if f.id == 'track')
    if field is None:
        raise Exception("Cant encode this message, missing 'Track'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFF) << 88
    return data_raw

def decode_pgn_130820_fusionVhf(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionVhf', 'Fusion: VHF')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 12, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "VHF", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:b | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:channel | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    channel = channel_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('channel', 'Channel', None, None, channel, channel_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:d | Offset: 48, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    d = d_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('d', 'D', None, None, d, d_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    return nmea2000Message

def encode_pgn_130820_fusionVhf(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # b | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # channel | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'channel')
    if field is None:
        raise Exception("Cant encode this message, missing 'Channel'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # d | Offset: 48, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'd')
    if field is None:
        raise Exception("Cant encode this message, missing 'D'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 48
    return data_raw

def decode_pgn_130820_fusionSquelch(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionSquelch', 'Fusion: Squelch')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 13, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "Squelch", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:b | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:squelch | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    squelch = squelch_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('squelch', 'Squelch', None, None, squelch, squelch_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130820_fusionSquelch(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # b | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # squelch | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'squelch')
    if field is None:
        raise Exception("Cant encode this message, missing 'Squelch'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    return data_raw

def decode_pgn_130820_fusionScan(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionScan', 'Fusion: Scan')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 14, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "Scan", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:b | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:scan | Offset: 40, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    scan_raw = decode_int(_data_raw_, running_bit_offset, 2)
    scan = master_dict['YES_NO'].get(scan_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('scan', 'Scan', None, None, scan, scan_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 8:c | Offset: 42, Length: 6, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 42
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 6, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 6

    return nmea2000Message

def encode_pgn_130820_fusionScan(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # b | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # scan | Offset: 40, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'scan')
    if field is None:
        raise Exception("Cant encode this message, missing 'Scan'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_YES_NO(field.value)
    data_raw |= (field_value & 0x3) << 40
    # c | Offset: 42, Length: 6, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 42
    return data_raw

def decode_pgn_130820_fusionMenuItem(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionMenuItem', 'Fusion: Menu Item')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 17, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "Menu Item", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:b | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:line | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    line = line_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('line', 'Line', None, None, line, line_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:e | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    e = e_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('e', 'E', None, None, e, e_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:f | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    f = f_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('f', 'F', None, None, f, f_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:g | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    g = g_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('g', 'G', None, None, g, g_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 11:h | Offset: 72, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    h = h_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('h', 'H', None, None, h, h_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 12:i | Offset: 80, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    i = i_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('i', 'I', None, None, i, i_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 13:text | Offset: 88, Length: 40, Signed: False Resolution: , Field Type: STRING_LZ, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    text = text_raw = decode_string_lz(_data_raw_, running_bit_offset, 40)
    nmea2000Message.fields.append(NMEA2000Field('text', 'Text', None, None, text, text_raw, None, FieldTypes.STRING_LZ, False))
    running_bit_offset += 40

    return nmea2000Message

def encode_pgn_130820_fusionMenuItem(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # b | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # line | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'line')
    if field is None:
        raise Exception("Cant encode this message, missing 'Line'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # e | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'e')
    if field is None:
        raise Exception("Cant encode this message, missing 'E'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # f | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'f')
    if field is None:
        raise Exception("Cant encode this message, missing 'F'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    # g | Offset: 64, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'g')
    if field is None:
        raise Exception("Cant encode this message, missing 'G'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 64
    # h | Offset: 72, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'h')
    if field is None:
        raise Exception("Cant encode this message, missing 'H'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 72
    # i | Offset: 80, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'i')
    if field is None:
        raise Exception("Cant encode this message, missing 'I'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 80
    # text | Offset: 88, Length: 40, Resolution: , Field Type: STRING_LZ
    field = next(f for f in nmea2000Message.fields if f.id == 'text')
    if field is None:
        raise Exception("Cant encode this message, missing 'Text'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFF) << 88
    return data_raw

def decode_pgn_130820_fusionReplay(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionReplay', 'Fusion: Replay')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 20, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "Replay", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:mode | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    mode_raw = decode_int(_data_raw_, running_bit_offset, 8)
    mode = master_dict['FUSION_REPLAY_MODE'].get(mode_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('mode', 'Mode', None, None, mode, mode_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:c | Offset: 40, Length: 24, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 24, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 24

    # 8:d | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    d = d_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('d', 'D', None, None, d, d_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:e | Offset: 72, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    e = e_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('e', 'E', None, None, e, e_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:status | Offset: 80, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    status_raw = decode_int(_data_raw_, running_bit_offset, 8)
    status = master_dict['FUSION_REPLAY_STATUS'].get(status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('status', 'Status', None, None, status, status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 11:h | Offset: 88, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    h = h_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('h', 'H', None, None, h, h_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 12:i | Offset: 96, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 96
    i = i_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('i', 'I', None, None, i, i_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 13:j | Offset: 104, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 104
    j = j_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('j', 'J', None, None, j, j_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130820_fusionReplay(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # mode | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'mode')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mode'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_REPLAY_MODE(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # c | Offset: 40, Length: 24, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFF) << 40
    # d | Offset: 64, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'd')
    if field is None:
        raise Exception("Cant encode this message, missing 'D'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 64
    # e | Offset: 72, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'e')
    if field is None:
        raise Exception("Cant encode this message, missing 'E'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 72
    # status | Offset: 80, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_REPLAY_STATUS(field.value)
    data_raw |= (field_value & 0xFF) << 80
    # h | Offset: 88, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'h')
    if field is None:
        raise Exception("Cant encode this message, missing 'H'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 88
    # i | Offset: 96, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'i')
    if field is None:
        raise Exception("Cant encode this message, missing 'I'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 96
    # j | Offset: 104, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'j')
    if field is None:
        raise Exception("Cant encode this message, missing 'J'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 104
    return data_raw

def decode_pgn_130820_fusionMute(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionMute', 'Fusion: Mute')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 23, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "Mute", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:mute | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    mute_raw = decode_int(_data_raw_, running_bit_offset, 8)
    mute = master_dict['FUSION_MUTE_COMMAND'].get(mute_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('mute', 'Mute', None, None, mute, mute_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130820_fusionMute(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # mute | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'mute')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mute'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MUTE_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 32
    return data_raw

def decode_pgn_130820_fusionSubVolume(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionSubVolume', 'Fusion: Sub Volume')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 26, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "Sub Volume", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:zone_1 | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    zone_1 = zone_1_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone_1', 'Zone 1', None, None, zone_1, zone_1_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:zone_2 | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    zone_2 = zone_2_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone_2', 'Zone 2', None, None, zone_2, zone_2_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:zone_3 | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    zone_3 = zone_3_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone_3', 'Zone 3', None, None, zone_3, zone_3_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:zone_4 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    zone_4 = zone_4_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone_4', 'Zone 4', None, None, zone_4, zone_4_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130820_fusionSubVolume(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # zone_1 | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zone_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone 1'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # zone_2 | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zone_2')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone 2'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # zone_3 | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zone_3')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone 3'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # zone_4 | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zone_4')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone 4'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw

def decode_pgn_130820_fusionTone(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionTone', 'Fusion: Tone')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 27, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "Tone", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:b | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:bass | Offset: 40, Length: 8, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    bass = bass_raw = decode_number(_data_raw_, running_bit_offset, 8, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('bass', 'Bass', None, None, bass, bass_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:mid | Offset: 48, Length: 8, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    mid = mid_raw = decode_number(_data_raw_, running_bit_offset, 8, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('mid', 'Mid', None, None, mid, mid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:treble | Offset: 56, Length: 8, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    treble = treble_raw = decode_number(_data_raw_, running_bit_offset, 8, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('treble', 'Treble', None, None, treble, treble_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130820_fusionTone(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # b | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # bass | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'bass')
    if field is None:
        raise Exception("Cant encode this message, missing 'Bass'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # mid | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'mid')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mid'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # treble | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'treble')
    if field is None:
        raise Exception("Cant encode this message, missing 'Treble'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw

def decode_pgn_130820_fusionVolume(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionVolume', 'Fusion: Volume')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 29, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "Volume", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:zone_1 | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    zone_1 = zone_1_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone_1', 'Zone 1', None, None, zone_1, zone_1_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:zone_2 | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    zone_2 = zone_2_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone_2', 'Zone 2', None, None, zone_2, zone_2_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:zone_3 | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    zone_3 = zone_3_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone_3', 'Zone 3', None, None, zone_3, zone_3_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:zone_4 | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    zone_4 = zone_4_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('zone_4', 'Zone 4', None, None, zone_4, zone_4_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130820_fusionVolume(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # zone_1 | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zone_1')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone 1'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # zone_2 | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zone_2')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone 2'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # zone_3 | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zone_3')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone 3'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # zone_4 | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'zone_4')
    if field is None:
        raise Exception("Cant encode this message, missing 'Zone 4'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    return data_raw

def decode_pgn_130820_fusionPowerState(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionPowerState', 'Fusion: Power State')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 32, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "Power", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:state | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    state_raw = decode_int(_data_raw_, running_bit_offset, 8)
    state = master_dict['FUSION_POWER_STATE'].get(state_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('state', 'State', None, None, state, state_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130820_fusionPowerState(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # state | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'state')
    if field is None:
        raise Exception("Cant encode this message, missing 'State'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_POWER_STATE(field.value)
    data_raw |= (field_value & 0xFF) << 32
    return data_raw

def decode_pgn_130820_fusionSiriusxmChannel(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionSiriusxmChannel', 'Fusion: SiriusXM Channel')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 36, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "SiriusXM Channel", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:channel | Offset: 56, Length: 96, Signed: False Resolution: , Field Type: STRING_LZ, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    channel = channel_raw = decode_string_lz(_data_raw_, running_bit_offset, 96)
    nmea2000Message.fields.append(NMEA2000Field('channel', 'Channel', None, None, channel, channel_raw, None, FieldTypes.STRING_LZ, False))
    running_bit_offset += 96

    return nmea2000Message

def encode_pgn_130820_fusionSiriusxmChannel(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 24
    # channel | Offset: 56, Length: 96, Resolution: , Field Type: STRING_LZ
    field = next(f for f in nmea2000Message.fields if f.id == 'channel')
    if field is None:
        raise Exception("Cant encode this message, missing 'Channel'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFF) << 56
    return data_raw

def decode_pgn_130820_fusionSiriusxmTitle(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionSiriusxmTitle', 'Fusion: SiriusXM Title')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 37, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "SiriusXM Title", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:title | Offset: 56, Length: 96, Signed: False Resolution: , Field Type: STRING_LZ, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    title = title_raw = decode_string_lz(_data_raw_, running_bit_offset, 96)
    nmea2000Message.fields.append(NMEA2000Field('title', 'Title', None, None, title, title_raw, None, FieldTypes.STRING_LZ, False))
    running_bit_offset += 96

    return nmea2000Message

def encode_pgn_130820_fusionSiriusxmTitle(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 24
    # title | Offset: 56, Length: 96, Resolution: , Field Type: STRING_LZ
    field = next(f for f in nmea2000Message.fields if f.id == 'title')
    if field is None:
        raise Exception("Cant encode this message, missing 'Title'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFF) << 56
    return data_raw

def decode_pgn_130820_fusionSiriusxmArtist(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionSiriusxmArtist', 'Fusion: SiriusXM Artist')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 38, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "SiriusXM Artist", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:artist | Offset: 56, Length: 96, Signed: False Resolution: , Field Type: STRING_LZ, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    artist = artist_raw = decode_string_lz(_data_raw_, running_bit_offset, 96)
    nmea2000Message.fields.append(NMEA2000Field('artist', 'Artist', None, None, artist, artist_raw, None, FieldTypes.STRING_LZ, False))
    running_bit_offset += 96

    return nmea2000Message

def encode_pgn_130820_fusionSiriusxmArtist(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 24
    # artist | Offset: 56, Length: 96, Resolution: , Field Type: STRING_LZ
    field = next(f for f in nmea2000Message.fields if f.id == 'artist')
    if field is None:
        raise Exception("Cant encode this message, missing 'Artist'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFF) << 56
    return data_raw

def decode_pgn_130820_fusionSiriusxmGenre(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130820."""
    nmea2000Message = NMEA2000Message(130820, 'fusionSiriusxmGenre', 'Fusion: SiriusXM Genre')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 419, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Fusion Electronics", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 40, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    message_id = master_dict['FUSION_MESSAGE_ID'].get(message_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "SiriusXM Genre", None, message_id, message_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:genre | Offset: 56, Length: 96, Signed: False Resolution: , Field Type: STRING_LZ, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    genre = genre_raw = decode_string_lz(_data_raw_, running_bit_offset, 96)
    nmea2000Message.fields.append(NMEA2000Field('genre', 'Genre', None, None, genre, genre_raw, None, FieldTypes.STRING_LZ, False))
    running_bit_offset += 96

    return nmea2000Message

def encode_pgn_130820_fusionSiriusxmGenre(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130820."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_FUSION_MESSAGE_ID(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 24
    # genre | Offset: 56, Length: 96, Resolution: , Field Type: STRING_LZ
    field = next(f for f in nmea2000Message.fields if f.id == 'genre')
    if field is None:
        raise Exception("Cant encode this message, missing 'Genre'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFF) << 56
    return data_raw


def is_fast_pgn_130821() -> bool:
    """Return True if PGN 130821 is a fast PGN."""
    return True
# Complex PGN. number of matches: 2
def decode_pgn_130821(data_raw: int) -> NMEA2000Message:
    # navicoAsciiData | Description: Navico: ASCII Data
    if (
        (((data_raw >> 0) & 0x7FF) == 275) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_130821_navicoAsciiData(data_raw)
    
    # furunoUnknown130821 | Description: Furuno: Unknown 130821
    if (
        (((data_raw >> 0) & 0x7FF) == 1855) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_130821_furunoUnknown130821(data_raw)
    
    
    raise Exception("No matching sub-PGN found")
    
def decode_pgn_130821_navicoAsciiData(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130821."""
    nmea2000Message = NMEA2000Message(130821, 'navicoAsciiData', 'Navico: ASCII Data')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:a | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:message | Offset: 24, Length: 1840, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    message = message_raw = decode_string_fix(_data_raw_, running_bit_offset, 1840)
    nmea2000Message.fields.append(NMEA2000Field('message', 'Message', None, None, message, message_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 1840

    return nmea2000Message

def encode_pgn_130821_navicoAsciiData(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130821."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # a | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # message | Offset: 24, Length: 1840, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'message')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 24
    return data_raw

def decode_pgn_130821_furunoUnknown130821(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130821."""
    nmea2000Message = NMEA2000Message(130821, 'furunoUnknown130821', 'Furuno: Unknown 130821')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1855, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Furuno", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:sid | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:a | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:b | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:c | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:d | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    d = d_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('d', 'D', None, None, d, d_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:e | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    e = e_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('e', 'E', None, None, e, e_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 10:f | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    f = f_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('f', 'F', None, None, f, f_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 11:g | Offset: 72, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    g = g_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('g', 'G', None, None, g, g_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 12:h | Offset: 80, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    h = h_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('h', 'H', None, None, h, h_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 13:i | Offset: 88, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    i = i_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('i', 'I', None, None, i, i_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130821_furunoUnknown130821(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130821."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # sid | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # a | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # b | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # c | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # d | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'd')
    if field is None:
        raise Exception("Cant encode this message, missing 'D'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # e | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'e')
    if field is None:
        raise Exception("Cant encode this message, missing 'E'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    # f | Offset: 64, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'f')
    if field is None:
        raise Exception("Cant encode this message, missing 'F'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 64
    # g | Offset: 72, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'g')
    if field is None:
        raise Exception("Cant encode this message, missing 'G'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 72
    # h | Offset: 80, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'h')
    if field is None:
        raise Exception("Cant encode this message, missing 'H'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 80
    # i | Offset: 88, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'i')
    if field is None:
        raise Exception("Cant encode this message, missing 'I'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 88
    return data_raw


def is_fast_pgn_130822() -> bool:
    """Return True if PGN 130822 is a fast PGN."""
    return True
def decode_pgn_130822(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130822."""
    nmea2000Message = NMEA2000Message(130822, 'navicoUnknown1', 'Navico: Unknown 1')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:data | Offset: 16, Length: 1848, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    data = data_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 1848))
    nmea2000Message.fields.append(NMEA2000Field('data', 'Data', None, None, data, data_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 1848

    return nmea2000Message

def encode_pgn_130822(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130822."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # data | Offset: 16, Length: 1848, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'data')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data'")
    # Skipping fields longer than 256
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 16
    return data_raw


def is_fast_pgn_130823() -> bool:
    """Return True if PGN 130823 is a fast PGN."""
    return True
def decode_pgn_130823(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130823."""
    nmea2000Message = NMEA2000Message(130823, 'maretronProprietaryTemperatureHighRange', 'Maretron: Proprietary Temperature High Range')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 137, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Maretron", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:sid | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:instance | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 24
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 6:source | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    source_raw = decode_int(_data_raw_, running_bit_offset, 8)
    source = master_dict['TEMPERATURE_SOURCE'].get(source_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('source', 'Source', None, None, source, source_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:actual_temperature | Offset: 40, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    actual_temperature = actual_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('actual_temperature', 'Actual Temperature', None, 'K', actual_temperature, actual_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:set_temperature | Offset: 56, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    set_temperature = set_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('set_temperature', 'Set Temperature', None, 'K', set_temperature, set_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_130823(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130823."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # sid | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # instance | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # source | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'source')
    if field is None:
        raise Exception("Cant encode this message, missing 'Source'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_TEMPERATURE_SOURCE(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # actual_temperature | Offset: 40, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'actual_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Actual Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 40
    
    # set_temperature | Offset: 56, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'set_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Set Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 56
    
    return data_raw


def is_fast_pgn_130824() -> bool:
    """Return True if PGN 130824 is a fast PGN."""
    return True
# Complex PGN. number of matches: 2
def decode_pgn_130824(data_raw: int) -> NMEA2000Message:
    # bGKeyValueData | Description: B&G: key-value data
    if (
        (((data_raw >> 0) & 0x7FF) == 381) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_130824_bGKeyValueData(data_raw)
    
    # maretronAnnunciator | Description: Maretron: Annunciator
    if (
        (((data_raw >> 0) & 0x7FF) == 137) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_130824_maretronAnnunciator(data_raw)
    
    
    raise Exception("No matching sub-PGN found")
    
def decode_pgn_130824_bGKeyValueData(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130824."""
    nmea2000Message = NMEA2000Message(130824, 'bGKeyValueData', 'B&G: key-value data')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 381, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "B & G", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:key | Offset: 16, Length: 12, Signed: False Resolution: 1, Field Type: FIELDTYPE_LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    key_raw = decode_int(_data_raw_, running_bit_offset, 12)
    kv_metadata = lookup_field_type_BANDG_KEY_VALUE(key_raw)
    key = kv_name = kv_metadata.name
    nmea2000Message.fields.append(NMEA2000Field('key', 'Key', None, None, key, key_raw, None, FieldTypes.FIELDTYPE_LOOKUP, False))
    running_bit_offset += 12

    # 5:length | Offset: 28, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 28
    length = length_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('length', 'Length', "Length of field 6", None, length, length_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 6:value | Offset: , Length: , Signed: False Resolution: , Field Type: KEY_VALUE, Match: , PartOfPrimaryKey: ,
    if kv_metadata.field_type == 'LOOKUP':
        value_raw = decode_int(_data_raw_, running_bit_offset, kv_metadata.bits)
        value = master_dict[kv_metadata.lookup_enumeration].get(value_raw, None)
    if kv_metadata.field_type == 'NUMBER':
        value = value_raw = decode_number(_data_raw_, running_bit_offset, kv_metadata.bits, False, kv_metadata.resolution)
    if kv_metadata.field_type == 'TIME':
        value_raw = decode_number(_data_raw_, running_bit_offset, kv_metadata.bits, False,kv_metadata.resolution)
        value = decode_time(value_raw)
    nmea2000Message.fields.append(NMEA2000Field('value', kv_metadata.name, '', kv_metadata.unit, value, value_raw, None, kv_metadata.field_type, False))
    running_bit_offset += kv_metadata.bits

    return nmea2000Message

def encode_pgn_130824_bGKeyValueData(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130824."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # key | Offset: 16, Length: 12, Resolution: 1, Field Type: FIELDTYPE_LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'key')
    if field is None:
        raise Exception("Cant encode this message, missing 'Key'")
    field_value = field.value
    data_raw |= (field_value & 0xFFF) << 16
    # length | Offset: 28, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'length')
    if field is None:
        raise Exception("Cant encode this message, missing 'Length'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 28
    raise Exception ("PGN 130824 not supporting encoding for now as Value is missing BitLength or BitOffset")
    return data_raw

def decode_pgn_130824_maretronAnnunciator(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130824."""
    nmea2000Message = NMEA2000Message(130824, 'maretronAnnunciator', 'Maretron: Annunciator')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 137, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Maretron", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:field_4 | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    field_4 = field_4_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('field_4', 'Field 4', None, None, field_4, field_4_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:field_5 | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    field_5 = field_5_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('field_5', 'Field 5', None, None, field_5, field_5_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:field_6 | Offset: 32, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    field_6 = field_6_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('field_6', 'Field 6', None, None, field_6, field_6_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:field_7 | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    field_7 = field_7_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('field_7', 'Field 7', None, None, field_7, field_7_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:field_8 | Offset: 56, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    field_8 = field_8_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('field_8', 'Field 8', None, None, field_8, field_8_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_130824_maretronAnnunciator(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130824."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # field_4 | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'field_4')
    if field is None:
        raise Exception("Cant encode this message, missing 'Field 4'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # field_5 | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'field_5')
    if field is None:
        raise Exception("Cant encode this message, missing 'Field 5'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # field_6 | Offset: 32, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'field_6')
    if field is None:
        raise Exception("Cant encode this message, missing 'Field 6'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 32
    # field_7 | Offset: 48, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'field_7')
    if field is None:
        raise Exception("Cant encode this message, missing 'Field 7'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 48
    # field_8 | Offset: 56, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'field_8')
    if field is None:
        raise Exception("Cant encode this message, missing 'Field 8'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 56
    return data_raw


def is_fast_pgn_130825() -> bool:
    """Return True if PGN 130825 is a fast PGN."""
    return True
def decode_pgn_130825(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130825."""
    nmea2000Message = NMEA2000Message(130825, 'navicoUnknown2', 'Navico: Unknown 2')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 275, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Navico", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:data | Offset: 16, Length: 80, Signed: False Resolution: 1, Field Type: BINARY, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    data = data_raw = int_to_bytes(decode_int(_data_raw_, running_bit_offset, 80))
    nmea2000Message.fields.append(NMEA2000Field('data', 'Data', None, None, data, data_raw, None, FieldTypes.BINARY, False))
    running_bit_offset += 80

    return nmea2000Message

def encode_pgn_130825(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130825."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # data | Offset: 16, Length: 80, Resolution: 1, Field Type: BINARY
    field = next(f for f in nmea2000Message.fields if f.id == 'data')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFF) << 16
    return data_raw


def is_fast_pgn_130827() -> bool:
    """Return True if PGN 130827 is a fast PGN."""
    return True
def decode_pgn_130827(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130827."""
    nmea2000Message = NMEA2000Message(130827, 'lowranceUnknown', 'Lowrance: unknown')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 140, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Lowrance", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:a | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:b | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:c | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:d | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    d = d_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('d', 'D', None, None, d, d_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:e | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    e = e_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('e', 'E', None, None, e, e_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:f | Offset: 64, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    f = f_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('f', 'F', None, None, f, f_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_130827(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130827."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # a | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # b | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # c | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # d | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'd')
    if field is None:
        raise Exception("Cant encode this message, missing 'D'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # e | Offset: 48, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'e')
    if field is None:
        raise Exception("Cant encode this message, missing 'E'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    # f | Offset: 64, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'f')
    if field is None:
        raise Exception("Cant encode this message, missing 'F'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 64
    return data_raw


def is_fast_pgn_130828() -> bool:
    """Return True if PGN 130828 is a fast PGN."""
    return True
def decode_pgn_130828(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130828."""
    nmea2000Message = NMEA2000Message(130828, 'simnetSetSerialNumber', 'Simnet: Set Serial Number')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    return nmea2000Message

def encode_pgn_130828(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130828."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    return data_raw


def is_fast_pgn_130831() -> bool:
    """Return True if PGN 130831 is a fast PGN."""
    return True
def decode_pgn_130831(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130831."""
    nmea2000Message = NMEA2000Message(130831, 'suzukiEngineAndStorageDeviceConfig', 'Suzuki: Engine and Storage Device Config')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 586, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Suzuki Motor Corporation", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    return nmea2000Message

def encode_pgn_130831(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130831."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    return data_raw


def is_fast_pgn_130832() -> bool:
    """Return True if PGN 130832 is a fast PGN."""
    return True
def decode_pgn_130832(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130832."""
    nmea2000Message = NMEA2000Message(130832, 'simnetFuelUsedHighResolution', 'Simnet: Fuel Used - High Resolution')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    return nmea2000Message

def encode_pgn_130832(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130832."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    return data_raw


def is_fast_pgn_130833() -> bool:
    """Return True if PGN 130833 is a fast PGN."""
    return True
def decode_pgn_130833(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130833."""
    nmea2000Message = NMEA2000Message(130833, 'bGUserAndRemoteRename', 'B&G: User and Remote rename')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 381, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "B & G", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:data_type | Offset: 16, Length: 12, Signed: False Resolution: 1, Field Type: FIELDTYPE_LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    data_type_raw = decode_int(_data_raw_, running_bit_offset, 12)
    kv_metadata = lookup_field_type_BANDG_KEY_VALUE(data_type_raw)
    data_type = kv_name = kv_metadata.name
    nmea2000Message.fields.append(NMEA2000Field('data_type', 'Data Type', None, None, data_type, data_type_raw, None, FieldTypes.FIELDTYPE_LOOKUP, False))
    running_bit_offset += 12

    # 5:length | Offset: 28, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 28
    length = length_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('length', 'Length', "Length of field 8", None, length, length_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 6:reserved_32 | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    reserved_32 = reserved_32_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_32', 'Reserved', None, None, reserved_32, reserved_32_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 7:decimals | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    decimals_raw = decode_int(_data_raw_, running_bit_offset, 8)
    decimals = master_dict['BANDG_DECIMALS'].get(decimals_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('decimals', 'Decimals', None, None, decimals, decimals_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 8:short_name | Offset: 48, Length: 64, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    short_name = short_name_raw = decode_string_fix(_data_raw_, running_bit_offset, 64)
    nmea2000Message.fields.append(NMEA2000Field('short_name', 'Short name', None, None, short_name, short_name_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 64

    # 9:long_name | Offset: 112, Length: 128, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    long_name = long_name_raw = decode_string_fix(_data_raw_, running_bit_offset, 128)
    nmea2000Message.fields.append(NMEA2000Field('long_name', 'Long name', None, None, long_name, long_name_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 128

    return nmea2000Message

def encode_pgn_130833(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130833."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # data_type | Offset: 16, Length: 12, Resolution: 1, Field Type: FIELDTYPE_LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'data_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Data Type'")
    field_value = field.value
    data_raw |= (field_value & 0xFFF) << 16
    # length | Offset: 28, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'length')
    if field is None:
        raise Exception("Cant encode this message, missing 'Length'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 28
    # reserved_32 | Offset: 32, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_32')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # decimals | Offset: 40, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'decimals')
    if field is None:
        raise Exception("Cant encode this message, missing 'Decimals'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_BANDG_DECIMALS(field.value)
    data_raw |= (field_value & 0xFF) << 40
    # short_name | Offset: 48, Length: 64, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'short_name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Short name'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFF) << 48
    # long_name | Offset: 112, Length: 128, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'long_name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Long name'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 112
    return data_raw


def is_fast_pgn_130834() -> bool:
    """Return True if PGN 130834 is a fast PGN."""
    return True
def decode_pgn_130834(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130834."""
    nmea2000Message = NMEA2000Message(130834, 'simnetEngineAndTankConfiguration', 'Simnet: Engine and Tank Configuration')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    return nmea2000Message

def encode_pgn_130834(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130834."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    return data_raw


def is_fast_pgn_130835() -> bool:
    """Return True if PGN 130835 is a fast PGN."""
    return True
def decode_pgn_130835(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130835."""
    nmea2000Message = NMEA2000Message(130835, 'simnetSetEngineAndTankConfiguration', 'Simnet: Set Engine and Tank Configuration')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    return nmea2000Message

def encode_pgn_130835(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130835."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    return data_raw


def is_fast_pgn_130836() -> bool:
    """Return True if PGN 130836 is a fast PGN."""
    return True
# Complex PGN. number of matches: 2
def decode_pgn_130836(data_raw: int) -> NMEA2000Message:
    # simnetFluidLevelSensorConfiguration | Description: Simnet: Fluid Level Sensor Configuration
    if (
        (((data_raw >> 0) & 0x7FF) == 1857) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_130836_simnetFluidLevelSensorConfiguration(data_raw)
    
    # maretronSwitchStatusCounter | Description: Maretron: Switch Status Counter
    if (
        (((data_raw >> 0) & 0x7FF) == 137) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_130836_maretronSwitchStatusCounter(data_raw)
    
    
    raise Exception("No matching sub-PGN found")
    
def decode_pgn_130836_simnetFluidLevelSensorConfiguration(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130836."""
    nmea2000Message = NMEA2000Message(130836, 'simnetFluidLevelSensorConfiguration', 'Simnet: Fluid Level Sensor Configuration')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:c | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:device | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 24
    device = device_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('device', 'Device', None, None, device, device_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 6:instance | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 32
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 7:f | Offset: 40, Length: 4, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    f = f_raw = decode_number(_data_raw_, running_bit_offset, 4, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('f', 'F', None, None, f, f_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 4

    # 8:tank_type | Offset: 44, Length: 4, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 44
    tank_type_raw = decode_int(_data_raw_, running_bit_offset, 4)
    tank_type = master_dict['TANK_TYPE'].get(tank_type_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('tank_type', 'Tank type', None, None, tank_type, tank_type_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 4

    # 9:capacity | Offset: 48, Length: 32, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    capacity = capacity_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('capacity', 'Capacity', None, 'L', capacity, capacity_raw, PhysicalQuantities.VOLUME, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 10:g | Offset: 80, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    g = g_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('g', 'G', None, None, g, g_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 11:h | Offset: 88, Length: 16, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    h = h_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('h', 'H', None, None, h, h_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 12:i | Offset: 104, Length: 8, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 104
    i = i_raw = decode_number(_data_raw_, running_bit_offset, 8, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('i', 'I', None, None, i, i_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130836_simnetFluidLevelSensorConfiguration(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130836."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # c | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # device | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'device')
    if field is None:
        raise Exception("Cant encode this message, missing 'Device'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # instance | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # f | Offset: 40, Length: 4, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'f')
    if field is None:
        raise Exception("Cant encode this message, missing 'F'")
    field_value = field.value
    data_raw |= (field_value & 0xF) << 40
    # tank_type | Offset: 44, Length: 4, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'tank_type')
    if field is None:
        raise Exception("Cant encode this message, missing 'Tank type'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_TANK_TYPE(field.value)
    data_raw |= (field_value & 0xF) << 44
    # capacity | Offset: 48, Length: 32, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'capacity')
    if field is None:
        raise Exception("Cant encode this message, missing 'Capacity'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFFFFFF) << 48
    
    # g | Offset: 80, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'g')
    if field is None:
        raise Exception("Cant encode this message, missing 'G'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 80
    # h | Offset: 88, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'h')
    if field is None:
        raise Exception("Cant encode this message, missing 'H'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 88
    # i | Offset: 104, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'i')
    if field is None:
        raise Exception("Cant encode this message, missing 'I'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 104
    return data_raw

def decode_pgn_130836_maretronSwitchStatusCounter(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130836."""
    nmea2000Message = NMEA2000Message(130836, 'maretronSwitchStatusCounter', 'Maretron: Switch Status Counter')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 137, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Maretron", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:instance | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 16
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 5:indicator_number | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    indicator_number = indicator_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('indicator_number', 'Indicator Number', None, None, indicator_number, indicator_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:start_date | Offset: 32, Length: 16, Signed: False Resolution: 1, Field Type: DATE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    start_date_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    start_date = decode_date(start_date_raw)
    nmea2000Message.fields.append(NMEA2000Field('start_date', 'Start Date', None, 'd', start_date, start_date_raw, PhysicalQuantities.DATE, FieldTypes.DATE, False))
    running_bit_offset += 16

    # 7:start_time | Offset: 48, Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    start_time_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    start_time = decode_time(start_time_raw)
    nmea2000Message.fields.append(NMEA2000Field('start_time', 'Start Time', "Seconds since midnight", 's', start_time, start_time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 8:off_counter | Offset: 80, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    off_counter = off_counter_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('off_counter', 'OFF Counter', None, None, off_counter, off_counter_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 9:on_counter | Offset: 112, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    on_counter = on_counter_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('on_counter', 'ON Counter', None, None, on_counter, on_counter_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 10:error_counter | Offset: 144, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    error_counter = error_counter_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('error_counter', 'ERROR Counter', None, None, error_counter, error_counter_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 11:switch_status | Offset: 176, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 176
    switch_status_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch_status = master_dict['OFF_ON'].get(switch_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch_status', 'Switch Status', None, None, switch_status, switch_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 12:reserved_178 | Offset: 178, Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 178
    reserved_178 = reserved_178_raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_178', 'Reserved', None, None, reserved_178, reserved_178_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    return nmea2000Message

def encode_pgn_130836_maretronSwitchStatusCounter(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130836."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # instance | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # indicator_number | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # start_date | Offset: 32, Length: 16, Resolution: 1, Field Type: DATE
    field = next(f for f in nmea2000Message.fields if f.id == 'start_date')
    if field is None:
        raise Exception("Cant encode this message, missing 'Start Date'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 32
    # start_time | Offset: 48, Length: 32, Resolution: 0.0001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'start_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Start Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFFFFFF) << 48
    
    # off_counter | Offset: 80, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'off_counter')
    if field is None:
        raise Exception("Cant encode this message, missing 'OFF Counter'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 80
    # on_counter | Offset: 112, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'on_counter')
    if field is None:
        raise Exception("Cant encode this message, missing 'ON Counter'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 112
    # error_counter | Offset: 144, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'error_counter')
    if field is None:
        raise Exception("Cant encode this message, missing 'ERROR Counter'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 144
    # switch_status | Offset: 176, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 176
    # reserved_178 | Offset: 178, Length: 6, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_178')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 178
    return data_raw


def is_fast_pgn_130837() -> bool:
    """Return True if PGN 130837 is a fast PGN."""
    return True
# Complex PGN. number of matches: 2
def decode_pgn_130837(data_raw: int) -> NMEA2000Message:
    # simnetFuelFlowTurbineConfiguration | Description: Simnet: Fuel Flow Turbine Configuration
    if (
        (((data_raw >> 0) & 0x7FF) == 1857) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_130837_simnetFuelFlowTurbineConfiguration(data_raw)
    
    # maretronSwitchStatusTimer | Description: Maretron: Switch Status Timer
    if (
        (((data_raw >> 0) & 0x7FF) == 137) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_130837_maretronSwitchStatusTimer(data_raw)
    
    
    raise Exception("No matching sub-PGN found")
    
def decode_pgn_130837_simnetFuelFlowTurbineConfiguration(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130837."""
    nmea2000Message = NMEA2000Message(130837, 'simnetFuelFlowTurbineConfiguration', 'Simnet: Fuel Flow Turbine Configuration')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    return nmea2000Message

def encode_pgn_130837_simnetFuelFlowTurbineConfiguration(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130837."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    return data_raw

def decode_pgn_130837_maretronSwitchStatusTimer(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130837."""
    nmea2000Message = NMEA2000Message(130837, 'maretronSwitchStatusTimer', 'Maretron: Switch Status Timer')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 137, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Maretron", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:instance | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 16
    instance = instance_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('instance', 'Instance', None, None, instance, instance_raw, None, FieldTypes.NUMBER, True))
    running_bit_offset += 8

    # 5:indicator_number | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    indicator_number = indicator_number_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('indicator_number', 'Indicator Number', None, None, indicator_number, indicator_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:start_date | Offset: 32, Length: 16, Signed: False Resolution: 1, Field Type: DATE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    start_date_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    start_date = decode_date(start_date_raw)
    nmea2000Message.fields.append(NMEA2000Field('start_date', 'Start Date', None, 'd', start_date, start_date_raw, PhysicalQuantities.DATE, FieldTypes.DATE, False))
    running_bit_offset += 16

    # 7:start_time | Offset: 48, Length: 32, Signed: False Resolution: 0.0001, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    start_time_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.0001)
    start_time = decode_time(start_time_raw)
    nmea2000Message.fields.append(NMEA2000Field('start_time', 'Start Time', "Seconds since midnight", 's', start_time, start_time_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 8:accumulated_off_period | Offset: 80, Length: 32, Signed: False Resolution: 1, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    accumulated_off_period_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    accumulated_off_period = decode_time(accumulated_off_period_raw)
    nmea2000Message.fields.append(NMEA2000Field('accumulated_off_period', 'Accumulated OFF Period', None, 's', accumulated_off_period, accumulated_off_period_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 9:accumulated_on_period | Offset: 112, Length: 32, Signed: False Resolution: 1, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    accumulated_on_period_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    accumulated_on_period = decode_time(accumulated_on_period_raw)
    nmea2000Message.fields.append(NMEA2000Field('accumulated_on_period', 'Accumulated ON Period', None, 's', accumulated_on_period, accumulated_on_period_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 10:accumulated_error_period | Offset: 144, Length: 32, Signed: False Resolution: 1, Field Type: TIME, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 144
    accumulated_error_period_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    accumulated_error_period = decode_time(accumulated_error_period_raw)
    nmea2000Message.fields.append(NMEA2000Field('accumulated_error_period', 'Accumulated ERROR Period', None, 's', accumulated_error_period, accumulated_error_period_raw, PhysicalQuantities.TIME, FieldTypes.TIME, False))
    running_bit_offset += 32

    # 11:switch_status | Offset: 176, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 176
    switch_status_raw = decode_int(_data_raw_, running_bit_offset, 2)
    switch_status = master_dict['OFF_ON'].get(switch_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('switch_status', 'Switch Status', None, None, switch_status, switch_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 12:reserved_178 | Offset: 178, Length: 6, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 178
    reserved_178 = reserved_178_raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('reserved_178', 'Reserved', None, None, reserved_178, reserved_178_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 6

    return nmea2000Message

def encode_pgn_130837_maretronSwitchStatusTimer(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130837."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # instance | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'instance')
    if field is None:
        raise Exception("Cant encode this message, missing 'Instance'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # indicator_number | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'indicator_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Indicator Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # start_date | Offset: 32, Length: 16, Resolution: 1, Field Type: DATE
    field = next(f for f in nmea2000Message.fields if f.id == 'start_date')
    if field is None:
        raise Exception("Cant encode this message, missing 'Start Date'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 32
    # start_time | Offset: 48, Length: 32, Resolution: 0.0001, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'start_time')
    if field is None:
        raise Exception("Cant encode this message, missing 'Start Time'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFFFFFF) << 48
    
    # accumulated_off_period | Offset: 80, Length: 32, Resolution: 1, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'accumulated_off_period')
    if field is None:
        raise Exception("Cant encode this message, missing 'Accumulated OFF Period'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 80
    # accumulated_on_period | Offset: 112, Length: 32, Resolution: 1, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'accumulated_on_period')
    if field is None:
        raise Exception("Cant encode this message, missing 'Accumulated ON Period'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 112
    # accumulated_error_period | Offset: 144, Length: 32, Resolution: 1, Field Type: TIME
    field = next(f for f in nmea2000Message.fields if f.id == 'accumulated_error_period')
    if field is None:
        raise Exception("Cant encode this message, missing 'Accumulated ERROR Period'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 144
    # switch_status | Offset: 176, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'switch_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'Switch Status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_OFF_ON(field.value)
    data_raw |= (field_value & 0x3) << 176
    # reserved_178 | Offset: 178, Length: 6, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_178')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 178
    return data_raw


def is_fast_pgn_130838() -> bool:
    """Return True if PGN 130838 is a fast PGN."""
    return True
def decode_pgn_130838(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130838."""
    nmea2000Message = NMEA2000Message(130838, 'simnetFluidLevelWarning', 'Simnet: Fluid Level Warning')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    return nmea2000Message

def encode_pgn_130838(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130838."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    return data_raw


def is_fast_pgn_130839() -> bool:
    """Return True if PGN 130839 is a fast PGN."""
    return True
def decode_pgn_130839(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130839."""
    nmea2000Message = NMEA2000Message(130839, 'simnetPressureSensorConfiguration', 'Simnet: Pressure Sensor Configuration')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    return nmea2000Message

def encode_pgn_130839(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130839."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    return data_raw


def is_fast_pgn_130840() -> bool:
    """Return True if PGN 130840 is a fast PGN."""
    return True
def decode_pgn_130840(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130840."""
    nmea2000Message = NMEA2000Message(130840, 'simnetDataUserGroupConfiguration', 'Simnet: Data User Group Configuration')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    return nmea2000Message

def encode_pgn_130840(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130840."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    return data_raw


def is_fast_pgn_130842() -> bool:
    """Return True if PGN 130842 is a fast PGN."""
    return True
# Complex PGN. number of matches: 3
def decode_pgn_130842(data_raw: int) -> NMEA2000Message:
    # simnetAisClassBStaticDataMsg24PartA | Description: Simnet: AIS Class B static data (msg 24 Part A)
    if (
        (((data_raw >> 0) & 0x7FF) == 1857) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0x3F) == 0)
        ):
        return decode_pgn_130842_simnetAisClassBStaticDataMsg24PartA(data_raw)
    
    # furunoSixDegreesOfFreedomMovement | Description: Furuno: Six Degrees Of Freedom Movement
    if (
        (((data_raw >> 0) & 0x7FF) == 1855) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_130842_furunoSixDegreesOfFreedomMovement(data_raw)
    
    # simnetAisClassBStaticDataMsg24PartB | Description: Simnet: AIS Class B static data (msg 24 Part B)
    if (
        (((data_raw >> 0) & 0x7FF) == 1857) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0x3F) == 1)
        ):
        return decode_pgn_130842_simnetAisClassBStaticDataMsg24PartB(data_raw)
    
    
    raise Exception("No matching sub-PGN found")
    
def decode_pgn_130842_simnetAisClassBStaticDataMsg24PartA(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130842."""
    nmea2000Message = NMEA2000Message(130842, 'simnetAisClassBStaticDataMsg24PartA', 'Simnet: AIS Class B static data (msg 24 Part A)')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 6, Signed: False Resolution: 1, Field Type: NUMBER, Match: 0, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id = message_id_raw = decode_number(_data_raw_, running_bit_offset, 6, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "Msg 24 Part A", None, message_id, message_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 6

    # 5:repeat_indicator | Offset: 22, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 22
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 6:d | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    d = d_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('d', 'D', None, None, d, d_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:e | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    e = e_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('e', 'E', None, None, e, e_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:user_id | Offset: 40, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 40
    user_id = user_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('user_id', 'User ID', None, None, user_id, user_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 9:name | Offset: 72, Length: 160, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    name = name_raw = decode_string_fix(_data_raw_, running_bit_offset, 160)
    nmea2000Message.fields.append(NMEA2000Field('name', 'Name', None, None, name, name_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 160

    return nmea2000Message

def encode_pgn_130842_simnetAisClassBStaticDataMsg24PartA(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130842."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 6, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 16
    # repeat_indicator | Offset: 22, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 22
    # d | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'd')
    if field is None:
        raise Exception("Cant encode this message, missing 'D'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # e | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'e')
    if field is None:
        raise Exception("Cant encode this message, missing 'E'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # user_id | Offset: 40, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'user_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'User ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 40
    # name | Offset: 72, Length: 160, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Name'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 72
    return data_raw

def decode_pgn_130842_furunoSixDegreesOfFreedomMovement(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130842."""
    nmea2000Message = NMEA2000Message(130842, 'furunoSixDegreesOfFreedomMovement', 'Furuno: Six Degrees Of Freedom Movement')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1855, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Furuno", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:a | Offset: 16, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 5:b | Offset: 48, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:c | Offset: 80, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 7:d | Offset: 112, Length: 8, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 112
    d = d_raw = decode_number(_data_raw_, running_bit_offset, 8, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('d', 'D', None, None, d, d_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:e | Offset: 120, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    e = e_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('e', 'E', None, None, e, e_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 9:f | Offset: 152, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 152
    f = f_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('f', 'F', None, None, f, f_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 10:g | Offset: 184, Length: 16, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 184
    g = g_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('g', 'G', None, None, g, g_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:h | Offset: 200, Length: 16, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 200
    h = h_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('h', 'H', None, None, h, h_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 12:i | Offset: 216, Length: 16, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 216
    i = i_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('i', 'I', None, None, i, i_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_130842_furunoSixDegreesOfFreedomMovement(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130842."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # a | Offset: 16, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 16
    # b | Offset: 48, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 48
    # c | Offset: 80, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 80
    # d | Offset: 112, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'd')
    if field is None:
        raise Exception("Cant encode this message, missing 'D'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 112
    # e | Offset: 120, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'e')
    if field is None:
        raise Exception("Cant encode this message, missing 'E'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 120
    # f | Offset: 152, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'f')
    if field is None:
        raise Exception("Cant encode this message, missing 'F'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 152
    # g | Offset: 184, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'g')
    if field is None:
        raise Exception("Cant encode this message, missing 'G'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 184
    # h | Offset: 200, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'h')
    if field is None:
        raise Exception("Cant encode this message, missing 'H'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 200
    # i | Offset: 216, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'i')
    if field is None:
        raise Exception("Cant encode this message, missing 'I'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 216
    return data_raw

def decode_pgn_130842_simnetAisClassBStaticDataMsg24PartB(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130842."""
    nmea2000Message = NMEA2000Message(130842, 'simnetAisClassBStaticDataMsg24PartB', 'Simnet: AIS Class B static data (msg 24 Part B)')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 6, Signed: False Resolution: 1, Field Type: NUMBER, Match: 1, PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id = message_id_raw = decode_number(_data_raw_, running_bit_offset, 6, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', "Msg 24 Part B", None, message_id, message_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 6

    # 5:repeat_indicator | Offset: 22, Length: 2, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 22
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 2)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 2

    # 6:d | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    d = d_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('d', 'D', None, None, d, d_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:e | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    e = e_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('e', 'E', None, None, e, e_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 8:user_id | Offset: 40, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 40
    user_id = user_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('user_id', 'User ID', None, None, user_id, user_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 9:type_of_ship | Offset: 72, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    type_of_ship_raw = decode_int(_data_raw_, running_bit_offset, 8)
    type_of_ship = master_dict['SHIP_TYPE'].get(type_of_ship_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('type_of_ship', 'Type of ship', None, None, type_of_ship, type_of_ship_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 10:vendor_id | Offset: 80, Length: 56, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    vendor_id = vendor_id_raw = decode_string_fix(_data_raw_, running_bit_offset, 56)
    nmea2000Message.fields.append(NMEA2000Field('vendor_id', 'Vendor ID', None, None, vendor_id, vendor_id_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 56

    # 11:callsign | Offset: 136, Length: 56, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 136
    callsign = callsign_raw = decode_string_fix(_data_raw_, running_bit_offset, 56)
    nmea2000Message.fields.append(NMEA2000Field('callsign', 'Callsign', None, None, callsign, callsign_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 56

    # 12:length | Offset: 192, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 192
    length = length_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('length', 'Length', None, 'm', length, length_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 13:beam | Offset: 208, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 208
    beam = beam_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('beam', 'Beam', None, 'm', beam, beam_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 14:position_reference_from_starboard | Offset: 224, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 224
    position_reference_from_starboard = position_reference_from_starboard_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('position_reference_from_starboard', 'Position reference from Starboard', None, 'm', position_reference_from_starboard, position_reference_from_starboard_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 15:position_reference_from_bow | Offset: 240, Length: 16, Signed: False Resolution: 0.1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 240
    position_reference_from_bow = position_reference_from_bow_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.1)
    nmea2000Message.fields.append(NMEA2000Field('position_reference_from_bow', 'Position reference from Bow', None, 'm', position_reference_from_bow, position_reference_from_bow_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 16:mothership_user_id | Offset: 256, Length: 32, Signed: False Resolution: 1, Field Type: MMSI, Match: , PartOfPrimaryKey: True,
    running_bit_offset = 256
    mothership_user_id = mothership_user_id_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('mothership_user_id', 'Mothership User ID', None, None, mothership_user_id, mothership_user_id_raw, None, FieldTypes.MMSI, True))
    running_bit_offset += 32

    # 17:spare | Offset: 288, Length: 6, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 288
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 6)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 6

    # 18:reserved_294 | Offset: 294, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 294
    reserved_294 = reserved_294_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_294', 'Reserved', None, None, reserved_294, reserved_294_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    return nmea2000Message

def encode_pgn_130842_simnetAisClassBStaticDataMsg24PartB(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130842."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 6, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 16
    # repeat_indicator | Offset: 22, Length: 2, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0x3) << 22
    # d | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'd')
    if field is None:
        raise Exception("Cant encode this message, missing 'D'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # e | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'e')
    if field is None:
        raise Exception("Cant encode this message, missing 'E'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # user_id | Offset: 40, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'user_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'User ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 40
    # type_of_ship | Offset: 72, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'type_of_ship')
    if field is None:
        raise Exception("Cant encode this message, missing 'Type of ship'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SHIP_TYPE(field.value)
    data_raw |= (field_value & 0xFF) << 72
    # vendor_id | Offset: 80, Length: 56, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'vendor_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Vendor ID'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFF) << 80
    # callsign | Offset: 136, Length: 56, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'callsign')
    if field is None:
        raise Exception("Cant encode this message, missing 'Callsign'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFF) << 136
    # length | Offset: 192, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'length')
    if field is None:
        raise Exception("Cant encode this message, missing 'Length'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 192
    
    # beam | Offset: 208, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'beam')
    if field is None:
        raise Exception("Cant encode this message, missing 'Beam'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 208
    
    # position_reference_from_starboard | Offset: 224, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'position_reference_from_starboard')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position reference from Starboard'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 224
    
    # position_reference_from_bow | Offset: 240, Length: 16, Resolution: 0.1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'position_reference_from_bow')
    if field is None:
        raise Exception("Cant encode this message, missing 'Position reference from Bow'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.1) & 0xFFFF) << 240
    
    # mothership_user_id | Offset: 256, Length: 32, Resolution: 1, Field Type: MMSI
    field = next(f for f in nmea2000Message.fields if f.id == 'mothership_user_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Mothership User ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 256
    # spare | Offset: 288, Length: 6, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0x3F) << 288
    # reserved_294 | Offset: 294, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_294')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 294
    return data_raw


def is_fast_pgn_130843() -> bool:
    """Return True if PGN 130843 is a fast PGN."""
    return True
# Complex PGN. number of matches: 2
def decode_pgn_130843(data_raw: int) -> NMEA2000Message:
    # furunoHeelAngleRollInformation | Description: Furuno: Heel Angle, Roll Information
    if (
        (((data_raw >> 0) & 0x7FF) == 1855) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_130843_furunoHeelAngleRollInformation(data_raw)
    
    # simnetSonarStatusFrequencyAndDspVoltage | Description: Simnet: Sonar Status, Frequency and DSP Voltage
    if (
        (((data_raw >> 0) & 0x7FF) == 1857) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_130843_simnetSonarStatusFrequencyAndDspVoltage(data_raw)
    
    
    raise Exception("No matching sub-PGN found")
    
def decode_pgn_130843_furunoHeelAngleRollInformation(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130843."""
    nmea2000Message = NMEA2000Message(130843, 'furunoHeelAngleRollInformation', 'Furuno: Heel Angle, Roll Information')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1855, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Furuno", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:a | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:b | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:yaw | Offset: 32, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    yaw = yaw_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('yaw', 'Yaw', None, 'rad', yaw, yaw_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:pitch | Offset: 48, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    pitch = pitch_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('pitch', 'Pitch', None, 'rad', pitch, pitch_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:roll | Offset: 64, Length: 16, Signed: True Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    roll = roll_raw = decode_number(_data_raw_, running_bit_offset, 16, True, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('roll', 'Roll', None, 'rad', roll, roll_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_130843_furunoHeelAngleRollInformation(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130843."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # a | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # b | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # yaw | Offset: 32, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'yaw')
    if field is None:
        raise Exception("Cant encode this message, missing 'Yaw'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 32
    
    # pitch | Offset: 48, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'pitch')
    if field is None:
        raise Exception("Cant encode this message, missing 'Pitch'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 48
    
    # roll | Offset: 64, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'roll')
    if field is None:
        raise Exception("Cant encode this message, missing 'Roll'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 64
    
    return data_raw

def decode_pgn_130843_simnetSonarStatusFrequencyAndDspVoltage(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130843."""
    nmea2000Message = NMEA2000Message(130843, 'simnetSonarStatusFrequencyAndDspVoltage', 'Simnet: Sonar Status, Frequency and DSP Voltage')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    return nmea2000Message

def encode_pgn_130843_simnetSonarStatusFrequencyAndDspVoltage(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130843."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    return data_raw


def is_fast_pgn_130845() -> bool:
    """Return True if PGN 130845 is a fast PGN."""
    return True
# Complex PGN. number of matches: 2
def decode_pgn_130845(data_raw: int) -> NMEA2000Message:
    # furunoMultiSatsInViewExtended | Description: Furuno: Multi Sats In View Extended
    if (
        (((data_raw >> 0) & 0x7FF) == 1855) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_130845_furunoMultiSatsInViewExtended(data_raw)
    
    # simnetKeyValue | Description: Simnet: Key Value
    if (
        (((data_raw >> 0) & 0x7FF) == 1857) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_130845_simnetKeyValue(data_raw)
    
    
    raise Exception("No matching sub-PGN found")
    
def decode_pgn_130845_furunoMultiSatsInViewExtended(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130845."""
    nmea2000Message = NMEA2000Message(130845, 'furunoMultiSatsInViewExtended', 'Furuno: Multi Sats In View Extended')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1855, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Furuno", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    return nmea2000Message

def encode_pgn_130845_furunoMultiSatsInViewExtended(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130845."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    return data_raw

def decode_pgn_130845_simnetKeyValue(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130845."""
    nmea2000Message = NMEA2000Message(130845, 'simnetKeyValue', 'Simnet: Key Value')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:address | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    address = address_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('address', 'Address', "NMEA 2000 address of commanded device", None, address, address_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:repeat_indicator | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    repeat_indicator_raw = decode_int(_data_raw_, running_bit_offset, 8)
    repeat_indicator = master_dict['REPEAT_INDICATOR'].get(repeat_indicator_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('repeat_indicator', 'Repeat Indicator', None, None, repeat_indicator, repeat_indicator_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 6:display_group | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    display_group_raw = decode_int(_data_raw_, running_bit_offset, 8)
    display_group = master_dict['SIMNET_DISPLAY_GROUP'].get(display_group_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('display_group', 'Display Group', None, None, display_group, display_group_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:reserved_40 | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    reserved_40 = reserved_40_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_40', 'Reserved', None, None, reserved_40, reserved_40_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 8:key | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: FIELDTYPE_LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    key_raw = decode_int(_data_raw_, running_bit_offset, 16)
    kv_metadata = lookup_field_type_SIMNET_KEY_VALUE(key_raw)
    key = kv_name = kv_metadata.name
    nmea2000Message.fields.append(NMEA2000Field('key', 'Key', None, None, key, key_raw, None, FieldTypes.FIELDTYPE_LOOKUP, False))
    running_bit_offset += 16

    # 9:spare | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 8

    # 10:minlength | Offset: 72, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    minlength = minlength_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('minlength', 'MinLength', "Length of data field", None, minlength, minlength_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 11:value | Offset: , Length: , Signed: False Resolution: , Field Type: KEY_VALUE, Match: , PartOfPrimaryKey: ,
    if kv_metadata.field_type == 'LOOKUP':
        value_raw = decode_int(_data_raw_, running_bit_offset, kv_metadata.bits)
        value = master_dict[kv_metadata.lookup_enumeration].get(value_raw, None)
    if kv_metadata.field_type == 'NUMBER':
        value = value_raw = decode_number(_data_raw_, running_bit_offset, kv_metadata.bits, False, kv_metadata.resolution)
    if kv_metadata.field_type == 'TIME':
        value_raw = decode_number(_data_raw_, running_bit_offset, kv_metadata.bits, False,kv_metadata.resolution)
        value = decode_time(value_raw)
    nmea2000Message.fields.append(NMEA2000Field('value', kv_metadata.name, '', kv_metadata.unit, value, value_raw, None, kv_metadata.field_type, False))
    running_bit_offset += kv_metadata.bits

    return nmea2000Message

def encode_pgn_130845_simnetKeyValue(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130845."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # address | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'address')
    if field is None:
        raise Exception("Cant encode this message, missing 'Address'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # repeat_indicator | Offset: 24, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'repeat_indicator')
    if field is None:
        raise Exception("Cant encode this message, missing 'Repeat Indicator'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_REPEAT_INDICATOR(field.value)
    data_raw |= (field_value & 0xFF) << 24
    # display_group | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'display_group')
    if field is None:
        raise Exception("Cant encode this message, missing 'Display Group'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_DISPLAY_GROUP(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # reserved_40 | Offset: 40, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_40')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # key | Offset: 48, Length: 16, Resolution: 1, Field Type: FIELDTYPE_LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'key')
    if field is None:
        raise Exception("Cant encode this message, missing 'Key'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    # spare | Offset: 64, Length: 8, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 64
    # minlength | Offset: 72, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'minlength')
    if field is None:
        raise Exception("Cant encode this message, missing 'MinLength'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 72
    raise Exception ("PGN 130845 not supporting encoding for now as Value is missing BitLength or BitOffset")
    return data_raw


def is_fast_pgn_130846() -> bool:
    """Return True if PGN 130846 is a fast PGN."""
    return True
# Complex PGN. number of matches: 2
def decode_pgn_130846(data_raw: int) -> NMEA2000Message:
    # simnetParameterSet | Description: Simnet: Parameter Set
    if (
        (((data_raw >> 0) & 0x7FF) == 1857) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_130846_simnetParameterSet(data_raw)
    
    # furunoMotionSensorStatusExtended | Description: Furuno: Motion Sensor Status Extended
    if (
        (((data_raw >> 0) & 0x7FF) == 1855) and
        (((data_raw >> 13) & 0x7) == 4)
        ):
        return decode_pgn_130846_furunoMotionSensorStatusExtended(data_raw)
    
    
    raise Exception("No matching sub-PGN found")
    
def decode_pgn_130846_simnetParameterSet(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130846."""
    nmea2000Message = NMEA2000Message(130846, 'simnetParameterSet', 'Simnet: Parameter Set')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:address | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    address = address_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('address', 'Address', "NMEA 2000 address of commanded device", None, address, address_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:b | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', "00, 01 or FF observed", None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:display_group | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    display_group_raw = decode_int(_data_raw_, running_bit_offset, 8)
    display_group = master_dict['SIMNET_DISPLAY_GROUP'].get(display_group_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('display_group', 'Display Group', None, None, display_group, display_group_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:d | Offset: 40, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    d = d_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('d', 'D', "Various values observed", None, d, d_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:key | Offset: 56, Length: 16, Signed: False Resolution: 1, Field Type: FIELDTYPE_LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    key_raw = decode_int(_data_raw_, running_bit_offset, 16)
    kv_metadata = lookup_field_type_SIMNET_KEY_VALUE(key_raw)
    key = kv_name = kv_metadata.name
    nmea2000Message.fields.append(NMEA2000Field('key', 'Key', None, None, key, key_raw, None, FieldTypes.FIELDTYPE_LOOKUP, False))
    running_bit_offset += 16

    # 9:spare | Offset: 72, Length: 8, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 8

    # 10:length | Offset: 80, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    length = length_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('length', 'Length', "Length of data field", None, length, length_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 11:value | Offset: , Length: , Signed: False Resolution: , Field Type: KEY_VALUE, Match: , PartOfPrimaryKey: ,
    if kv_metadata.field_type == 'LOOKUP':
        value_raw = decode_int(_data_raw_, running_bit_offset, kv_metadata.bits)
        value = master_dict[kv_metadata.lookup_enumeration].get(value_raw, None)
    if kv_metadata.field_type == 'NUMBER':
        value = value_raw = decode_number(_data_raw_, running_bit_offset, kv_metadata.bits, False, kv_metadata.resolution)
    if kv_metadata.field_type == 'TIME':
        value_raw = decode_number(_data_raw_, running_bit_offset, kv_metadata.bits, False,kv_metadata.resolution)
        value = decode_time(value_raw)
    nmea2000Message.fields.append(NMEA2000Field('value', kv_metadata.name, '', kv_metadata.unit, value, value_raw, None, kv_metadata.field_type, False))
    running_bit_offset += kv_metadata.bits

    return nmea2000Message

def encode_pgn_130846_simnetParameterSet(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130846."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # address | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'address')
    if field is None:
        raise Exception("Cant encode this message, missing 'Address'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # b | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # display_group | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'display_group')
    if field is None:
        raise Exception("Cant encode this message, missing 'Display Group'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_DISPLAY_GROUP(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # d | Offset: 40, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'd')
    if field is None:
        raise Exception("Cant encode this message, missing 'D'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 40
    # key | Offset: 56, Length: 16, Resolution: 1, Field Type: FIELDTYPE_LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'key')
    if field is None:
        raise Exception("Cant encode this message, missing 'Key'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 56
    # spare | Offset: 72, Length: 8, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 72
    # length | Offset: 80, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'length')
    if field is None:
        raise Exception("Cant encode this message, missing 'Length'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 80
    raise Exception ("PGN 130846 not supporting encoding for now as Value is missing BitLength or BitOffset")
    return data_raw

def decode_pgn_130846_furunoMotionSensorStatusExtended(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130846."""
    nmea2000Message = NMEA2000Message(130846, 'furunoMotionSensorStatusExtended', 'Furuno: Motion Sensor Status Extended')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1855, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Furuno", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    return nmea2000Message

def encode_pgn_130846_furunoMotionSensorStatusExtended(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130846."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    return data_raw


def is_fast_pgn_130847() -> bool:
    """Return True if PGN 130847 is a fast PGN."""
    return True
def decode_pgn_130847(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130847."""
    nmea2000Message = NMEA2000Message(130847, 'seatalkNodeStatistics', 'SeaTalk: Node Statistics')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1851, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Raymarine", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:product_code | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    product_code = product_code_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('product_code', 'Product Code', None, None, product_code, product_code_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:year | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    year = year_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('year', 'Year', None, None, year, year_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:month | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    month = month_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('month', 'Month', None, None, month, month_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:device_number | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    device_number = device_number_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('device_number', 'Device Number', None, None, device_number, device_number_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:node_voltage | Offset: 64, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    node_voltage = node_voltage_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('node_voltage', 'Node Voltage', None, 'V', node_voltage, node_voltage_raw, PhysicalQuantities.POTENTIAL_DIFFERENCE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_130847(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130847."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # product_code | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'product_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Product Code'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # year | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'year')
    if field is None:
        raise Exception("Cant encode this message, missing 'Year'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # month | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'month')
    if field is None:
        raise Exception("Cant encode this message, missing 'Month'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # device_number | Offset: 48, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'device_number')
    if field is None:
        raise Exception("Cant encode this message, missing 'Device Number'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 48
    # node_voltage | Offset: 64, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'node_voltage')
    if field is None:
        raise Exception("Cant encode this message, missing 'Node Voltage'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 64
    
    return data_raw


def is_fast_pgn_130848() -> bool:
    """Return True if PGN 130848 is a fast PGN."""
    return True
def decode_pgn_130848(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130848."""
    nmea2000Message = NMEA2000Message(130848, 'seatalkWaypointInformation', 'SeaTalk: Waypoint Information')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1851, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Raymarine", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:sid | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    sid = sid_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('sid', 'SID', None, None, sid, sid_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:waypoint_name | Offset: 24, Length: 128, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    waypoint_name = waypoint_name_raw = decode_string_fix(_data_raw_, running_bit_offset, 128)
    nmea2000Message.fields.append(NMEA2000Field('waypoint_name', 'Waypoint Name', None, None, waypoint_name, waypoint_name_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 128

    # 6:waypoint_sequence | Offset: 152, Length: 32, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 152
    waypoint_sequence = waypoint_sequence_raw = decode_string_fix(_data_raw_, running_bit_offset, 32)
    nmea2000Message.fields.append(NMEA2000Field('waypoint_sequence', 'Waypoint Sequence', None, None, waypoint_sequence, waypoint_sequence_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 32

    # 7:bearing_to_waypoint__true | Offset: 184, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 184
    bearing_to_waypoint__true = bearing_to_waypoint__true_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('bearing_to_waypoint__true', 'Bearing to Waypoint, True', None, 'rad', bearing_to_waypoint__true, bearing_to_waypoint__true_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 8:bearing_to_waypoint__magnetic | Offset: 200, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 200
    bearing_to_waypoint__magnetic = bearing_to_waypoint__magnetic_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('bearing_to_waypoint__magnetic', 'Bearing to Waypoint, Magnetic', None, 'rad', bearing_to_waypoint__magnetic, bearing_to_waypoint__magnetic_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 9:distance_to_waypoint | Offset: 216, Length: 32, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 216
    distance_to_waypoint = distance_to_waypoint_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('distance_to_waypoint', 'Distance to Waypoint', None, 'm', distance_to_waypoint, distance_to_waypoint_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_130848(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130848."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # sid | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'sid')
    if field is None:
        raise Exception("Cant encode this message, missing 'SID'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # waypoint_name | Offset: 24, Length: 128, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'waypoint_name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Waypoint Name'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 24
    # waypoint_sequence | Offset: 152, Length: 32, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'waypoint_sequence')
    if field is None:
        raise Exception("Cant encode this message, missing 'Waypoint Sequence'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFF) << 152
    # bearing_to_waypoint__true | Offset: 184, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'bearing_to_waypoint__true')
    if field is None:
        raise Exception("Cant encode this message, missing 'Bearing to Waypoint, True'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 184
    
    # bearing_to_waypoint__magnetic | Offset: 200, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'bearing_to_waypoint__magnetic')
    if field is None:
        raise Exception("Cant encode this message, missing 'Bearing to Waypoint, Magnetic'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 200
    
    # distance_to_waypoint | Offset: 216, Length: 32, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'distance_to_waypoint')
    if field is None:
        raise Exception("Cant encode this message, missing 'Distance to Waypoint'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFFFFFF) << 216
    
    return data_raw


def is_fast_pgn_130850() -> bool:
    """Return True if PGN 130850 is a fast PGN."""
    return True
# Complex PGN. number of matches: 3
def decode_pgn_130850(data_raw: int) -> NMEA2000Message:
    # simnetApCommand | Description: Simnet: AP Command
    if (
        (((data_raw >> 0) & 0x7FF) == 1857) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 32) & 0xFF) == 255)
        ):
        return decode_pgn_130850_simnetApCommand(data_raw)
    
    # simnetEventCommandApCommand | Description: Simnet: Event Command: AP command
    if (
        (((data_raw >> 0) & 0x7FF) == 1857) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 16) & 0xFF) == 2)
        ):
        return decode_pgn_130850_simnetEventCommandApCommand(data_raw)
    
    # simnetAlarm | Description: Simnet: Alarm
    if (
        (((data_raw >> 0) & 0x7FF) == 1857) and
        (((data_raw >> 13) & 0x7) == 4) and
        (((data_raw >> 32) & 0xFF) == 1)
        ):
        return decode_pgn_130850_simnetAlarm(data_raw)
    
    
    raise Exception("No matching sub-PGN found")
    
def decode_pgn_130850_simnetApCommand(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130850."""
    nmea2000Message = NMEA2000Message(130850, 'simnetApCommand', 'Simnet: AP Command')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:address | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    address = address_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('address', 'Address', "NMEA 2000 address of commanded device", None, address, address_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:reserved_24 | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    reserved_24 = reserved_24_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_24', 'Reserved', None, None, reserved_24, reserved_24_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 6:proprietary_id | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 255, PartOfPrimaryKey: ,
    running_bit_offset = 32
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SIMNET_EVENT_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Autopilot", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:ap_status | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    ap_status_raw = decode_int(_data_raw_, running_bit_offset, 8)
    ap_status = master_dict['SIMNET_AP_STATUS'].get(ap_status_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ap_status', 'AP status', None, None, ap_status, ap_status_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 8:ap_command | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    ap_command_raw = decode_int(_data_raw_, running_bit_offset, 8)
    ap_command = master_dict['SIMNET_AP_EVENTS'].get(ap_command_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('ap_command', 'AP Command', None, None, ap_command, ap_command_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 9:spare | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: SPARE, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    spare = spare_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('spare', 'Spare', None, None, spare, spare_raw, None, FieldTypes.SPARE, False))
    running_bit_offset += 8

    # 10:direction | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    direction_raw = decode_int(_data_raw_, running_bit_offset, 8)
    direction = master_dict['SIMNET_DIRECTION'].get(direction_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('direction', 'Direction', None, None, direction, direction_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 11:angle | Offset: 72, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    angle = angle_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('angle', 'Angle', "Commanded angle change", 'rad', angle, angle_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_130850_simnetApCommand(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130850."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # address | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'address')
    if field is None:
        raise Exception("Cant encode this message, missing 'Address'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # reserved_24 | Offset: 24, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_24')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # proprietary_id | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_EVENT_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # ap_status | Offset: 40, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ap_status')
    if field is None:
        raise Exception("Cant encode this message, missing 'AP status'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_AP_STATUS(field.value)
    data_raw |= (field_value & 0xFF) << 40
    # ap_command | Offset: 48, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'ap_command')
    if field is None:
        raise Exception("Cant encode this message, missing 'AP Command'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_AP_EVENTS(field.value)
    data_raw |= (field_value & 0xFF) << 48
    # spare | Offset: 56, Length: 8, Resolution: 1, Field Type: SPARE
    field = next(f for f in nmea2000Message.fields if f.id == 'spare')
    if field is None:
        raise Exception("Cant encode this message, missing 'Spare'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    # direction | Offset: 64, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'direction')
    if field is None:
        raise Exception("Cant encode this message, missing 'Direction'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_DIRECTION(field.value)
    data_raw |= (field_value & 0xFF) << 64
    # angle | Offset: 72, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'angle')
    if field is None:
        raise Exception("Cant encode this message, missing 'Angle'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 72
    
    return data_raw

def decode_pgn_130850_simnetEventCommandApCommand(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130850."""
    nmea2000Message = NMEA2000Message(130850, 'simnetEventCommandApCommand', 'Simnet: Event Command: AP command')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 2, PartOfPrimaryKey: ,
    running_bit_offset = 16
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SIMNET_EVENT_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "AP command", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:unused_a | Offset: 24, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    unused_a = unused_a_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unused_a', 'Unused A', None, None, unused_a, unused_a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:controlling_device | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    controlling_device = controlling_device_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('controlling_device', 'Controlling Device', None, None, controlling_device, controlling_device_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:event | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    event_raw = decode_int(_data_raw_, running_bit_offset, 8)
    event = master_dict['SIMNET_AP_EVENTS'].get(event_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('event', 'Event', None, None, event, event_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 8:unused_b | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    unused_b = unused_b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unused_b', 'Unused B', None, None, unused_b, unused_b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:direction | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    direction_raw = decode_int(_data_raw_, running_bit_offset, 8)
    direction = master_dict['SIMNET_DIRECTION'].get(direction_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('direction', 'Direction', None, None, direction, direction_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 10:angle | Offset: 72, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    angle = angle_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('angle', 'Angle', None, 'rad', angle, angle_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:unused_c | Offset: 88, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    unused_c = unused_c_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unused_c', 'Unused C', None, None, unused_c, unused_c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130850_simnetEventCommandApCommand(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130850."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_EVENT_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # unused_a | Offset: 24, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unused_a')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unused A'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 24
    # controlling_device | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'controlling_device')
    if field is None:
        raise Exception("Cant encode this message, missing 'Controlling Device'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # event | Offset: 48, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'event')
    if field is None:
        raise Exception("Cant encode this message, missing 'Event'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_AP_EVENTS(field.value)
    data_raw |= (field_value & 0xFF) << 48
    # unused_b | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unused_b')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unused B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    # direction | Offset: 64, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'direction')
    if field is None:
        raise Exception("Cant encode this message, missing 'Direction'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_DIRECTION(field.value)
    data_raw |= (field_value & 0xFF) << 64
    # angle | Offset: 72, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'angle')
    if field is None:
        raise Exception("Cant encode this message, missing 'Angle'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 72
    
    # unused_c | Offset: 88, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unused_c')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unused C'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 88
    return data_raw

def decode_pgn_130850_simnetAlarm(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130850."""
    nmea2000Message = NMEA2000Message(130850, 'simnetAlarm', 'Simnet: Alarm')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:address | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    address = address_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('address', 'Address', "NMEA 2000 address of commanded device", None, address, address_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:reserved_24 | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    reserved_24 = reserved_24_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_24', 'Reserved', None, None, reserved_24, reserved_24_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 6:proprietary_id | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1, PartOfPrimaryKey: ,
    running_bit_offset = 32
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SIMNET_EVENT_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "Alarm", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 7:reserved_40 | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    reserved_40 = reserved_40_raw = decode_int(_data_raw_, running_bit_offset, 8)
    nmea2000Message.fields.append(NMEA2000Field('reserved_40', 'Reserved', None, None, reserved_40, reserved_40_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 8

    # 8:alarm | Offset: 48, Length: 16, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    alarm_raw = decode_int(_data_raw_, running_bit_offset, 16)
    alarm = master_dict['SIMNET_ALARM'].get(alarm_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('alarm', 'Alarm', None, None, alarm, alarm_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 16

    # 9:message_id | Offset: 64, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    message_id = message_id_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 10:f | Offset: 80, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 80
    f = f_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('f', 'F', None, None, f, f_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 11:g | Offset: 88, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    g = g_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('g', 'G', None, None, g, g_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130850_simnetAlarm(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130850."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # address | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'address')
    if field is None:
        raise Exception("Cant encode this message, missing 'Address'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # reserved_24 | Offset: 24, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_24')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # proprietary_id | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_EVENT_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # reserved_40 | Offset: 40, Length: 8, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_40')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # alarm | Offset: 48, Length: 16, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'alarm')
    if field is None:
        raise Exception("Cant encode this message, missing 'Alarm'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_ALARM(field.value)
    data_raw |= (field_value & 0xFFFF) << 48
    # message_id | Offset: 64, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 64
    # f | Offset: 80, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'f')
    if field is None:
        raise Exception("Cant encode this message, missing 'F'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 80
    # g | Offset: 88, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'g')
    if field is None:
        raise Exception("Cant encode this message, missing 'G'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 88
    return data_raw


def is_fast_pgn_130851() -> bool:
    """Return True if PGN 130851 is a fast PGN."""
    return True
def decode_pgn_130851(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130851."""
    nmea2000Message = NMEA2000Message(130851, 'simnetEventReplyApCommand', 'Simnet: Event Reply: AP command')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:proprietary_id | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 2, PartOfPrimaryKey: ,
    running_bit_offset = 16
    proprietary_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    proprietary_id = master_dict['SIMNET_EVENT_COMMAND'].get(proprietary_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('proprietary_id', 'Proprietary ID', "AP command", None, proprietary_id, proprietary_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 5:b | Offset: 24, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:address | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    address = address_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('address', 'Address', "NMEA 2000 address of controlling device", None, address, address_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:event | Offset: 48, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    event_raw = decode_int(_data_raw_, running_bit_offset, 8)
    event = master_dict['SIMNET_AP_EVENTS'].get(event_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('event', 'Event', None, None, event, event_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 8:c | Offset: 56, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:direction | Offset: 64, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 64
    direction_raw = decode_int(_data_raw_, running_bit_offset, 8)
    direction = master_dict['SIMNET_DIRECTION'].get(direction_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('direction', 'Direction', None, None, direction, direction_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 10:angle | Offset: 72, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 72
    angle = angle_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('angle', 'Angle', None, 'rad', angle, angle_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:g | Offset: 88, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    g = g_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('g', 'G', None, None, g, g_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130851(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130851."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # proprietary_id | Offset: 16, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'proprietary_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Proprietary ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_EVENT_COMMAND(field.value)
    data_raw |= (field_value & 0xFF) << 16
    # b | Offset: 24, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 24
    # address | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'address')
    if field is None:
        raise Exception("Cant encode this message, missing 'Address'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # event | Offset: 48, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'event')
    if field is None:
        raise Exception("Cant encode this message, missing 'Event'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_AP_EVENTS(field.value)
    data_raw |= (field_value & 0xFF) << 48
    # c | Offset: 56, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 56
    # direction | Offset: 64, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'direction')
    if field is None:
        raise Exception("Cant encode this message, missing 'Direction'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_SIMNET_DIRECTION(field.value)
    data_raw |= (field_value & 0xFF) << 64
    # angle | Offset: 72, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'angle')
    if field is None:
        raise Exception("Cant encode this message, missing 'Angle'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 72
    
    # g | Offset: 88, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'g')
    if field is None:
        raise Exception("Cant encode this message, missing 'G'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 88
    return data_raw


def is_fast_pgn_130856() -> bool:
    """Return True if PGN 130856 is a fast PGN."""
    return True
def decode_pgn_130856(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130856."""
    nmea2000Message = NMEA2000Message(130856, 'simnetAlarmMessage', 'Simnet: Alarm Message')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:message_id | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    message_id = message_id_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('message_id', 'Message ID', None, None, message_id, message_id_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:b | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 6:c | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:text | Offset: 48, Length: 1784, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 48
    text = text_raw = decode_string_fix(_data_raw_, running_bit_offset, 1784)
    nmea2000Message.fields.append(NMEA2000Field('text', 'Text', None, None, text, text_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 1784

    return nmea2000Message

def encode_pgn_130856(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130856."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # message_id | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'message_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Message ID'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # b | Offset: 32, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 32
    # c | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    # text | Offset: 48, Length: 1784, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'text')
    if field is None:
        raise Exception("Cant encode this message, missing 'Text'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 48
    return data_raw


def is_fast_pgn_130860() -> bool:
    """Return True if PGN 130860 is a fast PGN."""
    return True
def decode_pgn_130860(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130860."""
    nmea2000Message = NMEA2000Message(130860, 'simnetApUnknown4', 'Simnet: AP Unknown 4')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1857, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Simrad", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:a | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    a = a_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('a', 'A', None, None, a, a_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:b | Offset: 24, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    b = b_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('b', 'B', None, None, b, b_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 6:c | Offset: 56, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 7:d | Offset: 88, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 88
    d = d_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('d', 'D', None, None, d, d_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 8:e | Offset: 120, Length: 32, Signed: True Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 120
    e = e_raw = decode_number(_data_raw_, running_bit_offset, 32, True, 1)
    nmea2000Message.fields.append(NMEA2000Field('e', 'E', None, None, e, e_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 9:f | Offset: 152, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 152
    f = f_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('f', 'F', None, None, f, f_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    return nmea2000Message

def encode_pgn_130860(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130860."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # a | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'a')
    if field is None:
        raise Exception("Cant encode this message, missing 'A'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # b | Offset: 24, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'b')
    if field is None:
        raise Exception("Cant encode this message, missing 'B'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 24
    # c | Offset: 56, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 56
    # d | Offset: 88, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'd')
    if field is None:
        raise Exception("Cant encode this message, missing 'D'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 88
    # e | Offset: 120, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'e')
    if field is None:
        raise Exception("Cant encode this message, missing 'E'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 120
    # f | Offset: 152, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'f')
    if field is None:
        raise Exception("Cant encode this message, missing 'F'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 152
    return data_raw


def is_fast_pgn_130880() -> bool:
    """Return True if PGN 130880 is a fast PGN."""
    return True
def decode_pgn_130880(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130880."""
    nmea2000Message = NMEA2000Message(130880, 'airmarAdditionalWeatherData', 'Airmar: Additional Weather Data')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:c | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:apparent_windchill_temperature | Offset: 24, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    apparent_windchill_temperature = apparent_windchill_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('apparent_windchill_temperature', 'Apparent Windchill Temperature', None, 'K', apparent_windchill_temperature, apparent_windchill_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:true_windchill_temperature | Offset: 40, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    true_windchill_temperature = true_windchill_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('true_windchill_temperature', 'True Windchill Temperature', None, 'K', true_windchill_temperature, true_windchill_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:dewpoint | Offset: 56, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    dewpoint = dewpoint_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('dewpoint', 'Dewpoint', None, 'K', dewpoint, dewpoint_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_130880(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130880."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # c | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # apparent_windchill_temperature | Offset: 24, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'apparent_windchill_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Apparent Windchill Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 24
    
    # true_windchill_temperature | Offset: 40, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'true_windchill_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'True Windchill Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 40
    
    # dewpoint | Offset: 56, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'dewpoint')
    if field is None:
        raise Exception("Cant encode this message, missing 'Dewpoint'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 56
    
    return data_raw


def is_fast_pgn_130881() -> bool:
    """Return True if PGN 130881 is a fast PGN."""
    return True
def decode_pgn_130881(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130881."""
    nmea2000Message = NMEA2000Message(130881, 'airmarHeaterControl', 'Airmar: Heater Control')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:c | Offset: 16, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    c = c_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('c', 'C', None, None, c, c_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 5:plate_temperature | Offset: 24, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    plate_temperature = plate_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('plate_temperature', 'Plate Temperature', None, 'K', plate_temperature, plate_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 6:air_temperature | Offset: 40, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    air_temperature = air_temperature_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('air_temperature', 'Air Temperature', None, 'K', air_temperature, air_temperature_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:dewpoint | Offset: 56, Length: 16, Signed: False Resolution: 0.01, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 56
    dewpoint = dewpoint_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.01)
    nmea2000Message.fields.append(NMEA2000Field('dewpoint', 'Dewpoint', None, 'K', dewpoint, dewpoint_raw, PhysicalQuantities.TEMPERATURE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_130881(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130881."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # c | Offset: 16, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'c')
    if field is None:
        raise Exception("Cant encode this message, missing 'C'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 16
    # plate_temperature | Offset: 24, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'plate_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Plate Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 24
    
    # air_temperature | Offset: 40, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'air_temperature')
    if field is None:
        raise Exception("Cant encode this message, missing 'Air Temperature'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 40
    
    # dewpoint | Offset: 56, Length: 16, Resolution: 0.01, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'dewpoint')
    if field is None:
        raise Exception("Cant encode this message, missing 'Dewpoint'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.01) & 0xFFFF) << 56
    
    return data_raw


def is_fast_pgn_130918() -> bool:
    """Return True if PGN 130918 is a fast PGN."""
    return True
def decode_pgn_130918(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130918."""
    nmea2000Message = NMEA2000Message(130918, 'seatalkRouteInformation', 'SeaTalk: Route Information')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 1851, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Raymarine", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:current_waypoint_sequence | Offset: 16, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    current_waypoint_sequence = current_waypoint_sequence_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('current_waypoint_sequence', 'Current Waypoint Sequence', None, None, current_waypoint_sequence, current_waypoint_sequence_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 5:current_waypoint_name | Offset: 32, Length: 128, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    current_waypoint_name = current_waypoint_name_raw = decode_string_fix(_data_raw_, running_bit_offset, 128)
    nmea2000Message.fields.append(NMEA2000Field('current_waypoint_name', 'Current Waypoint Name', None, None, current_waypoint_name, current_waypoint_name_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 128

    # 6:next_waypoint_sequence | Offset: 160, Length: 16, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 160
    next_waypoint_sequence = next_waypoint_sequence_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('next_waypoint_sequence', 'Next Waypoint Sequence', None, None, next_waypoint_sequence, next_waypoint_sequence_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 7:next_waypoint_name | Offset: 176, Length: 128, Signed: False Resolution: , Field Type: STRING_FIX, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 176
    next_waypoint_name = next_waypoint_name_raw = decode_string_fix(_data_raw_, running_bit_offset, 128)
    nmea2000Message.fields.append(NMEA2000Field('next_waypoint_name', 'Next Waypoint Name', None, None, next_waypoint_name, next_waypoint_name_raw, None, FieldTypes.STRING_FIX, False))
    running_bit_offset += 128

    # 8:unknown | Offset: 304, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 304
    unknown = unknown_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('unknown', 'Unknown', None, None, unknown, unknown_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 9:distance__position_to_next_waypoint | Offset: 312, Length: 32, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 312
    distance__position_to_next_waypoint = distance__position_to_next_waypoint_raw = decode_number(_data_raw_, running_bit_offset, 32, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('distance__position_to_next_waypoint', 'Distance, Position to Next Waypoint', None, 'm', distance__position_to_next_waypoint, distance__position_to_next_waypoint_raw, PhysicalQuantities.LENGTH, FieldTypes.NUMBER, False))
    running_bit_offset += 32

    # 10:bearing__position_to_next_waypoint__true | Offset: 344, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 344
    bearing__position_to_next_waypoint__true = bearing__position_to_next_waypoint__true_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('bearing__position_to_next_waypoint__true', 'Bearing, Position to Next Waypoint, True', None, 'rad', bearing__position_to_next_waypoint__true, bearing__position_to_next_waypoint__true_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    # 11:bearing__current_waypoint_to_next_waypoint__true | Offset: 360, Length: 16, Signed: False Resolution: 0.0001, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 360
    bearing__current_waypoint_to_next_waypoint__true = bearing__current_waypoint_to_next_waypoint__true_raw = decode_number(_data_raw_, running_bit_offset, 16, False, 0.0001)
    nmea2000Message.fields.append(NMEA2000Field('bearing__current_waypoint_to_next_waypoint__true', 'Bearing, Current Waypoint to Next Waypoint, True', None, 'rad', bearing__current_waypoint_to_next_waypoint__true, bearing__current_waypoint_to_next_waypoint__true_raw, PhysicalQuantities.ANGLE, FieldTypes.NUMBER, False))
    running_bit_offset += 16

    return nmea2000Message

def encode_pgn_130918(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130918."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # current_waypoint_sequence | Offset: 16, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'current_waypoint_sequence')
    if field is None:
        raise Exception("Cant encode this message, missing 'Current Waypoint Sequence'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 16
    # current_waypoint_name | Offset: 32, Length: 128, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'current_waypoint_name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Current Waypoint Name'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 32
    # next_waypoint_sequence | Offset: 160, Length: 16, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'next_waypoint_sequence')
    if field is None:
        raise Exception("Cant encode this message, missing 'Next Waypoint Sequence'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFF) << 160
    # next_waypoint_name | Offset: 176, Length: 128, Resolution: , Field Type: STRING_FIX
    field = next(f for f in nmea2000Message.fields if f.id == 'next_waypoint_name')
    if field is None:
        raise Exception("Cant encode this message, missing 'Next Waypoint Name'")
    # Skipping STRING field types
    data_raw |= (field_value & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 176
    # unknown | Offset: 304, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'unknown')
    if field is None:
        raise Exception("Cant encode this message, missing 'Unknown'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 304
    # distance__position_to_next_waypoint | Offset: 312, Length: 32, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'distance__position_to_next_waypoint')
    if field is None:
        raise Exception("Cant encode this message, missing 'Distance, Position to Next Waypoint'")
    field_value = field.value
    data_raw |= (field_value & 0xFFFFFFFF) << 312
    # bearing__position_to_next_waypoint__true | Offset: 344, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'bearing__position_to_next_waypoint__true')
    if field is None:
        raise Exception("Cant encode this message, missing 'Bearing, Position to Next Waypoint, True'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 344
    
    # bearing__current_waypoint_to_next_waypoint__true | Offset: 360, Length: 16, Resolution: 0.0001, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'bearing__current_waypoint_to_next_waypoint__true')
    if field is None:
        raise Exception("Cant encode this message, missing 'Bearing, Current Waypoint to Next Waypoint, True'")
    field_value = field.value        
    data_raw |= (int((field_value if field_value is not None else 0) / 0.0001) & 0xFFFF) << 360
    
    return data_raw


def is_fast_pgn_130944() -> bool:
    """Return True if PGN 130944 is a fast PGN."""
    return True
def decode_pgn_130944(_data_raw_: int) -> NMEA2000Message:
    """Decode PGN 130944."""
    nmea2000Message = NMEA2000Message(130944, 'airmarPost', 'Airmar: POST')
    running_bit_offset = 0
    # 1:manufacturer_code | Offset: 0, Length: 11, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 135, PartOfPrimaryKey: True,
    running_bit_offset = 0
    manufacturer_code_raw = decode_int(_data_raw_, running_bit_offset, 11)
    manufacturer_code = master_dict['MANUFACTURER_CODE'].get(manufacturer_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('manufacturer_code', 'Manufacturer Code', "Airmar", None, manufacturer_code, manufacturer_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 11

    # 2:reserved_11 | Offset: 11, Length: 2, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 11
    reserved_11 = reserved_11_raw = decode_int(_data_raw_, running_bit_offset, 2)
    nmea2000Message.fields.append(NMEA2000Field('reserved_11', 'Reserved', None, None, reserved_11, reserved_11_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 2

    # 3:industry_code | Offset: 13, Length: 3, Signed: False Resolution: 1, Field Type: LOOKUP, Match: 4, PartOfPrimaryKey: True,
    running_bit_offset = 13
    industry_code_raw = decode_int(_data_raw_, running_bit_offset, 3)
    industry_code = master_dict['INDUSTRY_CODE'].get(industry_code_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('industry_code', 'Industry Code', "Marine Industry", None, industry_code, industry_code_raw, None, FieldTypes.LOOKUP, True))
    running_bit_offset += 3

    # 4:control | Offset: 16, Length: 1, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 16
    control_raw = decode_int(_data_raw_, running_bit_offset, 1)
    control = master_dict['AIRMAR_POST_CONTROL'].get(control_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('control', 'Control', None, None, control, control_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 1

    # 5:reserved_17 | Offset: 17, Length: 7, Signed: False Resolution: 1, Field Type: RESERVED, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 17
    reserved_17 = reserved_17_raw = decode_int(_data_raw_, running_bit_offset, 7)
    nmea2000Message.fields.append(NMEA2000Field('reserved_17', 'Reserved', None, None, reserved_17, reserved_17_raw, None, FieldTypes.RESERVED, False))
    running_bit_offset += 7

    # 6:number_of_id_test_result_pairs_to_follow | Offset: 24, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 24
    number_of_id_test_result_pairs_to_follow = number_of_id_test_result_pairs_to_follow_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('number_of_id_test_result_pairs_to_follow', 'Number of ID/test result pairs to follow', None, None, number_of_id_test_result_pairs_to_follow, number_of_id_test_result_pairs_to_follow_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    # 7:test_id | Offset: 32, Length: 8, Signed: False Resolution: 1, Field Type: LOOKUP, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 32
    test_id_raw = decode_int(_data_raw_, running_bit_offset, 8)
    test_id = master_dict['AIRMAR_POST_ID'].get(test_id_raw, None)
    nmea2000Message.fields.append(NMEA2000Field('test_id', 'Test ID', "See Airmar docs for table of IDs and failure codes; these lookup values are for DST200", None, test_id, test_id_raw, None, FieldTypes.LOOKUP, False))
    running_bit_offset += 8

    # 8:test_result | Offset: 40, Length: 8, Signed: False Resolution: 1, Field Type: NUMBER, Match: , PartOfPrimaryKey: ,
    running_bit_offset = 40
    test_result = test_result_raw = decode_number(_data_raw_, running_bit_offset, 8, False, 1)
    nmea2000Message.fields.append(NMEA2000Field('test_result', 'Test result', "Values other than 0 are failure codes", None, test_result, test_result_raw, None, FieldTypes.NUMBER, False))
    running_bit_offset += 8

    return nmea2000Message

def encode_pgn_130944(nmea2000Message: NMEA2000Message) -> int:
    """Encode Nmea2000Message object to binary data for PGN 130944."""
    data_raw = 0
    # manufacturer_code | Offset: 0, Length: 11, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'manufacturer_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Manufacturer Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_MANUFACTURER_CODE(field.value)
    data_raw |= (field_value & 0x7FF) << 0
    # reserved_11 | Offset: 11, Length: 2, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_11')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x3) << 11
    # industry_code | Offset: 13, Length: 3, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'industry_code')
    if field is None:
        raise Exception("Cant encode this message, missing 'Industry Code'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_INDUSTRY_CODE(field.value)
    data_raw |= (field_value & 0x7) << 13
    # control | Offset: 16, Length: 1, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'control')
    if field is None:
        raise Exception("Cant encode this message, missing 'Control'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIRMAR_POST_CONTROL(field.value)
    data_raw |= (field_value & 0x1) << 16
    # reserved_17 | Offset: 17, Length: 7, Resolution: 1, Field Type: RESERVED
    field = next(f for f in nmea2000Message.fields if f.id == 'reserved_17')
    if field is None:
        raise Exception("Cant encode this message, missing 'Reserved'")
    field_value = field.value
    data_raw |= (field_value & 0x7F) << 17
    # number_of_id_test_result_pairs_to_follow | Offset: 24, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'number_of_id_test_result_pairs_to_follow')
    if field is None:
        raise Exception("Cant encode this message, missing 'Number of ID/test result pairs to follow'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 24
    # test_id | Offset: 32, Length: 8, Resolution: 1, Field Type: LOOKUP
    field = next(f for f in nmea2000Message.fields if f.id == 'test_id')
    if field is None:
        raise Exception("Cant encode this message, missing 'Test ID'")
    field_value = field.raw_value if field.raw_value is not None else lookup_encode_AIRMAR_POST_ID(field.value)
    data_raw |= (field_value & 0xFF) << 32
    # test_result | Offset: 40, Length: 8, Resolution: 1, Field Type: NUMBER
    field = next(f for f in nmea2000Message.fields if f.id == 'test_result')
    if field is None:
        raise Exception("Cant encode this message, missing 'Test result'")
    field_value = field.value
    data_raw |= (field_value & 0xFF) << 40
    return data_raw

